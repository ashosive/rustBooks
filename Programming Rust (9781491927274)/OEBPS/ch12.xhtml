<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Operator Overloading"><div class="chapter" id="operator-overloading">
<h1><span class="label">Chapter 12. </span>Operator Overloading</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>
There is a range of views among mathematicians and philosophers as to the exact scope and definition of mathematics. ...All have severe problems, none has widespread acceptance, and no reconciliation seems possible.
</p>
<p data-type="attribution">
Wikipedia, <a href="https://en.wikipedia.org/wiki/Mathematics#Definitions_of_mathematics">“Mathematics”</a>
</p>
</blockquote>

<p><a contenteditable="false" data-primary="operator overloading" data-type="indexterm" id="C12-operator.html0"/>In <a contenteditable="false" data-primary="types" data-secondary="and operator overloading" data-type="indexterm" id="idm45251614506072"/>the Mandelbrot set plotter we showed in <a data-type="xref" href="ch02.xhtml#a-tour-of-rust">Chapter 2</a>, we used the <code>num</code> crate’s <code>Complex</code> type to represent a number on the complex plane:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[derive(Clone, Copy, Debug)]</code><code class="w"/>
<code class="k">struct</code> <code class="nc">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Real portion of the complex number</code>
<code class="w">    </code><code class="n">re</code>: <code class="nc">T</code><code class="p">,</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Imaginary portion of the complex number</code>
<code class="w">    </code><code class="n">im</code>: <code class="nc">T</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We were able to add and multiply <code>Complex</code> numbers just like any built-in numeric type, using Rust’s <code>+</code> and <code>*</code> operators:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">c</code><code class="p">;</code><code class="w"/></pre>
<p>You can make your own types support arithmetic and other operators, too, just by implementing a few built-in traits. This is called <em>operator overloading</em>, and the effect is much like operator overloading in C++, C#, Python, and Ruby.</p>
<p><a contenteditable="false" data-primary="traits" data-secondary="for operator overloading" data-type="indexterm" id="idm45251614472344"/>The traits for operator overloading fall into a few categories depending on what part of the language they support, as shown in <a data-type="xref" href="#operator-traits-table">Table 12-1</a>. The remaining sections of this chapter cover each category in turn.</p>

<table id="operator-traits-table">
<caption><span class="label">Table 12-1. </span>
Summary of traits for operator overloading
</caption>
<thead>
<tr>
<th>
Category
</th>
<th>
Trait
</th>
<th>
Operator
</th>
</tr>
</thead>
<tbody class="border_bottom">
<tr>
<td rowspan="2">
Unary operators
</td>
<td>
<code>std::ops::Neg</code>
</td>
<td>
<code>-x</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::ops::Not</code>
</td>
<td>
<code>!x</code>
</td>
</tr>
<tr>
<td rowspan="5">
Arithmetic operators
</td>
<td>
<code>std::ops::Add</code>
</td>
<td>
<code>x + y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Sub</code>
</td>
<td>
<code>x - y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Mul</code>
</td>
<td>
<code>x * y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Div</code>
</td>
<td>
<code>x / y</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::ops::Rem</code>
</td>
<td>
<code>x % y</code>
</td>
</tr>
<tr>
<td rowspan="5">
Bitwise operators
</td>
<td>
<code>std::ops::BitAnd</code>
</td>
<td>
<code>x &amp; y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitOr</code>
</td>
<td>
<code>x | y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitXor</code>
</td>
<td>
<code>x ^ y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Shl</code>
</td>
<td>
<code>x &lt;&lt; y</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::ops::Shr</code>
</td>
<td>
<code>x &gt;&gt; y</code>
</td>
</tr>
<tr>
<td rowspan="5">
Compound assignment<br/>arithmetic operators
</td>
<td>
<code>std::ops::AddAssign</code>
</td>
<td>
<code>x += y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::SubAssign</code>
</td>
<td>
<code>x -= y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::MulAssign</code>
</td>
<td>
<code>x *= y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::DivAssign</code>
</td>
<td>
<code>x /= y</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::ops::RemAssign</code>
</td>
<td>
<code>x %= y</code>
</td>
</tr>
<tr>
<td rowspan="5">
Compound assignment<br/>bitwise operators
</td>
<td>
<code>std::ops::BitAndAssign</code>
</td>
<td>
<code>x &amp;= y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitOrAssign</code>
</td>
<td>
<code>x |= y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitXorAssign</code>
</td>
<td>
<code>x ^= y</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::ShlAssign</code>
</td>
<td>
<code>x &lt;&lt;= y</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::ops::ShrAssign</code>
</td>
<td>
<code>x &gt;&gt;= y</code>
</td>
</tr>
<tr>
<td rowspan="2">
Comparison
</td>
<td>
<code>std::cmp::PartialEq</code>
</td>
<td>
<code>x == y</code>, <code>x != y</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::cmp::PartialOrd</code>
</td>
<td>
<code>x &lt; y</code>,  <code>x &lt;= y</code>,  <code>x &gt; y</code>,  <code>x &gt;= y</code>
</td>
</tr>
<tr>
<td rowspan="2">
Indexing
</td>
<td>
<code>std::ops::Index</code>
</td>
<td>
<code>x[y]</code>,  <code>&amp;x[y]</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::IndexMut</code>
</td>
<td>
<code>x[y] = z</code>,  <code>&amp;mut x[y]</code>
</td>
</tr>
</tbody>
</table>

<section data-type="sect1" data-pdf-bookmark="Arithmetic and Bitwise Operators"><div class="sect1" id="arithmetic-traits">
<h1>Arithmetic and Bitwise Operators</h1>
<p><a contenteditable="false" data-primary="arithmetic operators" data-type="indexterm" id="C12-operator.html1"/><a contenteditable="false" data-primary="operator overloading" data-secondary="arithmetic/bitwise operators" data-type="indexterm" id="C12-operator.html2"/>In Rust, the expression <code>a + b</code> is actually shorthand for <code>a.add(b)</code>, a call to the <code>add</code> method of the standard library’s <code>std::ops::Add</code> trait. Rust’s standard numeric types all implement <code>std::ops::Add</code>. To make the expression <code>a + b</code> work for <code>Complex</code> values, the <code>num</code> crate implements this trait for <code>Complex</code> as well. Similar traits cover the other operators: <code>a * b</code> is shorthand for <code>a.mul(b)</code>, a method from the <code>std::ops::Mul</code> trait, <code>std::ops::Neg</code> covers the prefix <code>-</code> negation operator, and so on.</p>
<p>If you want to try writing out <code>z.add(c)</code>, you’ll need to bring the <code>Add</code> trait into scope, so that its method is visible. That done, you can treat all arithmetic as function calls:<sup><a data-type="noteref" id="idm45251614196008-marker" href="ch12.xhtml#idm45251614196008">1</a></sup></p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Add</code><code class="p">;</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">4.125</code><code class="k">f32</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="mf">5.75</code><code class="p">),</code><code class="w"> </code><code class="mf">9.875</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">10.</code><code class="n">add</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">20</code><code class="p">);</code><code class="w"/></pre>
<p>Here’s the definition of <code>std::ops::Add</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">Add</code><code class="o">&lt;</code><code class="n">RHS</code><code class="o">=</code><code class="n">Self</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="nc">RHS</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">Output</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In other words, the trait <code>Add&lt;T&gt;</code> is the ability to add a <code>T</code> value to yourself. For example, if you want to be able to add <code>i32</code> and <code>u32</code> values to your type, your type must implement both <code>Add&lt;i32&gt;</code> and <code>Add&lt;u32&gt;</code>. The trait’s type parameter <code>RHS</code> defaults to <code>Self</code>, so if you’re implementing addition between two values of the same type, you can simply write <code>Add</code> for that case. The associated type <code>Output</code> describes the result of the addition.</p>
<p>For example, to be able to add <code>Complex&lt;i32&gt;</code> values together, <code>Complex&lt;i32&gt;</code> must implement <code>Add&lt;Complex&lt;i32&gt;&gt;</code>. Since we’re adding a type to itself, we just write <code>Add</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Add</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">Add</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="nc">Self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="nc">self</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">re</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="nc">self</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Of course, we shouldn’t have to implement <code>Add</code> separately for <code>Complex&lt;i32&gt;</code>, <code>Complex&lt;f32&gt;</code>, <code>Complex&lt;f64&gt;</code>, and so on. All the definitions would look exactly the same except for the types involved, so we should be able to write a single generic implementation that covers them all, as long as the type of the complex components themselves supports addition:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Add</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Add</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nc">Add</code><code class="o">&lt;</code><code class="n">Output</code><code class="o">=</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Self</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="nc">Self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="nc">self</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">re</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="nc">self</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>By writing <code>where T: Add&lt;Output=T&gt;</code>, we restrict <code>T</code> to types that can be added to themselves, yielding another <code>T</code> value. This is a reasonable restriction, but we could loosen things still further: the <code>Add</code> trait doesn’t require both operands of <code>+</code> to have the same type, nor does it constrain the result type. So a maximally generic implementation would let the left- and right-hand operands vary independently, and produce a <code>Complex</code> value of whatever component type that addition produces:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Add</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">L</code><code class="p">,</code><code class="w"> </code><code class="n">R</code><code class="p">,</code><code class="w"> </code><code class="n">O</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Add</code><code class="o">&lt;</code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">L</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">L</code>: <code class="nc">Add</code><code class="o">&lt;</code><code class="n">R</code><code class="p">,</code><code class="w"> </code><code class="n">Output</code><code class="o">=</code><code class="n">O</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">O</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">Output</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="nc">self</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">re</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="nc">self</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In practice, however, Rust tends to avoid supporting mixed-type operations. Since our type parameter <code>L</code> must implement <code>Add&lt;R, Output=O&gt;</code>, it usually follows that <code>L</code>, <code>R</code>, and <code>O</code> are all going to be the same type: there simply aren’t that many types available for <code>L</code> that implement anything else. So in the end, this maximally generic version may not be much more useful than the prior, simpler generic definition.</p>

<p>Rust’s built-in traits for arithmetic and bitwise operators come in three groups: unary operators, binary operators, and compound assignment operators. Within each group, the traits and their methods all have the same form, so we’ll cover one example from each.</p>

<section data-type="sect2" data-pdf-bookmark="Unary Operators"><div class="sect2" id="unary-operators">
<h2>Unary Operators</h2>

<p><a contenteditable="false" data-primary="operator overloading" data-secondary="unary operators" data-type="indexterm" id="idm45251613706136"/><a contenteditable="false" data-primary="unary operators" data-type="indexterm" id="idm45251613704760"/>Aside from the dereferencing operator <code>*</code>, which we’ll cover separately in <a data-type="xref" href="ch13.xhtml#deref-and-derefmut">“Deref and DerefMut”</a>, Rust has two unary operators that you can customize, shown in <a data-type="xref" href="#built-in-traits-unary">Table 12-2</a>.</p>

<table id="built-in-traits-unary">
<caption><span class="label">Table 12-2. </span>
Built-in traits for unary operators
</caption>
<thead>
<tr>
<th>
Trait name
</th>
<th>
Expression
</th>
<th>
Equivalent expression
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>std::ops::Neg</code>
</td>
<td>
<code>-x</code>
</td>
<td>
<code>x.neg()</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Not</code>
</td>
<td>
<code>!x</code>
</td>
<td>
<code>x.not()</code>
</td>
</tr>
</tbody>
</table>

<p><a contenteditable="false" data-primary="- operator" data-type="indexterm" id="idm45251613690776"/><a contenteditable="false" data-primary="! operator" data-type="indexterm" id="idm45251613689448"/>All of Rust’s signed numeric types implement <code>std::ops::Neg</code>, for the unary negation operator <code>-</code>; the integer types and <code>bool</code> implement <code>std::ops::Not</code>, for the unary complement operator <code>!</code>. There are also implementations for references to those types.</p>
<p>Note that <code>!</code> complements <code>bool</code> values, and performs a bitwise complement (that is, flips the bits) when applied to integers; it plays the role of both the <code>!</code> and <code>~</code> operators from C and C++.</p>
<p>These traits’ definitions are simple:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">Neg</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">neg</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">Output</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">trait</code><code class="w"> </code><code class="n">Not</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">not</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">Output</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Negating a complex number simply negates each of its components. Here’s how we might write a generic implementation of negation for <code>Complex</code> values:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Neg</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">O</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Neg</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nc">Neg</code><code class="o">&lt;</code><code class="n">Output</code><code class="o">=</code><code class="n">O</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">O</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">neg</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Complex</code><code class="o">&lt;</code><code class="n">O</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="o">-</code><code class="bp">self</code><code class="p">.</code><code class="n">re</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="o">-</code><code class="bp">self</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Binary Operators"><div class="sect2" id="binary-operators">
<h2>Binary Operators</h2>

<p><a contenteditable="false" data-primary="arithmetic operators" data-secondary="binary operators" data-type="indexterm" id="idm45251613465384"/><a contenteditable="false" data-primary="binary operators" data-type="indexterm" id="idm45251613464008"/><a contenteditable="false" data-primary="bitwise operators" data-secondary="binary operators" data-type="indexterm" id="idm45251613462904"/><a contenteditable="false" data-primary="operator overloading" data-secondary="binary operators" data-type="indexterm" id="idm45251613461528"/>Rust’s binary arithmetic and bitwise operators and their corresponding built-in traits appear in <a data-type="xref" href="#built-in-traits-binary">Table 12-3</a>.</p>

<table id="built-in-traits-binary">
<caption><span class="label">Table 12-3. </span>
Built-in traits for binary operators
</caption>
<thead>
<tr>
<th>
Category
</th>
<th>
Trait name
</th>
<th>
Expression
</th>
<th>
Equivalent expression
</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="5">
Arithmetic operators
</td>
<td>
<code>std::ops::Add</code>
</td>
<td>
<code>x + y</code>
</td>
<td>
<code>x.add(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Sub</code>
</td>
<td>
<code>x - y</code>
</td>
<td>
<code>x.sub(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Mul</code>
</td>
<td>
<code>x * y</code>
</td>
<td>
<code>x.mul(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Div</code>
</td>
<td>
<code>x / y</code>
</td>
<td>
<code>x.div(y)</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::ops::Rem</code>
</td>
<td>
<code>x % y</code>
</td>
<td>
<code>x.rem(y)</code>
</td>
</tr>
<tr>
<td rowspan="5">
Bitwise operators
</td>
<td>
<code>std::ops::BitAnd</code>
</td>
<td>
<code>x &amp; y</code>
</td>
<td>
<code>x.bitand(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitOr</code>
</td>
<td>
<code>x | y</code>
</td>
<td>
<code>x.bitor(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitXor</code>
</td>
<td>
<code>x ^ y</code>
</td>
<td>
<code>x.bitxor(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Shl</code>
</td>
<td>
<code>x &lt;&lt; y</code>
</td>
<td>
<code>x.shl(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::Shr</code>
</td>
<td>
<code>x &gt;&gt; y</code>
</td>
<td>
<code>x.shr(y)</code>
</td>
</tr>
</tbody>
</table>
<p>All of Rust’s numeric types implement the arithmetic operators. Rust’s integer types and <code>bool</code> implement the bitwise operators. There are also implementations that accept references to those types as either or both operands.</p>
<p>All of the traits here have the same general form. The definition of <code>std::ops::BitXor</code>, for the <code>^</code> operator, looks like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">BitXor</code><code class="o">&lt;</code><code class="n">RHS</code><code class="o">=</code><code class="n">Self</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">bitxor</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="nc">RHS</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">Output</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>At the beginning of this chapter, we also showed <code>std::ops::Add</code>, another trait in this category, along with several sample implementations.</p>
<p>The <code>Shl</code> and <code>Shr</code> traits deviate slightly from this pattern: they do not default their <code>RHS</code> type parameter to <code>Self</code>, so you must always supply the righthand operand type explicitly. The right operand of a <code>&lt;&lt;</code> or <code>&gt;&gt;</code> operator is a bit shift distance, which doesn’t have much relationship to the type of the value being shifted.</p>

<p><a contenteditable="false" data-primary="+ operator" data-type="indexterm" id="idm45251613393096"/>You can use the <code>+</code> operator to concatenate a <code>String</code> with a <code>&amp;str</code> slice or another <code>String</code>. However, Rust does not permit the left operand of <code>+</code> to be a <code>&amp;str</code>, to discourage building up long strings by repeatedly concatenating small pieces on the left. (This performs poorly, requiring time quadratic in the final length of the string.) Generally, the <code>write!</code> macro is better for building up strings piece by piece; we show how to do this in <a data-type="xref" href="ch17.xhtml#appending-and-inserting-text">“Appending and Inserting Text”</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Compound Assignment Operators"><div class="sect2" id="compound-assignment-operators">
<h2>Compound Assignment Operators</h2>

<p><a contenteditable="false" data-primary="arithmetic operators" data-secondary="compound assignment operators" data-type="indexterm" id="C12-operator.html3"/><a contenteditable="false" data-primary="bitwise operators" data-secondary="compound assignment operators" data-type="indexterm" id="C12-operator.html4"/><a contenteditable="false" data-primary="compound assignment operators" data-type="indexterm" id="C12-operator.html5"/><a contenteditable="false" data-primary="operator overloading" data-secondary="compound assignment operators" data-type="indexterm" id="C12-operator.html6"/>A compound assignment expression is one like <code>x += y</code> or <code>x &amp;= y</code>: it takes two operands, performs some operation on them like addition or a bitwise AND, and stores the result back in the left operand. In Rust, the value of a compound assignment expression is always <code>()</code>, never the value stored.</p>

<p>Many languages have operators like these, and usually define them as shorthand for expressions like <code>x = x + y</code> or <code>x = x &amp; y</code>. However, Rust doesn’t take that approach. Instead, <code>x += y</code> is shorthand for the method call <code>x.add_assign(y)</code>, where <code>add_assign</code> is the sole method of the <code>std::ops::AddAssign</code> trait:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">AddAssign</code><code class="o">&lt;</code><code class="n">RHS</code><code class="o">=</code><code class="n">Self</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add_assign</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">RHS</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><a data-type="xref" href="#built-in-traits-compound">Table 12-4</a> shows all of Rust’s compound assignment operators, and the built-in traits that implement them.</p>

<table id="built-in-traits-compound" class="built-in-traits-table">
<caption><span class="label">Table 12-4. </span>
Built-in traits for compound assignment operators
</caption>
<thead>
<tr>
<th>
Category
</th>
<th>
Trait name
</th>
<th>
Expression
</th>
<th>
Equivalent expression
</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="5">
Arithmetic operators
</td>
<td>
<code>std::ops::AddAssign</code>
</td>
<td>
<code>x += y</code>
</td>
<td>
<code>x.add_assign(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::SubAssign</code>
</td>
<td>
<code>x -= y</code>
</td>
<td>
<code>x.sub_assign(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::MulAssign</code>
</td>
<td>
<code>x *= y</code>
</td>
<td>
<code>x.mul_assign(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::DivAssign</code>
</td>
<td>
<code>x /= y</code>
</td>
<td>
<code>x.div_assign(y)</code>
</td>
</tr>
<tr class="border_bottom">
<td>
<code>std::ops::RemAssign</code>
</td>
<td>
<code>x %= y</code>
</td>
<td>
<code>x.rem_assign(y)</code>
</td>
</tr>
<tr>
<td rowspan="5">
Bitwise operators
</td>
<td>
<code>std::ops::BitAndAssign</code>
</td>
<td>
<code>x &amp;= y</code>
</td>
<td>
<code>x.bitand_assign(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitOrAssign</code>
</td>
<td>
<code>x |= y</code>
</td>
<td>
<code>x.bitor_assign(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::BitXorAssign</code>
</td>
<td>
<code>x ^= y</code>
</td>
<td>
<code>x.bitxor_assign(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::ShlAssign</code>
</td>
<td>
<code>x &lt;&lt;= y</code>
</td>
<td>
<code>x.shl_assign(y)</code>
</td>
</tr>
<tr>
<td>
<code>std::ops::ShrAssign</code>
</td>
<td>
<code>x &gt;&gt;= y</code>
</td>
<td>
<code>x.shr_assign(y)</code>
</td>
</tr>
</tbody>
</table>

<p>All of Rust’s numeric types implement the arithmetic compound assignment operators. Rust’s integer types and <code>bool</code> implement the bitwise compound assignment operators.</p>

<p>A generic implementation of <code>AddAssign</code> for our <code>Complex</code> type is straightforward:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">AddAssign</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">AddAssign</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nc">AddAssign</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add_assign</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">re</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">rhs</code><code class="p">.</code><code class="n">im</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The built-in trait for a compound assignment operator is completely independent of the built-in trait for the corresponding binary operator. Implementing <code>std::ops::Add</code> does not automatically implement <code>std::ops::AddAssign</code>; if you want Rust to permit your type as the lefthand operand of a <code>+=</code> operator, you must implement <code>AddAssign</code> yourself.</p>

<p>As with the binary <code>Shl</code> and <code>Shr</code> traits, the <code>ShlAssign</code> and <code>ShrAssign</code> traits deviate slightly from the pattern followed by the other compound assignment traits: they do not default their <code>RHS</code> type parameter to <code>Self</code>, so you must always supply the right-hand operand type explicitly<a contenteditable="false" data-primary="" data-startref="C12-operator.html6" data-type="indexterm" id="idm45251613134056"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html5" data-type="indexterm" id="idm45251613132680"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html4" data-type="indexterm" id="idm45251613131304"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html3" data-type="indexterm" id="idm45251613129928"/>.<a contenteditable="false" data-primary="" data-startref="C12-operator.html2" data-type="indexterm" id="idm45251613128424"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html1" data-type="indexterm" id="idm45251613127016"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Equality Tests"><div class="sect1" id="eq">
<h1>Equality Tests</h1>

<p><a contenteditable="false" data-primary="equality operators" data-type="indexterm" id="C12-operator.html7"/><a contenteditable="false" data-primary="operator overloading" data-secondary="equality tests" data-type="indexterm" id="C12-operator.html8"/><a contenteditable="false" data-primary="PartialEq trait" data-type="indexterm" id="C12-operator.html9"/>Rust’s <a contenteditable="false" data-primary="!= operator" data-type="indexterm" id="idm45251613119000"/><a contenteditable="false" data-primary="== operator" data-type="indexterm" id="idm45251613117864"/>equality operators, <code>==</code> and <code>!=</code>, are shorthand for calls to the <code>std::cmp::PartialEq</code> trait’s <code>eq</code> and <code>ne</code> methods:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">x</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="n">eq</code><code class="p">(</code><code class="o">&amp;</code><code class="n">y</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">x</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="n">ne</code><code class="p">(</code><code class="o">&amp;</code><code class="n">y</code><code class="p">));</code><code class="w"/></pre>
<p>Here’s the definition of <code>std::cmp::PartialEq</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">PartialEq</code><code class="o">&lt;</code><code class="n">Rhs</code>: <code class="o">?</code><code class="nb">Sized</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Self</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">eq</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Rhs</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">ne</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Rhs</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"> </code><code class="o">!</code><code class="bp">self</code><code class="p">.</code><code class="n">eq</code><code class="p">(</code><code class="n">other</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Since the <code>ne</code> method has a default definition, you only need to define <code>eq</code> to implement the <code>PartialEq</code> trait, so here’s a complete implementation for <code>Complex</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nb">PartialEq</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">PartialEq</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">eq</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">im</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In other words, for any component type <code>T</code> that itself can be compared for equality, this implements comparison for <code>Complex&lt;T&gt;</code>. Assuming we’ve also implemented <code>std::ops::Mul</code> for <code>Complex</code> somewhere along the line, we can now write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="mi">2</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="mi">5</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="mi">29</code><code class="w"> </code><code class="p">});</code><code class="w"/></pre>

<p>Implementations of <code>PartialEq</code> are almost always of the form shown here: they compare each field of the left operand to the corresponding field of the right. These get tedious to write, and equality is a common operation to support, so if you ask, Rust will generate an implementation of <code>PartialEq</code> for you automatically. Simply add <code>PartialEq</code> to the type definition’s <code>derive</code> attribute like so:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[derive(Clone, Copy, Debug, PartialEq)]</code><code class="w"/>
<code class="k">struct</code> <code class="nc">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Rust’s automatically generated implementation is essentially identical to our hand-written code, comparing each field or element of the type in turn. Rust can derive <code>PartialEq</code> implementations for <code>enum</code> types as well. Naturally, each of the values the type holds (or might hold, in the case of an <code>enum</code>) must itself implement <code>PartialEq</code>.</p>

<p>Unlike the arithmetic and bitwise traits, which take their operands by value, <code>PartialEq</code> takes its operands by reference. This means that comparing non-<code>Copy</code> values like <code>String</code>s, <code>Vec</code>s, or <code>HashMap</code>s doesn’t cause them to be moved, which would be troublesome:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"d</code><code class="se">\x6f</code><code class="s">v</code><code class="se">\x65</code><code class="s">t</code><code class="se">\x61</code><code class="s">i</code><code class="se">\x6c</code><code class="s">"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"</code><code class="se">\x64</code><code class="s">o</code><code class="se">\x76</code><code class="s">e</code><code class="se">\x74</code><code class="s">a</code><code class="se">\x69</code><code class="s">l"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">s</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">t</code><code class="p">);</code><code class="w">  </code><code class="c1">// s and t are only borrowed...</code>

<code class="c1">// ... so they still have their values here.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{} {}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="n">t</code><code class="p">),</code><code class="w"> </code><code class="s">"dovetail dovetail"</code><code class="p">);</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="Rhs type parameter" data-type="indexterm" id="idm45251612736024"/>This leads us to the trait’s bound on the <code>Rhs</code> type parameter, which is of a kind we haven’t seen before:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">Rhs</code>: <code class="o">?</code><code class="nb">Sized</code><code class="w"/></pre>
<p>This relaxes Rust’s usual requirement that type parameters must be sized types, letting us write traits like <code>PartialEq&lt;str&gt;</code> or <code>PartialEq&lt;[T]&gt;</code>. The <code>eq</code> and <code>ne</code> methods take parameters of type <code>&amp;Rhs</code>, and comparing something with a <code>&amp;str</code> or a <code>&amp;[T]</code> is completely reasonable. Since <code>str</code> implements <code>PartialEq&lt;str&gt;</code>, the following assertions are equivalent:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="s">"ungula"</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="s">"ungulate"</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="s">"ungula"</code><code class="p">.</code><code class="n">ne</code><code class="p">(</code><code class="s">"ungulate"</code><code class="p">));</code><code class="w"/></pre>
<p>Here, both <code>Self</code> and <code>Rhs</code> would be the unsized type <code>str</code>, making <code>ne</code>’s <code>self</code> and <code>rhs</code> parameters both <code>&amp;str</code> values. We’ll discuss sized types, unsized types, and the <code>Sized</code> trait in detail in <a data-type="xref" href="ch13.xhtml#sized">“Sized”</a>.</p>
<p>Why is this trait called <code>PartialEq</code>? The traditional mathematical definition of an <em>equivalence relation</em>, of which equality is one instance, imposes three requirements. For any values <code>x</code> and <code>y</code>:</p>

<ul>
<li><p>If <code>x == y</code> is true, then <code>y == x</code> must be true as well. In other words, swapping the two sides of an equality comparison doesn’t affect the result.</p></li>
<li><p>If <code>x == y</code> and <code>y == z</code>, then it must be the case that <code>x == z</code>. Given any chain of values, each equal to the next, each value in the chain is directly equal to every other. Equality is contagious.</p></li>
<li><p>It must always be true that <code>x == x</code>.</p></li>
</ul>

<p>That last requirement might seem too obvious to be worth stating, but this is exactly where things go awry. Rust’s <code>f32</code> and <code>f64</code> are IEEE standard floating-point values. <a contenteditable="false" data-primary="NaN (not-a-number) values" data-type="indexterm" id="idm45251612509784"/><a contenteditable="false" data-primary="not-a-number (NaN) values" data-type="indexterm" id="idm45251612546952"/>According to that standard, expressions like <code>0.0/0.0</code> and others with no appropriate value must produce special <em>not-a-number</em> values, usually referred to as NaN values. The standard further requires that a NaN value be treated as unequal to every other value—including itself. For example, the standard requires all the following <span class="keep-together">behaviors:</span></p>

<pre data-type="programlisting" data-code-language="rust"><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="kt">f64</code>::<code class="n">is_nan</code><code class="p">(</code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/></pre>
<p>Furthermore, any ordered comparison with a NaN value must return false:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mf">0.0</code><code class="o">/</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/></pre>
<p>So while Rust’s <code>==</code> operator meets the first two requirements for equivalence relations, it clearly doesn’t meet the third when used on IEEE floating-point values. This is called a <em>partial equivalence relation</em>, so Rust uses the name <code>PartialEq</code> for the <code>==</code> operator’s built-in trait. If you write generic code with type parameters known only to be <code>PartialEq</code>, you may assume the first two requirements hold, but you should not assume that values always equal themselves.</p>
<p>That can be a bit counterintuitive, and may lead to bugs if you’re not vigilant. If you’d prefer your generic code to require a full equivalence relation, you can instead use the <code>std::cmp::Eq</code> trait as a bound, which represents a full equivalence relation: if a type implements <code>Eq</code>, then <code>x == x</code> must be <code>true</code> for every value <code>x</code> of that type. In practice, almost every type that implements <code>PartialEq</code> should implement <code>Eq</code> as well; <code>f32</code> and <code>f64</code> are the only types in the standard library that are <code>PartialEq</code> but not <code>Eq</code>.</p>
<p>The standard library defines <code>Eq</code> as an extension of <code>PartialEq</code>, adding no new <span class="keep-together">methods:</span></p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Eq</code>: <code class="nb">PartialEq</code><code class="o">&lt;</code><code class="n">Self</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>If your type is <code>PartialEq</code>, and you would like it to be <code>Eq</code> as well, you must explicitly implement <code>Eq</code>, even though you need not actually define any new functions or types to do so. So implementing <code>Eq</code> for our <code>Complex</code> type is quick:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nb">Eq</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">Eq</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>We could implement it even more succinctly by just including <code>Eq</code> in the <code>derive</code> attribute on the <code>Complex</code> type definition:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[derive(Clone, Copy, Debug, Eq, PartialEq)]</code><code class="w"/>
<code class="k">struct</code> <code class="nc">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Derived implementations on a generic type may depend on the type parameters. With the <code>derive</code> attribute, <code>Complex&lt;i32&gt;</code> would implement <code>Eq</code>, because <code>i32</code> does, but <code>Complex&lt;f32&gt;</code> would implement only <code>PartialEq</code>, since <code>f32</code> doesn’t implement <code>Eq</code>.</p>

<p>When you implement <code>std::cmp::PartialEq</code> yourself, Rust can’t check that your definitions for the <code>eq</code> and <code>ne</code> methods actually behave as required for partial or full equivalence. They could do anything you like. Rust simply takes your word that you’ve implemented equality in a way that meets the expectations of the trait’s users.</p>
<p>Although the definition of <code>PartialEq</code> provides a default definition for <code>ne</code>, you can provide your own implementation if you like. However, you must ensure that <code>ne</code> and <code>eq</code> are exact inverses of each other. Users of the <code>PartialEq</code> trait will assume this is so.<a contenteditable="false" data-primary="" data-startref="C12-operator.html9" data-type="indexterm" id="idm45251612217864"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html8" data-type="indexterm" id="idm45251612216488"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html7" data-type="indexterm" id="idm45251612215112"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Ordered Comparisons"><div class="sect1" id="ord">
<h1>Ordered Comparisons</h1>

<p><a contenteditable="false" data-primary="operator overloading" data-secondary="ordered comparisons" data-type="indexterm" id="C12-operator.html10"/><a contenteditable="false" data-primary="ordered comparison operators" data-type="indexterm" id="C12-operator.html11"/><a contenteditable="false" data-primary="PartialOrd trait" data-type="indexterm" id="C12-operator.html12"/>Rust specifies the behavior of the ordered comparison operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> all in terms of a single trait, <code>std::cmp::PartialOrd</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">PartialOrd</code><code class="o">&lt;</code><code class="n">Rhs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Self</code><code class="o">&gt;</code>: <code class="nb">PartialEq</code><code class="o">&lt;</code><code class="n">Rhs</code><code class="o">&gt;</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">Rhs</code>: <code class="o">?</code><code class="nb">Sized</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">partial_cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Rhs</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Ordering</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="k">fn</code> <code class="nf">lt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Rhs</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">le</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Rhs</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">gt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Rhs</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">ge</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Rhs</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Note that <code>PartialOrd&lt;Rhs&gt;</code> extends <code>PartialEq&lt;Rhs&gt;</code>: you can do ordered comparisons only on types that you can also compare for equality.</p>
<p>The only method of <code>PartialOrd</code> you must implement yourself is <code>partial_cmp</code>. When <code>partial_cmp</code> returns <code>Some(o)</code>, then <code>o</code> indicates <code>self</code>’s relationship to <code>other</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">Ordering</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Less</code><code class="p">,</code><code class="w">       </code><code class="c1">// self &lt; other</code>
<code class="w">    </code><code class="n">Equal</code><code class="p">,</code><code class="w">      </code><code class="c1">// self == other</code>
<code class="w">    </code><code class="n">Greater</code><code class="p">,</code><code class="w">    </code><code class="c1">// self &gt; other</code>
<code class="p">}</code><code class="w"/></pre>
<p>But if <code>partial_cmp</code> returns <code>None</code>, that means <code>self</code> and <code>other</code> are unordered with respect to each other: neither is greater than the other, nor are they equal. Among all of Rust’s primitive types, only comparisons between floating-point values ever return <code>None</code>: specifically, comparing a NaN (not-a-number) value with anything else returns <code>None</code>. We give some more background on NaN values in <a data-type="xref" href="#eq">“Equality Tests”</a>.</p>
<p>Like the other binary operators, to compare values of two types <code>Left</code> and <code>Right</code>, <code>Left</code> must implement <code>PartialOrd&lt;Right&gt;</code>. Expressions like <code>x &lt; y</code> or <code>x &gt;= y</code> are shorthand for calls to <code>PartialOrd</code> methods, as shown in <a data-type="xref" href="#built-in-traits-ord">Table 12-5</a>.</p>

<table id="built-in-traits-ord" class="tallrow">
<caption><span class="label">Table 12-5. </span>
Ordered comparison operators and PartialOrd methods
</caption>
<thead>
<tr>
<th>
Expression
</th>
<th>
Equivalent method call
</th>
<th>
Default definition
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>x &lt; y</code>
</td>
<td>
<code>x.lt(y)</code>
</td>
<td>
<code>x.partial_cmp(&amp;y) == Some(Less)</code>
</td>
</tr>
<tr>
<td>
<code>x &gt; y</code>
</td>
<td>
<code>x.gt(y)</code>
</td>
<td>
<code>x.partial_cmp(&amp;y) == Some(Greater)</code>
</td>
</tr>
<tr>
<td>
<code>x &lt;= y</code>
</td>
<td>
<code>x.le(y)</code>
</td>
<td>
<code>match x.partial_cmp(&amp;y) {<br/>  Some(Less) | Some(Equal) =&gt; true,<br/>  _ =&gt; false,<br/>}</code>
</td>
</tr>
<tr>
<td>
<code>x &gt;= y</code>
</td>
<td>
<code>x.ge(y)</code>
</td>
<td>
<code>match x.partial_cmp(&amp;y) {<br/>  Some(Greater) | Some(Equal) =&gt; true,<br/>  _ =&gt; false,<br/>}</code>
</td>
</tr>
</tbody>
</table>

<p>As in prior examples, the equivalent method call code shown assumes that <code>std::cmp::PartialOrd</code> and <code>std::cmp::Ordering</code> are in scope.</p>
<p>If you know that values of two types are always ordered with respect to each other, then you can implement the stricter <code>std::cmp::Ord</code> trait:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Ord</code>: <code class="nb">Eq</code> <code class="o">+</code><code class="w"> </code><code class="nb">PartialOrd</code><code class="o">&lt;</code><code class="n">Self</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Ordering</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>cmp</code> method here simply returns an <code>Ordering</code>, instead of an <code>Option&lt;Ordering&gt;</code> like <code>partial_cmp</code>: <code>cmp</code> always declares its arguments equal, or indicates their relative order. Almost all types that implement <code>PartialOrd</code> should also implement <code>Ord</code>. In the standard library, <code>f32</code> and <code>f64</code> are the only exceptions to this rule.</p>
<p>Since there’s no natural ordering on complex numbers, we can’t use our <code>Complex</code> type from the previous sections to show a sample implementation of <code>PartialOrd</code>. Instead, suppose you’re working with the following type, representing the set of numbers falling within a given half-open interval:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[derive(Debug, PartialEq)]</code><code class="w"/>
<code class="k">struct</code> <code class="nc">Interval</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">lower</code>: <code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="c1">// inclusive</code>
<code class="w">    </code><code class="n">upper</code>: <code class="nc">T</code><code class="w">  </code><code class="c1">// exclusive</code>
<code class="p">}</code><code class="w"/></pre>
<p>You’d like to make values of this type partially ordered: one interval is less than another if it falls entirely before the other, with no overlap. If two unequal intervals overlap, they’re unordered: some element of each side is less than some element of the other. And two equal intervals are simply equal. The following implementation of <code>PartialOrd</code> implements those rules:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="p">{</code><code class="n">Ordering</code><code class="p">,</code><code class="w"> </code><code class="nb">PartialOrd</code><code class="p">};</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nb">PartialOrd</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">PartialOrd</code><code class="o">&lt;</code><code class="n">Interval</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Interval</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">partial_cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Interval</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Ordering</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">other</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Ordering</code>::<code class="n">Equal</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">lower</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">upper</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Ordering</code>::<code class="n">Greater</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">upper</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">lower</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Ordering</code>::<code class="n">Less</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nb">None</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>With that implementation in place, you can write the following:<a contenteditable="false" data-primary="" data-startref="C12-operator.html12" data-type="indexterm" id="idm45251611850552"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html11" data-type="indexterm" id="idm45251611691224"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html10" data-type="indexterm" id="idm45251611689848"/></p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="n">upper</code>: <code class="mi">20</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">&lt;</code><code class="w">  </code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="n">upper</code>: <code class="mi">40</code><code class="w"> </code><code class="p">});</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">7</code><code class="p">,</code><code class="w">  </code><code class="n">upper</code>: <code class="mi">8</code><code class="w">  </code><code class="p">}</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">0</code><code class="p">,</code><code class="w">  </code><code class="n">upper</code>: <code class="mi">1</code><code class="w">  </code><code class="p">});</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">7</code><code class="p">,</code><code class="w">  </code><code class="n">upper</code>: <code class="mi">8</code><code class="w">  </code><code class="p">}</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">7</code><code class="p">,</code><code class="w">  </code><code class="n">upper</code>: <code class="mi">8</code><code class="w">  </code><code class="p">});</code><code class="w"/>

<code class="c1">// Overlapping intervals aren't ordered with respect to each other.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">left</code><code class="w">  </code><code class="o">=</code><code class="w"> </code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="n">upper</code>: <code class="mi">30</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">right</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Interval</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">lower</code>: <code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="n">upper</code>: <code class="mi">40</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="n">left</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">right</code><code class="p">));</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="n">left</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="n">right</code><code class="p">));</code><code class="w"/></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Index and IndexMut"><div class="sect1" id="index-and-indexmut">
<h1>Index and IndexMut</h1>

<p><a contenteditable="false" data-primary="Index trait" data-type="indexterm" id="C12-operator.html13"/><a contenteditable="false" data-primary="IndexMut trait" data-type="indexterm" id="C12-operator.html14"/><a contenteditable="false" data-primary="operator overloading" data-secondary="Index and IndexMut" data-type="indexterm" id="C12-operator.html15"/>You can specify how an indexing expression like <code>a[i]</code> works on your type by implementing the <code>std::ops::Index</code> and <code>std::ops::IndexMut</code> traits. Arrays support the <code>[]</code> operator directly, but on any other type, the expression <code>a[i]</code> is normally shorthand for <code>*a.index(i)</code>, where <code>index</code> is a method of the <code>std::ops::Index</code> trait. However, if the expression is being assigned to or borrowed mutably, it’s instead shorthand for <code>*a.index_mut(i)</code>, a call to the method of the <code>std::ops::IndexMut</code> trait.</p>
<p>Here are the traits’ definitions:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">Index</code><code class="o">&lt;</code><code class="n">Idx</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code>: <code class="o">?</code><code class="nb">Sized</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">index</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">index</code>: <code class="nc">Idx</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">Self</code>::<code class="n">Output</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">trait</code><code class="w"> </code><code class="n">IndexMut</code><code class="o">&lt;</code><code class="n">Idx</code><code class="o">&gt;</code>: <code class="nc">Index</code><code class="o">&lt;</code><code class="n">Idx</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">index_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">index</code>: <code class="nc">Idx</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Self</code>::<code class="n">Output</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Note that these traits take the type of the index expression as a parameter. You can index a slice with a single <code>usize</code>, referring to a single element, because slices implement <code>Index&lt;usize&gt;</code>. But you can refer to a subslice with an expression like <code>a[i..j]</code> because they also implement <code>Index&lt;Range&lt;usize&gt;&gt;</code>. That expression is shorthand for:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="o">*</code><code class="n">a</code><code class="p">.</code><code class="n">index</code><code class="p">(</code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Range</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">start</code>: <code class="nc">i</code><code class="p">,</code><code class="w"> </code><code class="n">end</code>: <code class="nc">j</code><code class="w"> </code><code class="p">})</code><code class="w"/></pre>
<p>Rust’s <code>HashMap</code> and <code>BTreeMap</code> collections let you use any hashable or ordered type as the index. The following code works because <code>HashMap&lt;&amp;str, i32&gt;</code> implements <code>Index&lt;&amp;str&gt;</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">HashMap</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashMap</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"十"</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">);</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"百"</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">);</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"千"</code><code class="p">,</code><code class="w"> </code><code class="mi">1000</code><code class="p">);</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"万"</code><code class="p">,</code><code class="w"> </code><code class="mi">1_0000</code><code class="p">);</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"億"</code><code class="p">,</code><code class="w"> </code><code class="mi">1_0000_0000</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">m</code><code class="p">[</code><code class="s">"十"</code><code class="p">],</code><code class="w"> </code><code class="mi">10</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">m</code><code class="p">[</code><code class="s">"千"</code><code class="p">],</code><code class="w"> </code><code class="mi">1000</code><code class="p">);</code><code class="w"/></pre>
<p>Those indexing expressions are equivalent to:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Index</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">m</code><code class="p">.</code><code class="n">index</code><code class="p">(</code><code class="s">"十"</code><code class="p">),</code><code class="w"> </code><code class="mi">10</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">m</code><code class="p">.</code><code class="n">index</code><code class="p">(</code><code class="s">"千"</code><code class="p">),</code><code class="w"> </code><code class="mi">1000</code><code class="p">);</code><code class="w"/></pre>

<p>The <code>Index</code> trait’s associated type <code>Output</code> specifies what type an indexing expression produces: for our <code>HashMap</code>, the <code>Index</code> implementation’s <code>Output</code> type is <code>i32</code>.</p>

<p>The <code>IndexMut</code> trait extends <code>Index</code> with an <code>index_mut</code> method that takes a mutable reference to <code>self</code>, and returns a mutable reference to an <code>Output</code> value. Rust automatically selects <code>index_mut</code> when the indexing expression occurs in a context where it’s necessary. For example, suppose we write the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">desserts</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"Howalon"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                        </code><code class="s">"Soan papdi"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()];</code><code class="w"/>
<code class="n">desserts</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">push_str</code><code class="p">(</code><code class="s">" (fictional)"</code><code class="p">);</code><code class="w"/>
<code class="n">desserts</code><code class="p">[</code><code class="mi">1</code><code class="p">].</code><code class="n">push_str</code><code class="p">(</code><code class="s">" (real)"</code><code class="p">);</code><code class="w"/></pre>
<p>Because the <code>push_str</code> method operates on <code>&amp;mut self</code>, those last two lines are equivalent to:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">IndexMut</code><code class="p">;</code><code class="w"/>
<code class="p">(</code><code class="o">*</code><code class="n">desserts</code><code class="p">.</code><code class="n">index_mut</code><code class="p">(</code><code class="mi">0</code><code class="p">)).</code><code class="n">push_str</code><code class="p">(</code><code class="s">" (fictional)"</code><code class="p">);</code><code class="w"/>
<code class="p">(</code><code class="o">*</code><code class="n">desserts</code><code class="p">.</code><code class="n">index_mut</code><code class="p">(</code><code class="mi">1</code><code class="p">)).</code><code class="n">push_str</code><code class="p">(</code><code class="s">" (real)"</code><code class="p">);</code><code class="w"/></pre>
<p>One limitation of <code>IndexMut</code> is that, by design, it must return a mutable reference to some value. This is why you can’t use an expression like <code>m["十"] = 10;</code> to insert a value into the <code>HashMap</code> <code>m</code>: the table would need to create an entry for <code>"十"</code> first, with some default value, and return a mutable reference to that. But not all types have cheap default values, and some may be expensive to drop; it would be a waste to create such a value only to be immediately dropped by the assignment. (There are plans to improve this in later versions of the language.)</p>
<p>The most common use of indexing is for collections. For example, suppose we are working with bitmapped images, like the ones we created in the Mandelbrot set plotter in <a data-type="xref" href="ch02.xhtml#a-tour-of-rust">Chapter 2</a>. Recall that our program contained code like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">pixels</code><code class="p">[</code><code class="n">row</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">column</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...;</code><code class="w"/></pre>
<p>It would be nicer to have an <code>Image&lt;u8&gt;</code> type that acts like a two-dimensional array, allowing us to access pixels without having to write out all the arithmetic:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">image</code><code class="p">[</code><code class="n">row</code><code class="p">][</code><code class="n">column</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...;</code><code class="w"/></pre>
<p>To do this, we’ll need to declare a struct:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Image</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">width</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">pixels</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">P</code>: <code class="nb">Default</code> <code class="o">+</code><code class="w"> </code><code class="nb">Copy</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Image</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Create a new image of the given size.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">new</code><code class="p">(</code><code class="n">width</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="n">height</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Image</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Image</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">width</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">pixels</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[</code><code class="n">P</code>::<code class="n">default</code><code class="p">();</code><code class="w"> </code><code class="n">width</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">height</code><code class="p">]</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>And here are implementations of <code>Index</code> and <code>IndexMut</code> that would fit the bill:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Index</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Image</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="n">P</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">index</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">row</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="p">[</code><code class="n">P</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">start</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">row</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">width</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="o">&amp;</code><code class="bp">self</code><code class="p">.</code><code class="n">pixels</code><code class="p">[</code><code class="n">start</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">start</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">width</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">IndexMut</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Image</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">index_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">row</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="p">[</code><code class="n">P</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">start</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">row</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">width</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">pixels</code><code class="p">[</code><code class="n">start</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">start</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">width</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>When you index into an <code>Image</code>, you get back a slice of pixels; indexing the slice gives you an individual pixel.</p>
<p>Note that when we write <code>image[row][column]</code>, if <code>row</code> is out of bounds, our <code>.index()</code> method will try to index <code>self.pixels</code> out of range, triggering a panic. This is how <code>Index</code> and <code>IndexMut</code> implementations are supposed to behave: out-of-bounds access is detected and causes a panic, the same as when you index an array, slice, or vector out of bounds.<a contenteditable="false" data-primary="" data-startref="C12-operator.html15" data-type="indexterm" id="idm45251610575368"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html14" data-type="indexterm" id="idm45251610574104"/><a contenteditable="false" data-primary="" data-startref="C12-operator.html13" data-type="indexterm" id="idm45251610572728"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Other Operators"><div class="sect1" id="other-operators">
<h1>Other Operators</h1>

<p><a contenteditable="false" data-primary="operator overloading" data-secondary="limitations on" data-type="indexterm" id="idm45251610570152"/>Not all operators can be overloaded in Rust. As of Rust 1.17, the error-checking <code>?</code> operator works only with <code>Result</code> values. Similarly, the logical operators <code>&amp;&amp;</code> and <code>||</code> are limited to Boolean values only. The <code>..</code> operator always creates <code>Range</code> values, the <code>&amp;</code> operator always borrows references, and the <code>=</code> operator always moves or copies values. None of them can be overloaded.</p>
<p>The dereferencing operator, <code>*val</code>, and the dot operator for accessing fields and calling methods, as in <code>val.field</code> and <code>val.method()</code>, can be overloaded using the <code>Deref</code> and <code>DerefMut</code> traits, which are covered in the next chapter. (We did not include them here because these traits do more than just overload a few operators.)</p>
<p>Rust does not support overloading the function call operator, <code>f(x)</code>. Instead, when you need a callable value, you’ll typically just write a closure. We’ll explain how this works and cover the <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> special traits in <a data-type="xref" href="ch14.xhtml#closures">Chapter 14</a>.<a contenteditable="false" data-primary="" data-startref="C12-operator.html0" data-type="indexterm" id="idm45251610558680"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45251614196008"><sup><a href="ch12.xhtml#idm45251614196008-marker">1</a></sup> Lisp programmers rejoice! The expression <code>&lt;i32 as Add&gt;::add</code> is the <code>+</code> operator on <code>i32</code>, captured as a function value.</p></div></div></section></div></body>
</html>