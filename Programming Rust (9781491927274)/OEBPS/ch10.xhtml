<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Enums and Patterns"><div class="chapter" id="enums-and-patterns">
<h1><span class="label">Chapter 10. </span>Enums and Patterns</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>Surprising how much computer stuff makes sense viewed as tragic deprivation of sum types (cf. deprivation of lambdas)</p>
<p data-type="attribution"><a href="https://twitter.com/graydon_pub/status/555046888714416128">Graydon Hoare</a></p>
</blockquote>

<p><a contenteditable="false" data-primary="enums" data-type="indexterm" id="C10-enums.html0"/>The first topic of this chapter is potent, as old as the hills, happy to help you get a lot done in short order (for a price), and known by many names in many cultures. But it’s not the devil. It’s a kind of user-defined data type, long known to ML and Haskell hackers as sum types, discriminated unions, or algebraic data types. In Rust, they are called <em>enumerations</em>, or simply <em>enums</em>. Unlike the devil, they are quite safe, and the price they ask is no great privation.</p>
<p>C++ and C# have enums; you can use them to define your own type whose values are a set of named constants. For example, you might define a type named <code>Color</code> with values <code>Red</code>, <code>Orange</code>, <code>Yellow</code>, and so on. This kind of enum works in Rust, too. But Rust takes enums much further. A Rust enum can also contain data, even data of varying types. For example, Rust’s <code>Result&lt;String, io::Error&gt;</code> type is an enum; such a value is either an <code>Ok</code> value containing a <code>String</code>, or an <code>Err</code> value containing an <code>io::Error</code>. This is beyond what C++ and C# enums can do. It’s more like a C <code>union</code>—but unlike unions, Rust enums are type-safe.</p>
<p>Enums are useful whenever a value might be either one thing or another. The “price” of using them is that you must access the data safely, using pattern matching, our topic for the second half of this chapter.</p>
<p>Patterns, too, may be familiar if you’ve used unpacking in Python or destructuring in JavaScript, but Rust takes patterns further. Rust patterns are a little like regular expressions for all your data. They’re used to test whether or not a value has a particular desired shape. They can extract several fields from a struct or tuple into local variables all at once. And like regular expressions, they are concise, typically doing it all in a single line of code.</p>

<section data-type="sect1" data-pdf-bookmark="Enums"><div class="sect1" id="enums">
<h1>Enums</h1>

<p><a contenteditable="false" data-primary="enums" data-secondary="C-style" data-type="indexterm" id="idm45251625503272"/>Simple, C-style enums are straightforward:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">Ordering</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Less</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">Equal</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">Greater</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This declares a type <code>Ordering</code> with three possible values, called <em>variants</em> or <em>constructors</em>: <code>Ordering::Less</code>, <code>Ordering::Equal</code>, and <code>Ordering::Greater</code>. This particular enum is part of the standard library, so Rust code can import it, either by itself:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="n">Ordering</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">compare</code><code class="p">(</code><code class="n">n</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">m</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Ordering</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Ordering</code>::<code class="n">Less</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Ordering</code>::<code class="n">Greater</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Ordering</code>::<code class="n">Equal</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>or with all its constructors:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="n">Ordering</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="n">Ordering</code>::<code class="o">*</code><code class="p">;</code><code class="w">    </code><code class="c1">// `*` to import all children</code>

<code class="k">fn</code> <code class="nf">compare</code><code class="p">(</code><code class="n">n</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">m</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Ordering</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Less</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Greater</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Equal</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>After importing the constructors, we can write <code>Less</code> instead of <code>Ordering::Less</code>, and so on, but because this is less explicit, it’s generally considered better style <em>not</em> to import them except when it makes your code much more readable.</p>
<p>To import the constructors of an enum declared in the current module, use a <code>self</code> import:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">Pet</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Orca</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">Giraffe</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="bp">self</code>::<code class="n">Pet</code>::<code class="o">*</code><code class="p">;</code><code class="w"/></pre>
<p>In memory, values of C-style enums are stored as integers. Occasionally it’s useful to tell Rust which integers to use:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">HttpStatus</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">200</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">NotModified</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">304</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">NotFound</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">404</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Otherwise Rust will assign the numbers for you, starting at 0.</p>

<p>By default, Rust stores C-style enums using the smallest built-in integer type that can accommodate them. Most fit in a single byte.</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">size_of</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">size_of</code>::<code class="o">&lt;</code><code class="n">Ordering</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">size_of</code>::<code class="o">&lt;</code><code class="n">HttpStatus</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w">  </code><code class="c1">// 404 doesn't fit in a u8</code></pre>
<p>You can override Rust’s choice of in-memory representation by adding a <code>#[repr]</code> attribute to the enum. For details, see <a data-type="xref" href="ch21.xhtml#unsafe-code">Chapter 21</a>.</p>
<p>Casting a C-style enum to an integer is allowed:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">HttpStatus</code>::<code class="nb">Ok</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="mi">200</code><code class="p">);</code><code class="w"/></pre>
<p>However, casting in the other direction, from the integer to the enum, is not. Unlike C and C++, Rust guarantees that an enum value is only ever one of the values spelled out in the <code>enum</code> declaration. An unchecked cast from an integer type to an enum type could break this guarantee, so it’s not allowed. You can either write your own checked conversion:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">http_status_from_u32</code><code class="p">(</code><code class="n">n</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">HttpStatus</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="mi">200</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">HttpStatus</code>::<code class="nb">Ok</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="mi">304</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">HttpStatus</code>::<code class="n">NotModified</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="mi">404</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">HttpStatus</code>::<code class="n">NotFound</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="p">...</code><code class="w"/>
<code class="w">        </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>or use <a href="https://crates.io/crates/enum_primitive">the <code>enum_primitive</code> crate</a>. It contains a macro that autogenerates this kind of conversion code for you.</p>

<p>As with structs, the compiler will implement features like the <code>==</code> operator for you, but you have to ask.</p>
<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[derive(Copy, Clone, Debug, PartialEq)]</code><code class="w"/>
<code class="k">enum</code> <code class="nc">TimeUnit</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Seconds</code><code class="p">,</code><code class="w"> </code><code class="n">Minutes</code><code class="p">,</code><code class="w"> </code><code class="n">Hours</code><code class="p">,</code><code class="w"> </code><code class="n">Days</code><code class="p">,</code><code class="w"> </code><code class="n">Months</code><code class="p">,</code><code class="w"> </code><code class="n">Years</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Enums can have methods, just like structs:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="n">TimeUnit</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Return the plural noun for this time unit.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">plural</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">TimeUnit</code>::<code class="n">Seconds</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"seconds"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">TimeUnit</code>::<code class="n">Minutes</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"minutes"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">TimeUnit</code>::<code class="n">Hours</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"hours"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">TimeUnit</code>::<code class="n">Days</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"days"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">TimeUnit</code>::<code class="n">Months</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"months"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">TimeUnit</code>::<code class="n">Years</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"years"</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Return the singular noun for this time unit.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">singular</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">plural</code><code class="p">().</code><code class="n">trim_right_matches</code><code class="p">(</code><code class="sc">'s'</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>So much for C-style enums. The more interesting sort of Rust enum is the kind that contains data.</p>

<section data-type="sect2" data-pdf-bookmark="Enums with Data"><div class="sect2" id="enums-with-data">
<h2>Enums with Data</h2>

<p><a contenteditable="false" data-primary="enums" data-secondary="with data" data-type="indexterm" id="idm45251624712600"/>Some programs always need to display full dates and times down to the millisecond, but for most applications, it’s more user-friendly to use a rough approximation, like “two months ago.” We can write an enum to help with that:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="sd">/// A timestamp that has been deliberately rounded off, so our program</code>
<code class="sd">/// says "6 months ago" instead of "February 9, 2016, at 9:49 AM".</code>
<code class="cp">#[derive(Copy, Clone, Debug, PartialEq)]</code><code class="w"/>
<code class="k">enum</code> <code class="nc">RoughTime</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">InThePast</code><code class="p">(</code><code class="n">TimeUnit</code><code class="p">,</code><code class="w"> </code><code class="kt">u32</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">JustNow</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">InTheFuture</code><code class="p">(</code><code class="n">TimeUnit</code><code class="p">,</code><code class="w"> </code><code class="kt">u32</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p class="pagebreak-before">Two of the variants in this enum, <code>InThePast</code> and <code>InTheFuture</code>, take arguments. These are called <em>tuple variants</em>. Like tuple structs, these constructors are functions that create new <code>RoughTime</code> values.</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">four_score_and_seven_years_ago</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">RoughTime</code>::<code class="n">InThePast</code><code class="p">(</code><code class="n">TimeUnit</code>::<code class="n">Years</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="o">*</code><code class="mi">20</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">7</code><code class="p">);</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">three_hours_from_now</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">RoughTime</code>::<code class="n">InTheFuture</code><code class="p">(</code><code class="n">TimeUnit</code>::<code class="n">Hours</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/></pre>
<p>Enums can also have <em>struct variants</em>, which contain named fields, just like ordinary structs:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Sphere</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">center</code>: <code class="nc">Point3d</code><code class="p">,</code><code class="w"> </code><code class="n">radius</code>: <code class="kt">f32</code> <code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="n">Cuboid</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">corner1</code>: <code class="nc">Point3d</code><code class="p">,</code><code class="w"> </code><code class="n">corner2</code>: <code class="nc">Point3d</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">unit_sphere</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Shape</code>::<code class="n">Sphere</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">center</code>: <code class="nc">ORIGIN</code><code class="p">,</code><code class="w"> </code><code class="n">radius</code>: <code class="mf">1.0</code><code class="w"> </code><code class="p">};</code><code class="w"/></pre>

<p>In all, Rust has three kinds of enum variant, echoing the three kinds of struct we showed in the previous chapter. Variants with no data correspond to unit-like structs. Tuple variants look and function just like tuple structs. Struct variants have curly braces and named fields. A single enum can have variants of all three kinds.</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">RelationshipStatus</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Single</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">InARelationship</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">ItsComplicated</code><code class="p">(</code><code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">ItsExtremelyComplicated</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">car</code>: <code class="nc">DifferentialEquation</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">cdr</code>: <code class="nc">EarlyModernistPoem</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>All constructors and fields of a public enum are automatically public.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Enums in Memory"><div class="sect2" id="enums-in-memory">
<h2>Enums in Memory</h2>

<p><a contenteditable="false" data-primary="enums" data-secondary="in memory" data-type="indexterm" id="idm45251624495976"/><a contenteditable="false" data-primary="memory" data-secondary="enums in" data-type="indexterm" id="idm45251624494600"/>In memory, enums with data are stored as a small integer <em>tag</em>, plus enough memory to hold all the fields of the largest variant. The tag field is for Rust’s internal use. It tells which constructor created the value, and therefore which fields it has.</p>
<p>As of Rust 1.17, <code>RoughTime</code> fits in 8 bytes, as shown in <a data-type="xref" href="#rough-time-layout-figure">Figure 10-1</a>.</p>

<figure><div id="rough-time-layout-figure" class="figure">
<img src="Images/rust_1001.png" alt="Diagram showing how the fields of various RoughTime values fit in 8 bytes of memory." width="855" height="581"/>
<h6><span class="label">Figure 10-1. </span>
RoughTime values in memory
</h6>
</div></figure>

<p>Rust makes no promises about enum layout, however, in order to leave the door open for future optimizations. In some cases, it would be possible to pack an enum more efficiently than the figure suggests. We’ll show later in this chapter how Rust can already optimize away the tag field for some enums.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Rich Data Structures Using Enums"><div class="sect2" id="rich-data-structures-using-enums">
<h2>Rich Data Structures Using Enums</h2>

<p><a contenteditable="false" data-primary="enums" data-secondary="implementing rich data structures with" data-type="indexterm" id="C10-enums.html1"/><a contenteditable="false" data-primary="structs" data-secondary="implementing with enums" data-type="indexterm" id="C10-enums.html2"/>Enums are also useful for quickly implementing tree-like data structures. For example, suppose a Rust program needs to work with arbitrary JSON data. In memory, any JSON document can be represented as a value of this Rust type:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">Json</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Null</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">Boolean</code><code class="p">(</code><code class="kt">bool</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">Number</code><code class="p">(</code><code class="kt">f64</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nb">String</code><code class="p">(</code><code class="nb">String</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">Array</code><code class="p">(</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Json</code><code class="o">&gt;</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">Object</code><code class="p">(</code><code class="nb">Box</code><code class="o">&lt;</code><code class="n">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">Json</code><code class="o">&gt;&gt;</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The explanation of this data structure in English can’t improve much upon the Rust code. The JSON standard specifies the various data types that can appear in a JSON document: <code>null</code>, Boolean values, numbers, strings, arrays of JSON values, and objects with string keys and JSON values. The <code>Json</code> enum simply spells out these types.</p>

<p>This is not a hypothetical example. A very similar enum can be found in <code>serde_json</code>, a serialization library for Rust structs that is one of the most-downloaded crates on <a href="https://crates.io" class="orm:hideurl">crates.io</a>.</p>

<p>The <code>Box</code> around the <code>HashMap</code> that represents an <code>Object</code> serves only to make all <code>Json</code> values more compact. In memory, values of type <code>Json</code> take up four machine words. <code>String</code> and <code>Vec</code> values are three words, and Rust adds a tag byte. <code>Null</code> and <code>Boolean</code> values don’t have enough data in them to use up all that space, but all <code>Json</code> values must be the same size. The extra space goes unused. <a data-type="xref" href="#json-layout-figure">Figure 10-2</a> shows some examples of how <code>Json</code> values actually look in memory.</p>
<p>A <code>HashMap</code> is larger still. If we had to leave room for it in every <code>Json</code> value, they would be quite large, eight words or so. But a <code>Box&lt;HashMap&gt;</code> is a single word: it’s just a pointer to heap-allocated data. We could make <code>Json</code> even more compact by boxing more fields.</p>

<figure><div id="json-layout-figure" class="figure">
<img src="Images/rust_1002.png" alt="Diagram showing how the fields of various Json values fit in 4 words of memory." width="1311" height="509"/>
<h6><span class="label">Figure 10-2. </span>
Json values in memory
</h6>
</div></figure>

<p>What’s remarkable here is how easy it was to set this up. In C++, one might write a class for this:</p>
<pre class="cpp" data-type="programlisting" data-code-language="cpp"><code class="k">class</code> <code class="nc">JSON</code> <code class="p">{</code>
<code class="k">private</code><code class="o">:</code>
    <code class="k">enum</code> <code class="n">Tag</code> <code class="p">{</code>
        <code class="n">Null</code><code class="p">,</code> <code class="n">Boolean</code><code class="p">,</code> <code class="n">Number</code><code class="p">,</code> <code class="n">String</code><code class="p">,</code> <code class="n">Array</code><code class="p">,</code> <code class="n">Object</code>
    <code class="p">};</code>
    <code class="k">union</code> <code class="n">Data</code> <code class="p">{</code>
        <code class="kt">bool</code> <code class="n">boolean</code><code class="p">;</code>
        <code class="kt">double</code> <code class="n">number</code><code class="p">;</code>
        <code class="n">shared_ptr</code><code class="o">&lt;</code><code class="n">string</code><code class="o">&gt;</code> <code class="n">str</code><code class="p">;</code>
        <code class="n">shared_ptr</code><code class="o">&lt;</code><code class="n">vector</code><code class="o">&lt;</code><code class="n">JSON</code><code class="o">&gt;&gt;</code> <code class="n">array</code><code class="p">;</code>
        <code class="n">shared_ptr</code><code class="o">&lt;</code><code class="n">unordered_map</code><code class="o">&lt;</code><code class="n">string</code><code class="p">,</code> <code class="n">JSON</code><code class="o">&gt;&gt;</code> <code class="n">object</code><code class="p">;</code>

        <code class="n">Data</code><code class="p">()</code> <code class="p">{}</code>
        <code class="o">~</code><code class="n">Data</code><code class="p">()</code> <code class="p">{}</code>
        <code class="p">...</code>
    <code class="p">};</code>

    <code class="n">Tag</code> <code class="n">tag</code><code class="p">;</code>
    <code class="n">Data</code> <code class="n">data</code><code class="p">;</code>

<code class="k">public</code><code class="o">:</code>
    <code class="kt">bool</code> <code class="n">is_null</code><code class="p">()</code> <code class="k">const</code> <code class="p">{</code> <code class="k">return</code> <code class="n">tag</code> <code class="o">==</code> <code class="n">Null</code><code class="p">;</code> <code class="p">}</code>
    <code class="kt">bool</code> <code class="n">is_boolean</code><code class="p">()</code> <code class="k">const</code> <code class="p">{</code> <code class="k">return</code> <code class="n">tag</code> <code class="o">==</code> <code class="n">Boolean</code><code class="p">;</code> <code class="p">}</code>
    <code class="kt">bool</code> <code class="n">get_boolean</code><code class="p">()</code> <code class="k">const</code> <code class="p">{</code>
        <code class="n">assert</code><code class="p">(</code><code class="n">is_boolean</code><code class="p">());</code>
        <code class="k">return</code> <code class="n">data</code><code class="p">.</code><code class="n">boolean</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="kt">void</code> <code class="n">set_boolean</code><code class="p">(</code><code class="kt">bool</code> <code class="n">value</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="o">-&gt;~</code><code class="n">JSON</code><code class="p">();</code>  <code class="c1">// clean up string/array/object value</code>
        <code class="n">tag</code> <code class="o">=</code> <code class="n">Boolean</code><code class="p">;</code>
        <code class="n">data</code><code class="p">.</code><code class="n">boolean</code> <code class="o">=</code> <code class="n">value</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="p">...</code>
<code class="p">};</code></pre>
<p>At 30 lines of code, we have barely begun the work. This class will need constructors, a destructor, and an assignment operator. An alternative would be to create a class hierarchy with a base class <code>JSON</code> and subclasses <code>JSONBoolean</code>, <code>JSONString</code>, and so on. Either way, when it’s done, our C++ JSON library will have more than a dozen methods. It will take a bit of reading for other programmers to pick it up and use it. The entire Rust enum is eight lines of code.<a contenteditable="false" data-primary="" data-startref="C10-enums.html2" data-type="indexterm" id="idm45251624329480"/><a contenteditable="false" data-primary="" data-startref="C10-enums.html1" data-type="indexterm" id="idm45251624129944"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Generic Enums"><div class="sect2" id="generic-enums">
<h2>Generic Enums</h2>

<p><a contenteditable="false" data-primary="enums" data-secondary="generic" data-type="indexterm" id="C10-enums.html3"/><a contenteditable="false" data-primary="generic enums" data-type="indexterm" id="C10-enums.html4"/>Enums can be generic. Two examples from the standard library are among the most-used data types in the language:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nb">Option</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">T</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">enum</code> <code class="nb">Result</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">T</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nb">Err</code><code class="p">(</code><code class="n">E</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>These types are familiar enough by now, and the syntax for generic enums is the same as for generic structs. One unobvious detail is that Rust can eliminate the tag field of <code>Option&lt;T&gt;</code> when the type <code>T</code> is a <code>Box</code> or some other smart pointer type. An <code>Option&lt;Box&lt;i32&gt;&gt;</code> is stored in memory as a single machine word, 0 for <code>None</code> and nonzero for <code>Some</code> boxed value.</p>
<p>Generic data structures can be built with just a few lines of code:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// An ordered collection of `T`s.</code>
<code class="k">enum</code> <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Empty</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code><code class="o">&lt;</code><code class="n">TreeNode</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// A part of a BinaryTree.</code>
<code class="k">struct</code> <code class="nc">TreeNode</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">element</code>: <code class="nc">T</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">left</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">right</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>These few lines of code define a <code>BinaryTree</code> type that can store any number of values of type <code>T</code>.</p>

<p>A great deal of information is packed into these two definitions, so we will take the time to translate the code word for word into English. Each <code>BinaryTree</code> value is either <code>Empty</code> or <code>NonEmpty</code>. If it’s <code>Empty</code>, then it contains no data at all. If <code>NonEmpty</code>, then it has a <code>Box</code>, a pointer to a heap-allocated <code>TreeNode</code>.</p>

<p>Each <code>TreeNode</code> value contains one actual element, as well as two more <code>BinaryTree</code> values. This means a tree can contain subtrees, and thus a <code>NonEmpty</code> tree can have any number of descendants.</p>
<p>A sketch of a value of type <code>BinaryTree&lt;&amp;str&gt;</code> is shown in <a data-type="xref" href="#binary-tree-figure">Figure 10-3</a>. As with <code>Option&lt;Box&lt;T&gt;&gt;</code>, Rust eliminates the tag field, so a <code>BinaryTree</code> value is just one machine word.</p>

<figure><div id="binary-tree-figure" class="figure">
<img src="Images/rust_1003.png" alt="Diagram showing how BinaryTree is arranged in memory." width="1301" height="1069"/>
<h6><span class="label">Figure 10-3. </span>
A BinaryTree containing six strings
</h6>
</div></figure>

<p>Building any particular node in this tree is straightforward:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="bp">self</code>::<code class="n">BinaryTree</code>::<code class="o">*</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">jupiter_tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">TreeNode</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">element</code>: <code class="s">"Jupiter"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">left</code>: <code class="nc">Empty</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">right</code>: <code class="nc">Empty</code><code class="w"/>
<code class="p">}));</code><code class="w"/></pre>
<p>Larger trees can be built from smaller ones:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">mars_tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">TreeNode</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">element</code>: <code class="s">"Mars"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">left</code>: <code class="nc">jupiter_tree</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">right</code>: <code class="nc">mercury_tree</code><code class="w"/>
<code class="p">}));</code><code class="w"/></pre>
<p>Naturally, this assignment transfers ownership of <code>jupiter_node</code> and <code>mercury_node</code> to their new parent node.</p>
<p>The remaining parts of the tree follow the same patterns. The root node is no different from the others:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">TreeNode</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">element</code>: <code class="s">"Saturn"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">left</code>: <code class="nc">mars_tree</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">right</code>: <code class="nc">uranus_tree</code><code class="w"/>
<code class="p">}));</code><code class="w"/></pre>
<p>Later in this chapter, we’ll show how to implement an <code>add</code> method on the <code>BinaryTree</code> type, so that we can instead write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BinaryTree</code>::<code class="n">Empty</code><code class="p">;</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">planet</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">planets</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">tree</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">planet</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>No matter what language you’re coming from, creating data structures like <code>BinaryTree</code> in Rust will likely take some practice. It won’t be obvious at first where to put the <code>Box</code>es. One way to find a design that will work is to draw a picture like <a data-type="xref" href="#binary-tree-figure">Figure 10-3</a> that shows how you want things laid out in memory. Then work backward from the picture to the code. Each collection of rectangles is a struct or tuple; each arrow is a <code>Box</code> or other smart pointer. Figuring out the type of each field is a bit of a puzzle, but a manageable one. The reward for solving the puzzle is control over your program’s memory usage.</p>

<p>Now comes the “price” we mentioned in the introduction. The tag field of an enum costs a little memory, up to 8 bytes in the worst case, but that is usually negligible. The real downside to enums (if it can be called that) is that Rust code cannot throw caution to the wind and try to access fields regardless of whether they are actually present in the value:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">shape</code><code class="p">.</code><code class="n">radius</code><code class="p">;</code><code class="w">  </code><code class="c1">// error: no field `radius` on type `Shape`</code></pre>
<p>The only way to access the data in an enum is the safe way: using patterns<a contenteditable="false" data-primary="" data-startref="C10-enums.html4" data-type="indexterm" id="idm45251623685464"/><a contenteditable="false" data-primary="" data-startref="C10-enums.html3" data-type="indexterm" id="idm45251623684328"/>.<a contenteditable="false" data-primary="" data-startref="C10-enums.html0" data-type="indexterm" id="idm45251623682824"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Patterns"><div class="sect1" id="patterns">
<h1>Patterns</h1>

<p><a contenteditable="false" data-primary="patterns" data-type="indexterm" id="C10-enums.html5"/>Recall <a contenteditable="false" data-primary="patterns" data-secondary="about" data-type="indexterm" id="C10-enums.html6"/>the definition of our <code>RoughTime</code> type from earlier in this chapter:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">RoughTime</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">InThePast</code><code class="p">(</code><code class="n">TimeUnit</code><code class="p">,</code><code class="w"> </code><code class="kt">u32</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">JustNow</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">InTheFuture</code><code class="p">(</code><code class="n">TimeUnit</code><code class="p">,</code><code class="w"> </code><code class="kt">u32</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Suppose you have a <code>RoughTime</code> value and you’d like to display it on a web page. You need to access the <code>TimeUnit</code> and <code>u32</code> fields inside the value. Rust doesn’t let you access them directly, by writing <code>rough_time.0</code> and <code>rough_time.1</code>, because after all, the value might be <code>RoughTime::JustNow</code>, which has no fields. But then, how can you get the data out?</p>
<p>You need a <code>match</code> expression:</p>
<pre data-type="programlisting" data-code-language="rust" data-testing-pragma="linenumbers"><code class="w"> </code><code class="mi">1</code><code class="w">  </code><code class="k">fn</code> <code class="nf">rough_time_to_english</code><code class="p">(</code><code class="n">rt</code>: <code class="nc">RoughTime</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="mi">2</code><code class="w">      </code><code class="k">match</code><code class="w"> </code><code class="n">rt</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="mi">3</code><code class="w">          </code><code class="n">RoughTime</code>::<code class="n">InThePast</code><code class="p">(</code><code class="n">units</code><code class="p">,</code><code class="w"> </code><code class="n">count</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w"> </code><code class="mi">4</code><code class="w">              </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{} {} ago"</code><code class="p">,</code><code class="w"> </code><code class="n">count</code><code class="p">,</code><code class="w"> </code><code class="n">units</code><code class="p">.</code><code class="n">plural</code><code class="p">()),</code><code class="w"/>
<code class="w"> </code><code class="mi">5</code><code class="w">          </code><code class="n">RoughTime</code>::<code class="n">JustNow</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w"> </code><code class="mi">6</code><code class="w">              </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"just now"</code><code class="p">),</code><code class="w"/>
<code class="w"> </code><code class="mi">7</code><code class="w">          </code><code class="n">RoughTime</code>::<code class="n">InTheFuture</code><code class="p">(</code><code class="n">units</code><code class="p">,</code><code class="w"> </code><code class="n">count</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w"> </code><code class="mi">8</code><code class="w">              </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{} {} from now"</code><code class="p">,</code><code class="w"> </code><code class="n">count</code><code class="p">,</code><code class="w"> </code><code class="n">units</code><code class="p">.</code><code class="n">plural</code><code class="p">())</code><code class="w"/>
<code class="w"> </code><code class="mi">9</code><code class="w">      </code><code class="p">}</code><code class="w"/>
<code class="mi">10</code><code class="w">  </code><code class="p">}</code><code class="w"/></pre>
<p><code>match</code> performs pattern matching; in this example, the <em>patterns</em> are the parts that appear before the <code>=&gt;</code> symbol on lines 3, 5, and 7. Patterns that match <code>RoughTime</code> values look just like the expressions used to create <code>RoughTime</code> values. This is no coincidence. Expressions <em>produce</em> values; patterns <em>consume</em> values. The two use a lot of the same syntax.</p>
<p>Let’s step through what happens when this <code>match</code> expression runs. Suppose <code>rt</code> is the value <code>RoughTime::InTheFuture(TimeUnit::Months, 1)</code>. Rust first tries to match this value against the pattern on line 3. As you can see in <a data-type="xref" href="#fig1004">Figure 10-4</a>, it doesn’t match.</p>

<figure><div id="fig1004" class="figure">
<img src="Images/rust_10in01.png" alt="An InTheFuture value doesn't match an InThePast pattern." width="925" height="208"/>
<h6><span class="label">Figure 10-4. </span>
A RoughTime value and pattern that do not match
</h6>
</div></figure>

<p>Pattern matching on an enum, struct, or tuple works as though Rust is doing a simple left-to-right scan, checking each component of the pattern to see if the value matches it. If it doesn’t, Rust moves on to the next pattern.</p>

<p>The patterns on lines 3 and 5 fail to match. But the pattern on line 7 succeeds (<a data-type="xref" href="#fig1005">Figure 10-5</a>).</p>

<figure><div id="fig1005" class="figure">
<img src="Images/rust_10in02.png" alt="An InTheFuture value matches an InTheFuture pattern. The value 'TimeUnit::Months' matches the identifier 'units', and the value 1 matches the identifier 'count'." width="977" height="208"/>
<h6><span class="label">Figure 10-5. </span>
A successful match
</h6>
</div></figure>

<p>When a pattern contains simple identifiers like <code>units</code> and <code>count</code>, those become local variables in the code following the pattern. Whatever is present in the value is copied or moved into the new variables. Rust stores <code>TimeUnit::Months</code> in <code>units</code> and <code>1</code> in <code>count</code>, runs line 8, and returns the string <code>"1 months from now"</code>.</p>
<p>That output has a minor grammatical issue, which can be fixed by adding another arm to the <code>match</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">RoughTime</code>::<code class="n">InTheFuture</code><code class="p">(</code><code class="n">unit</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">    </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"a {} from now"</code><code class="p">,</code><code class="w"> </code><code class="n">unit</code><code class="p">.</code><code class="n">singular</code><code class="p">()),</code><code class="w"/></pre>
<p>This arm matches only if the <code>count</code> field is exactly 1. Note that this new code must be added before line 7. If we add it at the end, Rust will never get to it, because the pattern on line 7 matches all <code>InTheFuture</code> values. The Rust compiler will warn about an “unreachable pattern” if you make this kind of mistake.</p>
<p>Unfortunately, even with the new code, there is still a problem with <code>RoughTime::InTheFuture(TimeUnit::Hours, 1)</code>: the result <code>"a hour from now"</code> is not quite right. Such is the English language. This too can be fixed by adding another arm to the <code>match</code>.</p>
<p>As this example shows, pattern matching works hand in hand with enums and can even test the data they contain, making <code>match</code> a powerful, flexible replacement for C’s <code>switch</code> statement.</p>
<p>So far, we’ve only seen patterns that match enum values. There’s more to it than that. Rust patterns are their own little language, summarized in <a data-type="xref" href="#patterns-table">Table 10-1</a>. We’ll spend most of the rest of the chapter on the features shown in this table.<a contenteditable="false" data-primary="" data-startref="C10-enums.html6" data-type="indexterm" id="idm45251623409624"/></p>

<table id="patterns-table" class="tallrow">
<caption><span class="label">Table 10-1. </span>
Patterns
</caption>
<thead>
<tr>
<th>
Pattern type
</th>
<th>
Example
</th>
<th>
Notes
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Literal
</td>
<td>
<code>100
"name"</code>
</td>
<td>
Matches an exact value; the name of a <code>const</code> is also allowed
</td>
</tr>
<tr>
<td>
Range
</td>
<td>
<code>0 ... 100
'a' ... 'k'</code>
</td>
<td>
Matches any value in range, including the end value
</td>
</tr>
<tr>
<td>
Wildcard
</td>
<td>
<code>_</code>
</td>
<td>
Matches any value and ignores it
</td>
</tr>
<tr>
<td>
Variable
</td>
<td>
<code>name
mut count</code>
</td>
<td>
Like <code>_</code> but moves or copies the value into a new local variable
</td>
</tr>
<tr>
<td>
<code>ref</code> variable
</td>
<td>
<code>ref field
ref mut field</code>
</td>
<td>
Borrows a reference to the matched value instead of moving or copying it
</td>
</tr>
<tr>
<td>
Binding with subpattern
</td>
<td>
<code>val @ 0 ... 99
ref circle @ Shape::Circle { .. }</code>
</td>
<td>
Matches the pattern to the right of <code>@</code>, using the variable name to the left
</td>
</tr>
<tr>
<td>
Enum pattern
</td>
<td>
<code>Some(value)
None
Pet::Orca</code>
</td>
<td>
</td>
</tr>
<tr class="border_bottom">
<td>
Tuple pattern
</td>
<td>
<code>(key, value)
(r, g, b)</code>
</td>
<td>
</td>
</tr>
<tr>
<td>
Struct pattern
</td>
<td>
<code>Color(r, g, b)
Point { x, y }
Card { suit: Clubs, rank: n }
Account { id, name, .. }</code>
</td>
<td>
</td>
</tr>
<tr class="border_bottom">
<td>
Reference
</td>
<td>
<code>&amp;value
&amp;(k, v)</code>
</td>
<td>
Matches only reference values
</td>
</tr>
<tr class="border_bottom">
<td>
Multiple patterns
</td>
<td>
<code>'a' | 'A'</code>
</td>
<td>
In <code>match</code> only (not valid in <code>let</code>, etc.)
</td>
</tr>
<tr>
<td>
Guard expression
</td>
<td>
<code>x if x * x &lt;= r2</code>
</td>
<td>
In <code>match</code> only (not valid in <code>let</code>, etc.)
</td>
</tr>
</tbody>
</table>
<section data-type="sect2" data-pdf-bookmark="Literals, Variables, and Wildcards in Patterns"><div class="sect2" id="literals-variables-and-wildcards-in-patterns">
<h2>Literals, Variables, and Wildcards in Patterns</h2>
<p><a contenteditable="false" data-primary="literals, in patterns" data-type="indexterm" id="idm45251623327368"/><a contenteditable="false" data-primary="patterns" data-secondary="literals in" data-type="indexterm" id="idm45251623326040"/>So far, we’ve shown <code>match</code> expressions working with enums. Other types can be matched too. When you need something like a C <code>switch</code> statement, use <code>match</code> with an integer value. <a contenteditable="false" data-primary="integer literals" data-type="indexterm" id="idm45251623323112"/>Integer literals like <code>0</code> and <code>1</code> can serve as patterns:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">meadow</code><code class="p">.</code><code class="n">count_rabbits</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="mi">0</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{}</code><code class="w">  </code><code class="c1">// nothing to say</code>
<code class="w">    </code><code class="mi">1</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"A rabbit is nosing around in the clover."</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">n</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"There are {} rabbits hopping about in the meadow"</code><code class="p">,</code><code class="w"> </code><code class="n">n</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The pattern <code>0</code> matches if there are no rabbits in the meadow. <code>1</code> matches if there is just one. If there are two or more rabbits, we reach the third pattern, <code>n</code>. This pattern is just a variable name. It can match any value, and the matched value is moved or copied into a new local variable. So in this case, the value of <code>meadow.count_rabbits()</code> is stored in a new local variable <code>n</code>, which we then print.</p>
<p>Other literals can be used as patterns too, including Booleans, characters, and even strings:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">calendar</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">settings</code><code class="p">.</code><code class="n">get_string</code><code class="p">(</code><code class="s">"calendar"</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="s">"gregorian"</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">Calendar</code>::<code class="n">Gregorian</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="s">"chinese"</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">Calendar</code>::<code class="n">Chinese</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="s">"ethiopian"</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">Calendar</code>::<code class="n">Ethiopian</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">other</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">parse_error</code><code class="p">(</code><code class="s">"calendar"</code><code class="p">,</code><code class="w"> </code><code class="n">other</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/></pre>
<p>In this example, <code>other</code> serves as a catch-all pattern, like <code>n</code> in the previous example. These patterns play the same role as a <code>default</code> case in a <code>switch</code> statement, matching values that don’t match any of the other patterns.</p>
<p><a contenteditable="false" data-primary="patterns" data-secondary="wildcards in" data-type="indexterm" id="idm45251623174344"/><a contenteditable="false" data-primary="wildcards" data-type="indexterm" id="idm45251623172968"/>If you need a catch-all pattern, but you don’t care about the matched value, you can use a single underscore <code>_</code> as a pattern, the <em>wildcard pattern</em>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">caption</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">photo</code><code class="p">.</code><code class="n">tagged_pet</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Pet</code>::<code class="n">Tyrannosaur</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"RRRAAAAAHHHHHH"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">Pet</code>::<code class="n">Samoyed</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"*dog thoughts*"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"I'm cute, love me"</code><code class="w">  </code><code class="c1">// generic caption, works for any pet</code>
<code class="w">    </code><code class="p">};</code><code class="w"/></pre>
<p>The wildcard pattern matches any value, but without storing it anywhere. Since Rust requires every <code>match</code> expression to handle all possible values, a wildcard is often required at the end. Even if you’re very sure the remaining cases can’t occur, you must at least add a fallback arm that panics:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// There are many Shapes, but we only support "selecting"</code>
<code class="c1">// either some text, or everything in a rectangular area.</code>
<code class="c1">// You can't select an ellipse or trapezoid.</code>
<code class="k">match</code><code class="w"> </code><code class="n">document</code><code class="p">.</code><code class="n">selection</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Shape</code>::<code class="n">TextSpan</code><code class="p">(</code><code class="n">start</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">paint_text_selection</code><code class="p">(</code><code class="n">start</code><code class="p">,</code><code class="w"> </code><code class="n">end</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">Shape</code>::<code class="n">Rectangle</code><code class="p">(</code><code class="n">rect</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">paint_rect_selection</code><code class="p">(</code><code class="n">rect</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">panic</code><code class="o">!</code><code class="p">(</code><code class="s">"unexpected selection type"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="patterns" data-secondary="variables in" data-type="indexterm" id="idm45251623079592"/><a contenteditable="false" data-primary="variables" data-secondary="in patterns" data-type="indexterm" id="idm45251623018760"/>It’s worth noting that existing variables can’t be used in patterns. Suppose we’re implementing a board game with hexagonal spaces, and the player just clicked to move a piece. To confirm that the click was valid, we might try something like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">check_move</code><code class="p">(</code><code class="n">current_hex</code>: <code class="nc">Hex</code><code class="p">,</code><code class="w"> </code><code class="n">click</code>: <code class="nc">Point</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">game</code>::<code class="nb">Result</code><code class="o">&lt;</code><code class="n">Hex</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">point_to_hex</code><code class="p">(</code><code class="n">click</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">            </code><code class="nb">Err</code><code class="p">(</code><code class="s">"That's not a game space."</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">current_hex</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w">  </code><code class="c1">// try to match if user clicked the current_hex</code>
<code class="w">                              </code><code class="c1">// (it doesn't work: see explanation below)</code>
<code class="w">            </code><code class="nb">Err</code><code class="p">(</code><code class="s">"You are already there! You must click somewhere else."</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">other_hex</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">            </code><code class="nb">Ok</code><code class="p">(</code><code class="n">other_hex</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This fails because identifiers in patterns introduce <em>new</em> variables. The pattern <code>Some(current_hex)</code> here creates a new local variable <code>current_hex</code>, shadowing the argument <code>current_hex</code>. Rust emits several warnings about this code—in particular, the last arm of the <code>match</code> is unreachable. To fix it, use an <code>if</code> expression:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="nb">Some</code><code class="p">(</code><code class="n">hex</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">hex</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">current_hex</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Err</code><code class="p">(</code><code class="s">"You are already there! You must click somewhere else"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">hex</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>
<p>In a few pages, we’ll cover <a href="#pattern-guards">guards</a>, which offer another way to solve this problem.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Tuple and Struct Patterns"><div class="sect2" id="tuple-and-struct-patterns">
<h2>Tuple and Struct Patterns</h2>

<p><a contenteditable="false" data-primary="patterns" data-secondary="tuple patterns" data-type="indexterm" id="idm45251622778904"/><a contenteditable="false" data-primary="tuple patterns" data-type="indexterm" id="idm45251622777528"/>Tuple patterns match tuples. They’re useful any time you want to get multiple pieces of data involved in a single <code>match</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">describe_point</code><code class="p">(</code><code class="n">x</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="n">Ordering</code>::<code class="o">*</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="n">cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">0</code><code class="p">),</code><code class="w"> </code><code class="n">y</code><code class="p">.</code><code class="n">cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">0</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="n">Equal</code><code class="p">,</code><code class="w"> </code><code class="n">Equal</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"at the origin"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="n">_</code><code class="p">,</code><code class="w"> </code><code class="n">Equal</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"on the x axis"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="n">Equal</code><code class="p">,</code><code class="w"> </code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"on the y axis"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="n">Greater</code><code class="p">,</code><code class="w"> </code><code class="n">Greater</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"in the first quadrant"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="n">Less</code><code class="p">,</code><code class="w"> </code><code class="n">Greater</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"in the second quadrant"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"somewhere else"</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="patterns" data-secondary="struct patterns" data-type="indexterm" id="idm45251622869864"/><a contenteditable="false" data-primary="struct patterns" data-type="indexterm" id="idm45251622647832"/>Struct patterns use curly braces, just like struct expressions. They contain a subpattern for each field:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">balloon</code><code class="p">.</code><code class="n">location</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="nc">height</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"straight up {} meters"</code><code class="p">,</code><code class="w"> </code><code class="n">height</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="nc">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="nc">y</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"at ({}m, {}m)"</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In this example, if the first arm matches, then <code>balloon.location.y</code> is stored in the new local variable <code>height</code>.</p>
<p>Suppose <code>balloon.location</code> is <code>Point { x: 30, y: 40 }</code>. As always, Rust checks each component of each pattern in turn <a data-type="xref" href="#fig1006">Figure 10-6</a>.</p>

<figure><div id="fig1006" class="figure">
<img src="Images/rust_10in03.png" alt="A Point fails to match the first pattern, but matches the second." width="1399" height="208"/>
<h6><span class="label">Figure 10-6. </span>
Pattern matching with structs
</h6>
</div></figure>

<p>The second arm matches, so the output would be “<code>at (30m, 40m)</code>”.</p>
<p>Patterns like <code>Point { x: x, y: y }</code> are common when matching structs, and the redundant names are visual clutter, so Rust has a shorthand for this: <code>Point {x, y}</code>. The meaning is the same. This pattern still stores a point’s <code>x</code> field in a new local <code>x</code> and its <code>y</code> field in a new local <code>y</code>.</p>
<p>Even with the shorthand, it is cumbersome to match a large struct when we only care about a few fields:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">get_account</code><code class="p">(</code><code class="n">id</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">Account</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">language</code><code class="p">,</code><code class="w">  </code><code class="c1">// &lt;--- the 2 things we care about</code>
<code class="w">            </code><code class="n">id</code>: <code class="nc">_</code><code class="p">,</code><code class="w"> </code><code class="n">status</code>: <code class="nc">_</code><code class="p">,</code><code class="w"> </code><code class="n">address</code>: <code class="nc">_</code><code class="p">,</code><code class="w"> </code><code class="n">birthday</code>: <code class="nc">_</code><code class="p">,</code><code class="w"> </code><code class="n">eye_color</code>: <code class="nc">_</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">pet</code>: <code class="nc">_</code><code class="p">,</code><code class="w"> </code><code class="n">security_question</code>: <code class="nc">_</code><code class="p">,</code><code class="w"> </code><code class="n">hashed_innermost_secret</code>: <code class="nc">_</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">is_adamantium_preferred_customer</code>: <code class="nc">_</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">language</code><code class="p">.</code><code class="n">show_custom_greeting</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>To avoid this, use <code>..</code> to tell Rust you don’t care about any of the other fields:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="nb">Some</code><code class="p">(</code><code class="n">Account</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">language</code><code class="p">,</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">    </code><code class="n">language</code><code class="p">.</code><code class="n">show_custom_greeting</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Reference Patterns"><div class="sect2" id="reference-patterns">
<h2>Reference Patterns</h2>

<p><a contenteditable="false" data-primary="patterns" data-secondary="reference patterns" data-type="indexterm" id="C10-enums.html7"/><a contenteditable="false" data-primary="reference (ref) patterns" data-type="indexterm" id="C10-enums.html8"/>Rust patterns support two features for working with references. <code>ref</code> patterns borrow parts of a matched value. <code>&amp;</code> patterns match references. We’ll cover <code>ref</code> patterns first.</p>
<p>Matching on a noncopyable value moves the value. Continuing with the account example, this code would be invalid:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Account</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">language</code><code class="p">,</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">ui</code><code class="p">.</code><code class="n">greet</code><code class="p">(</code><code class="o">&amp;</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">language</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">ui</code><code class="p">.</code><code class="n">show_settings</code><code class="p">(</code><code class="o">&amp;</code><code class="n">account</code><code class="p">);</code><code class="w">  </code><code class="c1">// error: use of moved value `account`</code>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Here, the fields <code>account.name</code> and <code>account.language</code> are moved into local variables <code>name</code> and <code>language</code>. The rest of <code>account</code> is dropped. That’s why we can’t call methods on <code>account</code> afterward.</p>
<p>If <code>name</code> and <code>language</code> were both copyable values, Rust would copy the fields instead of moving them, and this code would be fine. But suppose these are <code>String</code>s. What can we do?</p>
<p>We need a kind of pattern that <em>borrows</em> matched values instead of moving them. The <code>ref</code> keyword does just that:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Account</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">ref</code><code class="w"> </code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="k">ref</code><code class="w"> </code><code class="n">language</code><code class="p">,</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">ui</code><code class="p">.</code><code class="n">greet</code><code class="p">(</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">language</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">ui</code><code class="p">.</code><code class="n">show_settings</code><code class="p">(</code><code class="o">&amp;</code><code class="n">account</code><code class="p">);</code><code class="w">  </code><code class="c1">// ok</code>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Now the local variables <code>name</code> and <code>language</code> are references to the corresponding fields in <code>account</code>. Since <code>account</code> is only being borrowed, not consumed, it’s OK to continue calling methods on it.</p>
<p>You can use <code>ref mut</code> to borrow <code>mut</code> references:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">line_result</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Err</code><code class="p">(</code><code class="k">ref</code><code class="w"> </code><code class="n">err</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">log_error</code><code class="p">(</code><code class="n">err</code><code class="p">),</code><code class="w">  </code><code class="c1">// `err` is &amp;Error (shared ref)</code>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="k">ref</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">line</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">            </code><code class="c1">// `line` is &amp;mut String (mut ref)</code>
<code class="w">        </code><code class="n">trim_comments</code><code class="p">(</code><code class="n">line</code><code class="p">);</code><code class="w">         </code><code class="c1">// modify the String in place</code>
<code class="w">        </code><code class="n">handle</code><code class="p">(</code><code class="n">line</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The pattern <code>Ok(ref mut line)</code> matches any success result and borrows a <code>mut</code> reference to the success value stored inside it.</p>
<p><a contenteditable="false" data-primary="&amp; pattern" data-type="indexterm" id="idm45251622125592"/>The opposite kind of reference pattern is the <code>&amp;</code> pattern. A pattern starting with <code>&amp;</code> matches a reference.</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">sphere</code><code class="p">.</code><code class="n">center</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">&amp;</code><code class="n">Point3d</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In this example, suppose <code>sphere.center()</code> returns a reference to a private field of <code>sphere</code>, a common pattern in Rust. The value returned is the address of a <code>Point3d</code>. If the center is at the origin, then <code>sphere.center()</code> returns <code>&amp;Point3d { x: 0.0, y: 0.0, z: 0.0 }</code>.</p>
<p>So pattern matching proceeds as shown in <a data-type="xref" href="#fig1007">Figure 10-7</a>.</p>

<figure><div id="fig1007" class="figure">
<img src="Images/rust_10in04.png" alt="A reference to a Point3d matches an &amp; pattern." width="794" height="208"/>
<h6><span class="label">Figure 10-7. </span>
Pattern matching with references
</h6>
</div></figure>

<p>This is a bit tricky because Rust is following a pointer here, an action we usually associate with the <code>*</code> operator, not the <code>&amp;</code> operator. The thing to remember is that patterns and expressions are natural opposites. The expression <code>(x, y)</code> makes two values into a new tuple, but the pattern <code>(x, y)</code> does the opposite: it matches a tuple and breaks out the two values. It’s the same with <code>&amp;</code>. In an expression, <code>&amp;</code> creates a reference. In a pattern, <code>&amp;</code> matches a reference.</p>
<p>Matching a reference follows all the rules we’ve come to expect. Lifetimes are enforced. You can’t get <code>mut</code> access via a shared reference. And you can’t move a value out of a reference, even a <code>mut</code> reference. When we match <code>&amp;Point3d { x, y, z }</code>, the variables <code>x</code>, <code>y</code>, and <code>z</code> receive copies of the coordinates, leaving the original <code>Point3d</code> value intact. It works because those fields are copyable. If we try the same thing on a struct with noncopyable fields, we’ll get an error:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">friend</code><code class="p">.</code><code class="n">borrow_car</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Car</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">engine</code><code class="p">,</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="o">=&gt;</code><code class="w">  </code><code class="c1">// error: can't move out of borrow</code>
<code class="w">        </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Scrapping a borrowed car for parts is not nice, and Rust won’t stand for it. You can use a <code>ref</code> pattern to borrow a reference to a part. You just don’t own it.</p>
<pre data-type="programlisting" data-code-language="rust"><code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Car</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">ref</code><code class="w"> </code><code class="n">engine</code><code class="p">,</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="o">=&gt;</code><code class="w">  </code><code class="c1">// ok, engine is a reference</code></pre>
<p>Let’s look at one more example of an <code>&amp;</code> pattern. Suppose we have an iterator <code>chars</code> over the characters in a string, and it has a method <code>chars.peek()</code> that returns an <code>Option&lt;&amp;char&gt;</code>: a reference to the next character, if any. (Peekable iterators do in fact return an <code>Option&lt;&amp;ItemType&gt;</code>, as we’ll see in <a data-type="xref" href="ch15.xhtml#iterators">Chapter 15</a>.)</p>
<p>A program can use an <code>&amp;</code> pattern to get the pointed-to character:<a contenteditable="false" data-primary="" data-startref="C10-enums.html8" data-type="indexterm" id="idm45251621915144"/><a contenteditable="false" data-primary="" data-startref="C10-enums.html7" data-type="indexterm" id="idm45251621913768"/></p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">chars</code><code class="p">.</code><code class="n">peek</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="n">c</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"coming up: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">c</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"end of chars"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Matching Multiple Possibilities"><div class="sect2" id="matching-multiple-possibilities">
<h2>Matching Multiple Possibilities</h2>

<p><a contenteditable="false" data-primary="| (vertical bar)" data-type="indexterm" id="idm45251621858168"/><a contenteditable="false" data-primary="patterns" data-secondary="matching multiple possibilities with |" data-type="indexterm" id="idm45251621857064"/><a contenteditable="false" data-primary="vertical bar (|)" data-type="indexterm" id="idm45251621855720"/>The vertical bar (<code>|</code>) can be used to combine several patterns in a single <code>match</code> arm:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">at_end</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">chars</code><code class="p">.</code><code class="n">peek</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="sc">'\r'</code><code class="p">)</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="sc">'\n'</code><code class="p">)</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/></pre>
<p>In an expression, <code>|</code> is the bitwise OR operator, but here it works more like the <code>|</code> symbol in a regular expression. <code>at_end</code> is set to <code>true</code> if <code>chars.peek()</code> matches any of the three patterns.</p>
<p><a contenteditable="false" data-primary="ranges" data-secondary="in patterns" data-type="indexterm" id="idm45251621791944"/>Use <code>...</code> to match a whole range of values. Range patterns include the begin and end values, so <code>'0' ... '9'</code> matches all the ASCII digits:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">next_char</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sc">'0'</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="sc">'9'</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">read_number</code><code class="p">(),</code><code class="w"/>
<code class="w">    </code><code class="sc">'a'</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="sc">'z'</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="sc">'A'</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="sc">'Z'</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">read_word</code><code class="p">(),</code><code class="w"/>
<code class="w">    </code><code class="sc">' '</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="sc">'\t'</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">skip_whitespace</code><code class="p">(),</code><code class="w"/>
<code class="w">    </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">handle_punctuation</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Ranges in patterns are <em>inclusive</em>, so that both <code>'0'</code> and <code>'9'</code> match the pattern <code>'0' ... '9'</code>. <a contenteditable="false" data-primary="exclusive (half-open) ranges" data-type="indexterm" id="idm45251621678232"/><a contenteditable="false" data-primary="half-open ranges" data-type="indexterm" id="idm45251621677240"/><a contenteditable="false" data-primary="ranges" data-secondary="half-open" data-type="indexterm" id="idm45251621676136"/>By contrast, range expressions (written with two dots, as in <code>for n in 0..100</code>) are half-open, or <em>exclusive</em> (covering <code>0</code> but not <code>100</code>). The reason for the inconsistency is simply that exclusive ranges are more useful for loops and slicing, but inclusive ranges are more useful in pattern matching.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Pattern Guards"><div class="sect2" id="pattern-guards">
<h2>Pattern Guards</h2>

<p><a contenteditable="false" data-primary="guards" data-type="indexterm" id="idm45251621671304"/><a contenteditable="false" data-primary="patterns" data-secondary="guards" data-type="indexterm" id="idm45251621669976"/>Use the <code>if</code> keyword to add a <em>guard</em> to a <code>match</code> arm. The match succeeds only if the guard evaluates to <code>true</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">robot</code><code class="p">.</code><code class="n">last_known_location</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">point</code><code class="p">)</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">distance_to</code><code class="p">(</code><code class="n">point</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">short_distance_strategy</code><code class="p">(</code><code class="n">point</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">point</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">long_distance_strategy</code><code class="p">(</code><code class="n">point</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">searching_strategy</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If a pattern moves any values, you can’t put a guard on it. The guard might evaluate to <code>false</code>, and then Rust would go on to the next pattern. But it can’t do that if you’ve moved bits out of the value to be matched. Therefore, the preceding code works only if <code>point</code> is <a href="ch04.xhtml#copy-types-the-exception-to-moves">copyable</a>. If it’s not, we’ll get an error:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0008]: cannot bind by-move into a pattern guard</code>
<code class="go">  --&gt; enums_move_into_guard.rs:19:18</code>
<code class="go">   |</code>
<code class="go">19 |             Some(point) if self.distance_to(point) &lt; 10 =&gt;</code>
<code class="go">   |                  ^^^^^ moves value into pattern guard</code></pre>
<p>The workaround, then, would be to change the pattern to borrow <code>point</code> instead of moving it: <code>Some(ref point)</code>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="@ patterns"><div class="sect2" id="patterns-1">
<h2>@ patterns</h2>

<p><a contenteditable="false" data-primary="@ patterns" data-type="indexterm" id="idm45251621623080"/><a contenteditable="false" data-primary="patterns" data-secondary="@ patterns" data-type="indexterm" id="idm45251621621976"/><a contenteditable="false" data-primary="x @ pattern" data-type="indexterm" id="idm45251621528104"/>Finally, <code><var>x</var> @ <var>pattern</var></code> matches exactly like the given <code><var>pattern</var></code>, but on success, instead of creating variables for parts of the matched value, it creates a single variable <code><var>x</var></code> and moves or copies the whole value into it. For example, say you have this code:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">get_selection</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Shape</code>::<code class="n">Rect</code><code class="p">(</code><code class="n">top_left</code><code class="p">,</code><code class="w"> </code><code class="n">bottom_right</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">optimized_paint</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Shape</code>::<code class="n">Rect</code><code class="p">(</code><code class="n">top_left</code><code class="p">,</code><code class="w"> </code><code class="n">bottom_right</code><code class="p">)),</code><code class="w"/>
<code class="w">    </code><code class="n">other_shape</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">paint_outline</code><code class="p">(</code><code class="n">other_shape</code><code class="p">.</code><code class="n">get_outline</code><code class="p">()),</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Note that the first case unpacks a <code>Shape::Rect</code> value, only to rebuild an identical <code>Shape::Rect</code> value on the next line. This can be rewritten to use an <code>@</code> pattern:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="w">    </code><code class="n">rect</code><code class="w"> </code><code class="o">@</code><code class="w"> </code><code class="n">Shape</code>::<code class="n">Rect</code><code class="p">(..)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w">        </code><code class="n">optimized_paint</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rect</code><code class="p">),</code><code class="w"/></pre>
<p><code>@</code> patterns are also useful with ranges:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">match</code><code class="w"> </code><code class="n">chars</code><code class="p">.</code><code class="n">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">digit</code><code class="w"> </code><code class="o">@</code><code class="w"> </code><code class="sc">'0'</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="sc">'9'</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">read_number</code><code class="p">(</code><code class="n">digit</code><code class="p">,</code><code class="w"> </code><code class="n">chars</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Where Patterns Are Allowed"><div class="sect2" id="where-patterns-are-allowed">
<h2>Where Patterns Are Allowed</h2>

<p><a contenteditable="false" data-primary="patterns" data-secondary="situations that allow" data-type="indexterm" id="idm45251621350424"/>Although patterns are most prominent in <code>match</code> expressions, they are also allowed in several other places, typically in place of an identifier. The meaning is always the same: instead of just storing a value in a single variable, Rust uses pattern matching to take the value apart.</p>
<p>This means patterns can be used to...</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// ...unpack a struct into three new local variables</code>
<code class="kd">let</code><code class="w"> </code><code class="n">Track</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">album</code><code class="p">,</code><code class="w"> </code><code class="n">track_number</code><code class="p">,</code><code class="w"> </code><code class="n">title</code><code class="p">,</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">song</code><code class="p">;</code><code class="w"/>

<code class="c1">// ...unpack a function argument that's a tuple</code>
<code class="k">fn</code> <code class="nf">distance_to</code><code class="p">((</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">)</code>: <code class="p">(</code><code class="kt">f64</code><code class="p">,</code><code class="w"> </code><code class="kt">f64</code><code class="p">))</code><code class="w"> </code>-&gt; <code class="kt">f64</code> <code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="c1">// ...iterate over keys and values of a HashMap</code>
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">id</code><code class="p">,</code><code class="w"> </code><code class="n">document</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">cache_map</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Document #{}: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">id</code><code class="p">,</code><code class="w"> </code><code class="n">document</code><code class="p">.</code><code class="n">title</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// ...automatically dereference an argument to a closure</code>
<code class="c1">// (handy because sometimes other code passes you a reference</code>
<code class="c1">// when you'd rather have a copy)</code>
<code class="kd">let</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">numbers</code><code class="p">.</code><code class="n">fold</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">num</code><code class="o">|</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">num</code><code class="p">);</code><code class="w"/></pre>
<p>Each of these saves two or three lines of boilerplate code. The same concept exists in some other languages: in JavaScript, it’s called <em>destructuring</em>; in Python, <em>unpacking</em>.</p>

<p>Note that in all four examples, we use patterns that are guaranteed to match. The pattern <code>Point3d { x, y, z }</code> matches every possible value of the <code>Point3d</code> struct type; <code>(x, y)</code> matches any <code>(f64, f64)</code> pair; and so on. Patterns that always match are special in Rust. <a contenteditable="false" data-primary="irrefutable patterns" data-type="indexterm" id="idm45251621186536"/>They’re called <em>irrefutable patterns</em>, and they’re the only patterns allowed in the four places shown here (after <code>let</code>, in function arguments, after <code>for</code>, and in closure arguments).</p>

<p><a contenteditable="false" data-primary="refutable patterns" data-type="indexterm" id="idm45251621183864"/>A <em>refutable pattern</em> is one that might not match, like <code>Ok(x)</code>, which doesn’t match an error result, or <code>'0' ... '9'</code>, which doesn’t match the character <code>'Q'</code>. Refutable patterns can be used in <code>match</code> arms, because <code>match</code> is designed for them: if one pattern fails to match, it’s clear what happens next. The four examples above are places in Rust programs where a pattern can be handy, but the language doesn’t allow for match <span class="keep-together">failure.</span></p>
<p>Refutable patterns are also allowed in <code>if let</code> and <code>while let</code> expressions, which can be used to...</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// ...handle just one enum variant specially</code>
<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="n">RoughTime</code>::<code class="n">InTheFuture</code><code class="p">(</code><code class="n">_</code><code class="p">,</code><code class="w"> </code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">user</code><code class="p">.</code><code class="n">date_of_birth</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">user</code><code class="p">.</code><code class="n">set_time_traveler</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// ...run some code only if a table lookup succeeds</code>
<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">document</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cache_map</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="o">&amp;</code><code class="n">id</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">send_cached_response</code><code class="p">(</code><code class="n">document</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// ...repeatedly try something until it succeeds</code>
<code class="k">while</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">err</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">present_cheesy_anti_robot_task</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">log_robot_attempt</code><code class="p">(</code><code class="n">err</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="c1">// let the user try again (it might still be a human)</code>
<code class="p">}</code><code class="w"/>

<code class="c1">// ...manually loop over an iterator</code>
<code class="k">while</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">lines</code><code class="p">.</code><code class="n">peek</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">read_paragraph</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">lines</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>For details about these expressions, see <a data-type="xref" href="ch06.xhtml#if-let">“if let”</a> and <a data-type="xref" href="ch06.xhtml#loops">“Loops”</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Populating a Binary Tree"><div class="sect2" id="populating-a-binary-tree">
<h2>Populating a Binary Tree</h2>

<p><a contenteditable="false" data-primary="binary trees, populating with patterns" data-type="indexterm" id="idm45251621043912"/><a contenteditable="false" data-primary="patterns" data-secondary="populating a binary tree" data-type="indexterm" id="idm45251621042792"/>Earlier we promised to show how to implement a method, <code>BinaryTree::add()</code>, that adds a node to a <code>BinaryTree</code> of this type:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Empty</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code><code class="o">&lt;</code><code class="n">TreeNode</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">struct</code> <code class="nc">TreeNode</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">element</code>: <code class="nc">T</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">left</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">right</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You now know enough about patterns to write this method. An explanation of binary search trees is beyond the scope of this book, but for readers already familiar with the topic, it’s worth seeing how it plays out in Rust.</p>
<pre data-type="programlisting" data-code-language="rust" data-testing-pragma="linenumbers"><code class="w"> </code><code class="mi">1</code><code class="w">  </code><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nb">Ord</code><code class="o">&gt;</code><code class="w"> </code><code class="n">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="mi">2</code><code class="w">      </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">value</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="mi">3</code><code class="w">          </code><code class="k">match</code><code class="w"> </code><code class="o">*</code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="mi">4</code><code class="w">              </code><code class="n">BinaryTree</code>::<code class="n">Empty</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="w"> </code><code class="mi">5</code><code class="w">                  </code><code class="o">*</code><code class="bp">self</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BinaryTree</code>::<code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">TreeNode</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="mi">6</code><code class="w">                      </code><code class="n">element</code>: <code class="nc">value</code><code class="p">,</code><code class="w"/>
<code class="w"> </code><code class="mi">7</code><code class="w">                      </code><code class="n">left</code>: <code class="nc">BinaryTree</code>::<code class="n">Empty</code><code class="p">,</code><code class="w"/>
<code class="w"> </code><code class="mi">8</code><code class="w">                      </code><code class="n">right</code>: <code class="nc">BinaryTree</code>::<code class="n">Empty</code><code class="w"/>
<code class="w"> </code><code class="mi">9</code><code class="w">                  </code><code class="p">})),</code><code class="w"/>
<code class="mi">10</code><code class="w">              </code><code class="n">BinaryTree</code>::<code class="n">NonEmpty</code><code class="p">(</code><code class="k">ref</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">node</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/>
<code class="mi">11</code><code class="w">                  </code><code class="k">if</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">node</code><code class="p">.</code><code class="n">element</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="mi">12</code><code class="w">                      </code><code class="n">node</code><code class="p">.</code><code class="n">left</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">value</code><code class="p">);</code><code class="w"/>
<code class="mi">13</code><code class="w">                  </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="mi">14</code><code class="w">                      </code><code class="n">node</code><code class="p">.</code><code class="n">right</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">value</code><code class="p">);</code><code class="w"/>
<code class="mi">15</code><code class="w">                  </code><code class="p">}</code><code class="w"/>
<code class="mi">16</code><code class="w">          </code><code class="p">}</code><code class="w"/>
<code class="mi">17</code><code class="w">      </code><code class="p">}</code><code class="w"/>
<code class="mi">18</code><code class="w">  </code><code class="p">}</code><code class="w"/></pre>
<p>Line 1 tells Rust that we’re defining a method on <code>BinaryTree</code>s of ordered types. This is exactly the same syntax we use to define methods on generic structs, explained in <a data-type="xref" href="ch09.xhtml#defining-methods-with-impl">“Defining Methods with impl”</a>.</p>

<p>If the existing tree <code>*self</code> is empty, that’s the easy case. Lines 5–9 run, changing the <code>Empty</code> tree to a <code>NonEmpty</code> one. The call to <code>Box::new()</code> here allocates a new <code>TreeNode</code> in the heap. When we’re done, the tree contains one element. Its left and right subtrees are both <code>Empty</code>.</p>

<p>If <code>*self</code> is not empty, we match the pattern on line 10:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">BinaryTree</code>::<code class="n">NonEmpty</code><code class="p">(</code><code class="k">ref</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">node</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"/></pre>
<p>This pattern borrows a mutable reference to the <code>Box&lt;TreeNode&lt;T&gt;&gt;</code>, so we can access and modify data in that tree node. That reference is named <code>node</code>, and it’s in scope from line 11 to line 15. Since there’s already an element in this node, the code must recursively call <code>.add()</code> to add the new element to either the left or the right <span class="keep-together">subtree.</span></p>
<p>The new method can be used like this:<a contenteditable="false" data-primary="" data-startref="C10-enums.html5" data-type="indexterm" id="idm45251620691464"/></p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BinaryTree</code>::<code class="n">Empty</code><code class="p">;</code><code class="w"/>
<code class="n">tree</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="s">"Mercury"</code><code class="p">);</code><code class="w"/>
<code class="n">tree</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="s">"Venus"</code><code class="p">);</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="The Big Picture"><div class="sect1" id="the-big-picture">
<h1>The Big Picture</h1>

<p><a contenteditable="false" data-primary="enums" data-type="indexterm" id="idm45251623690760"/>Rust’s enums may be new to systems programming, but they are not a new idea. Traveling under various academic-sounding names, like <em>algebraic data types</em>, they’ve been used in functional programming languages for more than 40 years. It’s unclear why so few other languages in the C tradition have ever had them. Perhaps it is simply that for a programming language designer, combining variants, references, mutability, and memory safety is extremely challenging. Functional programming languages dispense with mutability. C <code>union</code>s, by contrast, have variants, pointers, and mutability—but are so spectacularly unsafe that even in C, they’re a last resort. Rust’s borrow checker is the magic that makes it possible to combine all four without compromise.</p>
<p>Programming is data processing. Getting data into the right shape can be the difference between a small, fast, elegant program and a slow, gigantic tangle of duct tape and virtual method calls.</p>
<p>This is the problem space enums address. They are a design tool for getting data into the right shape. For cases when a value may be one thing, or another thing, or perhaps nothing at all, enums are better than class hierarchies on every axis: faster, safer, less code, easier to document.</p>
<p>The limiting factor is flexibility. End users of an enum can’t extend it to add new variants. Variants can be added only by changing the enum declaration. And when that happens, existing code breaks. Every <code>match</code> expression that individually matches each variant of the enum must be revisited—it needs a new arm to handle the new variant. In some cases, trading flexibility for simplicity is just good sense. After all, the structure of JSON is not expected to change. And in some cases, revisiting all uses of an enum when it changes is exactly what we want. For example, when an <code>enum</code> is used in a compiler to represent the various operators of a programming language, adding a new operator <em>should</em> involve touching all code that handles operators.</p>
<p>But sometimes more flexibility is needed. For those situations, Rust has traits, the topic of our next chapter.</p>
</div></section>
</div></section></div></body>
</html>