<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 17. Strings and Text"><div class="chapter" id="strings-and-text">
<h1><span class="label">Chapter 17. </span>Strings and Text</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>
The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
</p>
<p data-type="attribution">
Alan Perlis, epigram #34
</p>
</blockquote>

<p><a contenteditable="false" data-primary="strings and text" data-type="indexterm" id="C17-text.html0"/>We’ve been using Rust’s main textual types, <code>String</code>, <code>str</code>, and <code>char</code>, throughout the book. In <a data-type="xref" href="ch03.xhtml#string-types">“String Types”</a>, we described the syntax for character and string literals, and showed how strings are represented in memory. In this chapter, we cover text handling in more detail.</p>

<p>In this chapter:</p>
<ul>
<li><p>We give you some background on Unicode that should help you make sense of the standard library’s design.</p></li>
<li><p>We describe the <code>char</code> type, representing a single Unicode code point.</p></li>
<li><p>We describe the <code>String</code> and <code>str</code> types, representing owned and borrowed sequences of Unicode characters. These have a broad variety of methods for building, searching, modifying, and iterating over their contents.</p></li>
<li><p>We cover Rust’s string formatting facilities, like the <code>println!</code> and <code>format!</code> macros. You can write your own macros that work with formatting strings, and extend them to support your own types.</p></li>
<li><p>We give an overview of Rust’s regular expression support.</p></li>
<li><p>Finally, we talk about why Unicode normalization matters, and show how to do it in Rust.</p></li>
</ul>

<section data-type="sect1" data-pdf-bookmark="Some Unicode Background"><div class="sect1" id="some-unicode-background">
<h1>Some Unicode Background</h1>

<p><a contenteditable="false" data-primary="strings and text" data-secondary="Unicode" data-type="indexterm" id="C17-text.html1"/><a contenteditable="false" data-primary="Unicode" data-type="indexterm" id="C17-text.html2"/>This book is about Rust, not Unicode, which has entire books devoted to it already. But Rust’s character and string types are designed around Unicode. Here are a few bits of Unicode that help explain Rust.</p>

<section data-type="sect2" data-pdf-bookmark="ASCII, Latin-1, and Unicode"><div class="sect2" id="ascii-latin-1-and-unicode">
<h2>ASCII, Latin-1, and Unicode</h2>

<p><a contenteditable="false" data-primary="ASCII" data-type="indexterm" id="idm45251587848456"/><a contenteditable="false" data-primary="Latin-1 character set" data-type="indexterm" id="idm45251587846952"/><a contenteditable="false" data-primary="Unicode" data-secondary="ASCII and" data-type="indexterm" id="idm45251587845848"/><a contenteditable="false" data-primary="Unicode" data-secondary="Latin-1 and" data-type="indexterm" id="idm45251587844472"/>Unicode and ASCII match for all of ASCII’s code points, from <code>0</code> to <code>0x7f</code>: for example, both assign the character <code>'*'</code> the code point <code>42</code>. Similarly, Unicode assigns <code>0</code> through <code>0xff</code> to the same characters as the ISO/IEC 8859-1 character set, an eight-bit superset of ASCII for use with Western European languages. Unicode calls this range of code points <em>the Latin-1 code block</em>, so we’ll refer to ISO/IEC 8859-1 by the more evocative name <em>Latin-1</em>.</p>
<p>Since Unicode is a superset of Latin-1, converting Latin-1 to Unicode doesn’t even require a table:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">latin1_to_char</code><code class="p">(</code><code class="n">latin1</code>: <code class="kt">u8</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">char</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">latin1</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="n">char</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The reverse conversion is trivial as well, assuming the code points fall in the Latin-1 range:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">char_to_latin1</code><code class="p">(</code><code class="n">c</code>: <code class="nc">char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u32</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="mh">0xff</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">c</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u8</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="UTF-8"><div class="sect2" id="utf-8">
<h2>UTF-8</h2>

<p><a contenteditable="false" data-primary="Unicode" data-secondary="UTF-8" data-type="indexterm" id="C17-text.html3"/><a contenteditable="false" data-primary="UTF-8" data-type="indexterm" id="C17-text.html4"/>The Rust <code>String</code> and <code>str</code> types represent text using the UTF-8 encoding form. UTF-8 encodes a character as a sequence of one to four bytes (<a data-type="xref" href="#fig1701">Figure 17-1</a>).</p>

<figure><div id="fig1701" class="figure">
<img src="Images/rust_1701.png" alt="(UTF-8 encodes Unicode code points using one through four bytes.)"/>
<h6><span class="label">Figure 17-1. </span>
The UTF-8 encoding
</h6>
</div></figure>

<p>There are two restrictions on well-formed UTF-8 sequences. First, only the shortest encoding for any given code point is considered well-formed; you can’t spend four bytes encoding a code point that would fit in three. This rule ensures that there is exactly one UTF-8 encoding for a given code point. Second, well-formed UTF-8 must not encode numbers from <code>0xd800</code> through <code>0xdfff</code> or beyond <code>0x10ffff</code>: those are either reserved for noncharacter purposes, or outside Unicode’s range entirely.</p>

<p><a data-type="xref" href="#fig1702">Figure 17-2</a> shows some examples.</p>

<figure><div id="fig1702" class="figure">
<img src="Images/rust_1702.png" alt="(examples of encoding the characters '*', Greek mu, Japanese 'sabi', and the crab emoji in UTF-8)"/>
<h6><span class="label">Figure 17-2. </span>
UTF-8 examples
</h6>
</div></figure>

<p>Note that, even though the crab emoji has an encoding whose leading byte contributes only zeros to the code point, it still needs a four-byte encoding: three-byte UTF-8 encodings can only convey 16-bit code points, and <code>0x1f980</code> is 17 bits long.</p>
<p>Here’s a quick example of a string containing characters with encodings of varying lengths:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"うどん: udon"</code><code class="p">.</code><code class="n">as_bytes</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="o">&amp;</code><code class="p">[</code><code class="mh">0xe3</code><code class="p">,</code><code class="w"> </code><code class="mh">0x81</code><code class="p">,</code><code class="w"> </code><code class="mh">0x86</code><code class="p">,</code><code class="w"> </code><code class="c1">// う</code>
<code class="w">             </code><code class="mh">0xe3</code><code class="p">,</code><code class="w"> </code><code class="mh">0x81</code><code class="p">,</code><code class="w"> </code><code class="mh">0xa9</code><code class="p">,</code><code class="w"> </code><code class="c1">// ど</code>
<code class="w">             </code><code class="mh">0xe3</code><code class="p">,</code><code class="w"> </code><code class="mh">0x82</code><code class="p">,</code><code class="w"> </code><code class="mh">0x93</code><code class="p">,</code><code class="w"> </code><code class="c1">// ん</code>
<code class="w">             </code><code class="mh">0x3a</code><code class="p">,</code><code class="w"> </code><code class="mh">0x20</code><code class="p">,</code><code class="w"> </code><code class="mh">0x75</code><code class="p">,</code><code class="w"> </code><code class="mh">0x64</code><code class="p">,</code><code class="w"> </code><code class="mh">0x6f</code><code class="p">,</code><code class="w"> </code><code class="mh">0x6e</code><code class="w"> </code><code class="c1">// : udon</code>
<code class="w">           </code><code class="p">]);</code><code class="w"/></pre>
<p>The diagram shows some very helpful properties of UTF-8:</p>
<ul>
<li><p>Since UTF-8 encodes code points <code>0</code> through <code>0x7f</code> as nothing more than the bytes <code>0</code> through <code>0x7f</code>, a range of bytes holding ASCII text is valid UTF-8. And if a string of UTF-8 includes only characters from ASCII, the reverse is also true: the UTF-8 encoding is valid ASCII.</p>
<p>The same is not true for Latin-1: for example, Latin-1 encodes <code>'é'</code> as the byte <code>0xe9</code>, which UTF-8 would interpret as the first byte of a three-byte encoding.</p></li>
<li><p>From looking at any byte’s upper bits, you can immediately tell whether it is the start of some character’s UTF-8 encoding, or a byte from the midst of one.</p></li>
<li><p>An encoding’s first byte alone tells you the encoding’s full length, via its leading bits.</p></li>
<li><p>Since no encoding is longer than four bytes, UTF-8 processing never requires unbounded loops, which is nice when working with untrusted data.</p></li>
<li><p>In well-formed UTF-8, you can always tell unambiguously where characters’ encodings begin and end, even if you start from an arbitrary point in the midst of the bytes. UTF-8 first bytes and following bytes are always distinct, so one encoding cannot start in the midst of another. The first byte determines the encoding’s total length, so no encoding can be a prefix of another. This has a lot of nice consequences. For example, searching a UTF-8 string for an ASCII delimiter character requires only a simple scan for the delimiter’s byte. It can never appear as any part of a multibyte encoding, so there’s no need to keep track of the UTF-8 structure at all. Similarly, algorithms that search for one byte string in another will work without modification on UTF-8 strings, even though some don’t even examine every byte of the text being searched.</p></li>
</ul>
<p>Although variable-width encodings are more complicated than fixed-width encodings, these characteristics make UTF-8 more comfortable to work with than you might expect. The standard library handles most aspects for you.<a contenteditable="false" data-primary="" data-startref="C17-text.html4" data-type="indexterm" id="idm45251587588952"/><a contenteditable="false" data-primary="" data-startref="C17-text.html3" data-type="indexterm" id="idm45251587587576"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Text Directionality"><div class="sect2" id="text-directionality">
<h2>Text Directionality</h2>

<p><a contenteditable="false" data-primary="directionality of text" data-type="indexterm" id="idm45251587584584"/><a contenteditable="false" data-primary="text directionality" data-type="indexterm" id="idm45251587583480"/><a contenteditable="false" data-primary="Unicode" data-secondary="text directionality" data-type="indexterm" id="idm45251587582376"/>Whereas scripts like Latin, Cyrillic, and Thai are written from left to right, other scripts like Hebrew and Arabic are written from right to left. Unicode stores characters in the order in which they would normally be written or read, so the initial bytes of a string holding, say, Hebrew text encode the character that would be written at the right:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"ערב טוב"</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'ע'</code><code class="p">));</code><code class="w"/></pre>
<p>A few method names in the standard library use the terms <code>left</code> and <code>right</code> to mean the start and end of the text. When we describe such functions, we’ll spell out what they actually do.<a contenteditable="false" data-primary="" data-startref="C17-text.html2" data-type="indexterm" id="idm45251587525112"/><a contenteditable="false" data-primary="" data-startref="C17-text.html1" data-type="indexterm" id="idm45251587573864"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Characters (char)"><div class="sect1" id="characters-char">
<h1>Characters (char)</h1>

<p><a contenteditable="false" data-primary="char type" data-type="indexterm" id="C17-text.html5"/><a contenteditable="false" data-primary="characters (char)" data-type="indexterm" id="C17-text.html6"/><a contenteditable="false" data-primary="strings and text" data-secondary="characters (char)" data-type="indexterm" id="C17-text.html7"/>A Rust <code>char</code> is a 32-bit value holding a Unicode code point. A <code>char</code> is guaranteed to fall in the range from <code>0</code> to <code>0xd7ff</code>, or in the range <code>0xe000</code> to <code>0x10ffff</code>; all the methods for creating and manipulating <code>char</code> values ensure that this is true. The <code>char</code> type implements <code>Copy</code> and <code>Clone</code>, along with all the usual traits for comparison, hashing, and formatting.</p>
<p>In the descriptions that follow, the variable <code>ch</code> is always of type <code>char</code>.</p>

<section data-type="sect2" data-pdf-bookmark="Classifying Characters"><div class="sect2" id="classifying-characters">
<h2>Classifying Characters</h2>

<p><a contenteditable="false" data-primary="characters (char)" data-secondary="classifying" data-type="indexterm" id="idm45251587551096"/>The <code>char</code> type has methods for classifying characters into a few common categories. These all draw their definitions from Unicode:</p>

<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ch.is_numeric()</code></td>
<td>A numeric character. This includes the Unicode general categories “Number; digit” and “Number; letter”, but not “Number; other”.</td>
<td><code>'4'.is_numeric()</code><br/> <code>'ᛮ'.is_numeric()</code><br/> <code>!'⑧'.is_numeric()</code></td>
</tr>
<tr class="even">
<td><code>ch.is_alphabetic()</code></td>
<td>An alphabetic character: Unicode’s “Alphabetic” derived property.</td>
<td><code>'q'.is_alphabetic()</code><br/> <code>'七'.is_alphabetic()</code></td>
</tr>
<tr class="odd">
<td><code>ch.is_alphanumeric()</code></td>
<td>Either numeric or alphabetic, as defined above.</td>
<td><code>'9'.is_alphanumeric()</code><br/> <code>'饂'.is_alphanumeric()</code><br/> <code>!'*'.is_alphanumeric()</code></td>
</tr>
<tr class="even">
<td><code>ch.is_whitespace()</code></td>
<td>A whitespace character: Unicode character property “WSpace=Y”.</td>
<td><code>' '.is_whitespace()</code><br/> <code>'\n'.is_whitespace()</code><br/> <code>'\u{A0}'.is_whitespace()</code></td>
</tr>
<tr class="odd">
<td><code>ch.is_control()</code></td>
<td>A control character: Unicode’s “Other, control” general category.</td>
<td><code>'\n'.is_control()</code><br/> <code>'\u{85}'.is_control()</code></td>
</tr>
</tbody>
</table>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Handling Digits"><div class="sect2" id="handling-digits">
<h2>Handling Digits</h2>

<p><a contenteditable="false" data-primary="characters (char)" data-secondary="digits" data-type="indexterm" id="idm45251587481640"/><a contenteditable="false" data-primary="digits, handling" data-type="indexterm" id="idm45251587480264"/>For handling digits, you can use the following methods:</p>
<ul>

<li><p><strong><code>ch.to_digit(radix)</code></strong> decides whether <code>ch</code> is a digit in base <code>radix</code>. If it is, it returns <code>Some(num)</code>, where <code>num</code> is a <code>u32</code>. Otherwise, it returns <code>None</code>. This recognizes only ASCII digits, not the broader class of characters covered by <code>char::is_numeric</code>. The <code>radix</code> parameter can range from 2 to 36. For radixes larger than 10, ASCII letters of either case are considered digits with values from 10 through 35.</p></li>

<li><p>The free function <strong><code>std::char::from_digit(num, radix)</code></strong> converts the <code>u32</code> digit value <code>num</code> to a <code>char</code> if possible. If <code>num</code> can be represented as a single digit in <code>radix</code>, <code>from_digit</code> returns <code>Some(ch)</code>, where <code>ch</code> is the digit. When <code>radix</code> is greater than 10, <code>ch</code> may be a lowercase letter. Otherwise, it returns <code>None</code>.</p>
<p>This is the reverse of <code>to_digit</code>. If <code>std::char::from_digit(num, radix)</code> is <code>Some(ch)</code>, then <code>ch.to_digit(radix)</code> is <code>Some(num)</code>. If <code>ch</code> is an ASCII digit or lowercase letter, the converse holds as well.</p></li>

<li><p><strong><code>ch.is_digit(radix)</code></strong> returns <code>true</code> if <code>ch</code> is an ASCII digit in base <code>radix</code>. This is equivalent to <code>ch.to_digit(radix) != None</code>.</p></li>
</ul>

<p>So, for example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'F'</code><code class="p">.</code><code class="n">to_digit</code><code class="p">(</code><code class="mi">16</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">15</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">char</code>::<code class="n">from_digit</code><code class="p">(</code><code class="mi">15</code><code class="p">,</code><code class="w"> </code><code class="mi">16</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'f'</code><code class="p">));</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">char</code>::<code class="n">is_digit</code><code class="p">(</code><code class="sc">'f'</code><code class="p">,</code><code class="w"> </code><code class="mi">16</code><code class="p">));</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Case Conversion for Characters"><div class="sect2" id="case-conversion-for-characters">
<h2>Case Conversion for Characters</h2>

<p><a contenteditable="false" data-primary="case conversion" data-secondary="for characters" data-type="indexterm" id="idm45251587413560"/><a contenteditable="false" data-primary="characters (char)" data-secondary="case conversion" data-type="indexterm" id="idm45251587412216"/>For handling character case:</p>
<ul>
<li><p><strong><code>ch.is_lowercase()</code></strong> and <strong><code>ch.is_uppercase()</code></strong> indicate whether <code>ch</code> is a lower- or uppercase alphabetic character. These follow Unicode’s Lowercase and Uppercase derived properties, so they cover non-Latin alphabets like Greek and Cyrillic, and give the expected results for ASCII as well.</p></li>

<li><p><strong><code>ch.to_lowercase()</code></strong> and <strong><code>ch.to_uppercase()</code></strong> return iterators that produce the characters of the lower- and uppercase equivalents of <code>ch</code>, according to the Unicode Default Case Conversion algorithms:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">upper</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'s'</code><code class="p">.</code><code class="n">to_uppercase</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">upper</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'S'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">upper</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>These methods return an iterator instead of a single character because case conversion in Unicode isn’t always a one-to-one process:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// The uppercase form of the German letter "sharp S" is "SS":</code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">upper</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'ß'</code><code class="p">.</code><code class="n">to_uppercase</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">upper</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'S'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">upper</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'S'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">upper</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>

<code class="c1">// Unicode says to lowercase Turkish dotted capital 'İ' to 'i'</code>
<code class="c1">// followed by `'\u{307}'`, COMBINING DOT ABOVE, so that a</code>
<code class="c1">// subsequent conversion back to uppercase preserves the dot.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">ch</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'İ'</code><code class="p">;</code><code class="w"> </code><code class="c1">// `'\u{130}'`</code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">lower</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ch</code><code class="p">.</code><code class="n">to_lowercase</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">lower</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'i'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">lower</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'\u{307}'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">lower</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>As a convenience, these iterators implement the <code>std::fmt::Display</code> trait, so you can pass them directly to a <code>println!</code> or <code>write!</code> macro.</p></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Conversions to and from Integers"><div class="sect2" id="conversions-to-and-from-integers">
<h2>Conversions to and from Integers</h2>

<p><a contenteditable="false" data-primary="characters (char)" data-secondary="integer conversion" data-type="indexterm" id="idm45251587179112"/><a contenteditable="false" data-primary="integers, converting characters to/from" data-type="indexterm" id="idm45251587177736"/>Rust’s <code>as</code> operator will convert a <code>char</code> to any integer type, silently masking off any upper bits:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'B'</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u32</code><code class="p">,</code><code class="w"> </code><code class="mi">66</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'饂'</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u8</code><code class="p">,</code><code class="w"> </code><code class="mi">66</code><code class="p">);</code><code class="w">   </code><code class="c1">// upper bits truncated</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'二'</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i8</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">116</code><code class="p">);</code><code class="w"> </code><code class="c1">// same</code></pre>
<p>The <code>as</code> operator will convert any <code>u8</code> value to a <code>char</code>, and <code>char</code> implements <code>From&lt;u8&gt;</code> as well, but wider integer types can represent invalid code points, so for those you must use <code>std::char::from_u32</code>, which returns <code>Option&lt;char&gt;</code>:<a contenteditable="false" data-primary="" data-startref="C17-text.html7" data-type="indexterm" id="idm45251587132648"/><a contenteditable="false" data-primary="" data-startref="C17-text.html6" data-type="indexterm" id="idm45251587131240"/><a contenteditable="false" data-primary="" data-startref="C17-text.html5" data-type="indexterm" id="idm45251587129864"/></p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">char</code>::<code class="n">from</code><code class="p">(</code><code class="mi">66</code><code class="p">),</code><code class="w"> </code><code class="sc">'B'</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">char</code>::<code class="n">from_u32</code><code class="p">(</code><code class="mh">0x9942</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'饂'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">char</code>::<code class="n">from_u32</code><code class="p">(</code><code class="mh">0xd800</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"> </code><code class="c1">// reserved for UTF-16</code></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="String and str"><div class="sect1" id="string-and-str">
<h1>String and str</h1>

<p><a contenteditable="false" data-primary="String types" data-type="indexterm" id="C17-text.html8"/><a contenteditable="false" data-primary="strings and text" data-secondary="String and str types" data-seealso="String type" data-type="indexterm" id="C17-text.html9"/>Rust’s <code>String</code> and <code>str</code> types are guaranteed to hold only well-formed UTF-8. The library ensures this by restricting the ways you can create <code>String</code> and <code>str</code> values and the operations you can perform on them, such that the values are well-formed when introduced, and remain so as you work with them. All their methods protect this guarantee: no safe operation on them can introduce ill-formed UTF-8. This simplifies code that works with the text.</p>
<p>Rust places text-handling methods on either <code>str</code> or <code>String</code> depending on whether the method needs a resizable buffer, or is content just to use the text in place. Since <code>String</code> dereferences to <code>&amp;str</code>, every method defined on <code>str</code> is directly available on <code>String</code> as well. This section presents methods from both types, grouped by rough function.</p>
<p>These methods index text by byte offsets, and measure its length in bytes, rather than characters. In practice, given the nature of Unicode, indexing by character is not as useful as it may seem, and byte offsets are faster and simpler. If you try to use a byte offset that lands in the midst of some character’s UTF-8 encoding, the method panics, so you can’t introduce ill-formed UTF-8 this way.</p>
<p>A <code>String</code> is implemented as a wrapper around a <code>Vec&lt;u8&gt;</code> that ensures the vector’s contents are always well-formed UTF-8. Rust will never change <code>String</code> to use a more complicated representation, so you can assume that <code>String</code> shares <code>Vec</code>’s performance characteristics.</p>
<p>In these explanations, the following variables have the given types:</p>

<table>

<thead>
<tr class="header">
<th>Variable</th>
<th>Presumed type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>string</code></td>
<td><code>String</code></td>
</tr>
<tr class="even">
<td><code>slice</code></td>
<td><code>&amp;str</code> or something that dereferences to one, like <code>String</code> or <code>Rc&lt;String&gt;</code></td>
</tr>
<tr class="odd">
<td><code>ch</code></td>
<td><code>char</code></td>
</tr>
<tr class="even">
<td><code>n</code></td>
<td><code>usize</code>, a length</td>
</tr>
<tr class="odd">
<td><code>i</code>, <code>j</code></td>
<td><code>usize</code>, a byte offset</td>
</tr>
<tr class="even">
<td><code>range</code></td>
<td>A range of <code>usize</code> byte offsets, either fully bounded like <code>i..j</code>, or partly bounded like <code>i..</code>, <code>..j</code>, or <code>..</code></td>
</tr>
<tr class="odd">
<td><code>pattern</code></td>
<td>Any pattern type: <code>char</code>, <code>String</code>, <code>&amp;str</code>, <code>&amp;[char]</code>, or <code>FnMut(char) -&gt; bool</code></td>
</tr>
</tbody>
</table>

<p>We describe pattern types in <a data-type="xref" href="#patterns-for-searching-text">“Patterns for Searching Text”</a>.</p>

<section data-type="sect2" data-pdf-bookmark="Creating String Values"><div class="sect2" id="creating-string-values">
<h2>Creating String Values</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="creating String values" data-type="indexterm" id="idm45251587001736"/>There are a few common ways to create <code>String</code> values:</p>

<ul>
<li><p><strong><code>String::new()</code></strong> returns a fresh, empty string. This has no heap-allocated buffer, but will allocate one as needed.</p></li>

<li><p><strong><code>String::with_capacity(n)</code></strong> returns a fresh, empty string with a buffer pre-allocated to hold at least <code>n</code> bytes. If you know the length of the string you’re building in advance, this constructor lets you get the buffer sized correctly from the start, instead of resizing the buffer as you build the string. The string will still grow its buffer as needed if its length exceeds <code>n</code> bytes. Like vectors, strings have <code>capacity</code>, <code>reserve</code>, and <code>shrink_to_fit</code> methods, but usually the default allocation logic is fine.</p></li>

<li><p><strong><code>slice.to_string()</code></strong> allocates a fresh <code>String</code> whose contents are a copy of <code>slice</code>. We’ve been using expressions like <code>"literal text".to_string()</code> throughout the book to make <code>String</code>s from string literals.</p></li>

<li><p><strong><code>iter.collect()</code></strong> constructs a string by concatenating an iterator’s items, which can be <code>char</code>, <code>&amp;str</code>, or <code>String</code> values. For example, to remove all spaces from a string, you can write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">spacey</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"man hat tan"</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">spaceless</code>: <code class="nb">String</code> <code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">spacey</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="o">!</code><code class="n">c</code><code class="p">.</code><code class="n">is_whitespace</code><code class="p">()).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">spaceless</code><code class="p">,</code><code class="w"> </code><code class="s">"manhattan"</code><code class="p">);</code><code class="w"/></pre>

<p>Using <code>collect</code> this way takes advantage of <code>String</code>’s implementation of the <code>std::iter::FromIterator</code> trait.</p></li>

<li><p>The <code>str</code> type cannot implement <code>Clone</code>: the trait would require <code>clone</code> on a <code>&amp;str</code> to return a <code>str</code> value, but <code>str</code> is unsized. However, <code>&amp;str</code> does implement <code>ToOwned</code>, which lets the implementer specify its owned equivalent, so <strong><code>slice.to_owned()</code></strong> returns a copy of <code>slice</code> as a freshly allocated <code>String</code>.</p></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Simple Inspection"><div class="sect2" id="simple-inspection">
<h2>Simple Inspection</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="simple inspection" data-type="indexterm" id="idm45251586912312"/>These methods get basic information from string slices:</p>

<ul>
<li><p><strong><code>slice.len()</code></strong> is the length of <code>slice</code>, in bytes.</p></li>

<li><p><strong><code>slice.is_empty()</code></strong> is true if <code>slice.len() == 0</code>.</p></li>

<li><p><strong><code>slice[range]</code></strong> returns a slice borrowing the given portion of <code>slice</code>. Partially bounded and unbounded ranges are OK: For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">full</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"bookkeeping"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">full</code><code class="p">[..</code><code class="mi">4</code><code class="p">],</code><code class="w"> </code><code class="s">"book"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">full</code><code class="p">[</code><code class="mi">5</code><code class="p">..],</code><code class="w"> </code><code class="s">"eeping"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">full</code><code class="p">[</code><code class="mi">2</code><code class="p">..</code><code class="mi">4</code><code class="p">],</code><code class="w"> </code><code class="s">"ok"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">full</code><code class="p">[..].</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">11</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">full</code><code class="p">[</code><code class="mi">5</code><code class="p">..].</code><code class="n">contains</code><code class="p">(</code><code class="s">"boo"</code><code class="p">),</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/></pre></li>

<li><p>You cannot index a string slice with a single position, like <code>slice[i]</code>. Fetching a single character at a given byte offset is a bit clumsy: you must produce a <code>chars</code> iterator over the slice, and ask it to parse one character’s UTF-8:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">parenthesized</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Rust (饂)"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parenthesized</code><code class="p">[</code><code class="mi">6</code><code class="p">..].</code><code class="n">chars</code><code class="p">().</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'饂'</code><code class="p">));</code><code class="w"/></pre>
<p>However, you should rarely need to do this. Rust has much nicer ways to iterate over slices, which we describe in <a data-type="xref" href="#iterating-over-text">“Iterating over Text”</a>.</p></li>

<li><p><strong><code>slice.split_at(i)</code></strong> returns a tuple of two shared slices borrowed from <code>slice</code>: the portion up to byte offset <code>i</code>, and the portion after it. In other words, this returns <code>(slice[..i], slice[i..])</code>.</p></li>

<li><p><strong><code>slice.is_char_boundary(i)</code></strong> is <code>true</code> if the byte offset <code>i</code> falls between character boundaries, and is thus suitable as an offset into <code>slice</code>.</p></li>
</ul>

<p>Naturally, slices can be compared for equality, ordered, and hashed. Ordered comparison simply treats the string as a sequence of Unicode code points and compares them in lexicographic order.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Appending and Inserting Text"><div class="sect2" id="appending-and-inserting-text">
<h2>Appending and Inserting Text</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="adding text to" data-type="indexterm" id="idm45251586756008"/><a contenteditable="false" data-primary="text" data-seealso="strings and text" data-secondary="adding to String" data-type="indexterm" id="idm45251586754632"/>The following methods add text to a <code>String</code>:</p>

<ul>
<li><p><strong><code>string.push(ch)</code></strong> appends the character <code>ch</code> to the end <code>string</code>.</p></li>

<li><p><strong><code>string.push_str(slice)</code></strong> appends the full contents of <code>slice</code>.</p></li>

<li><p><strong><code>string.extend(iter)</code></strong> appends the items produced by the iterator <code>iter</code> to the string. The iterator can produce <code>char</code>, <code>str</code>, or <code>String</code> values. These are <code>String</code>’s implementations of <code>std::iter::Extend</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">also_spaceless</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"con"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="n">also_spaceless</code><code class="p">.</code><code class="n">extend</code><code class="p">(</code><code class="s">"tri but ion"</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">());</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">also_spaceless</code><code class="p">,</code><code class="w"> </code><code class="s">"contribution"</code><code class="p">);</code><code class="w"/></pre></li>

<li><p><strong><code>string.insert(i, ch)</code></strong> inserts the single character <code>ch</code> at byte offset <code>i</code> in <code>string</code>. This entails shifting over any characters after <code>i</code> to make room for <code>ch</code>, so building up a string this way can require time quadratic in the length of the string.</p></li>

<li><p><strong><code>string.insert_str(i, slice)</code></strong> does the same for <code>slice</code>, with the same performance caveat.</p></li>
</ul>

<p><code>String</code> implements <code>std::fmt::Write</code>, meaning that the <code>write!</code> and <code>writeln!</code> macros can append formatted text to <code>String</code>s:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Write</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">letter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">letter</code><code class="p">,</code><code class="w"> </code><code class="s">"Whose {} these are I think I know"</code><code class="p">,</code><code class="w"> </code><code class="s">"rutabagas"</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">letter</code><code class="p">,</code><code class="w"> </code><code class="s">"His house is in the village though;"</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">letter</code><code class="p">,</code><code class="w"> </code><code class="s">"Whose rutabagas these are I think I know</code><code class="se">\n</code><code class="s">\</code>
<code class="s">                    His house is in the village though;</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code><code class="w"/></pre>

<p>Since <code>write!</code> and <code>writeln!</code> are designed for writing to output streams, they return a <code>Result</code>, which Rust complains if you ignore. This code uses the <code>?</code> operator to handle it, but writing to a <code>String</code> is actually infallible, so in this case calling <code>.unwrap()</code> would be OK too.</p>

<p>Since <code>String</code> implements <code>Add&lt;&amp;str&gt;</code> and <code>AddAssign&lt;&amp;str&gt;</code>, you can write code like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">left</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"partners"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">right</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"crime"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">left</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">" in "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="o">&amp;</code><code class="n">right</code><code class="p">,</code><code class="w"> </code><code class="s">"partners in crime"</code><code class="p">);</code><code class="w"/>

<code class="n">right</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="s">" doesn't pay"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">right</code><code class="p">,</code><code class="w"> </code><code class="s">"crime doesn't pay"</code><code class="p">);</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="+ operator" data-type="indexterm" id="idm45251586557928"/>When applied to strings, the <code>+</code> operator takes its left operand by value, so it can actually reuse that <code>String</code> as the result of the addition. As a consequence, if the left operand’s buffer is large enough to hold the result, no allocation is needed.</p>
<p>In an unfortunate lack of symmetry, the left operand of <code>+</code> cannot be a <code>&amp;str</code>, so you cannot write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">parenthetical</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"("</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">string</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">")"</code><code class="p">;</code><code class="w"/></pre>
<p>You must instead write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">parenthetical</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"("</code><code class="p">.</code><code class="n">to_string</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="o">&amp;</code><code class="n">string</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">")"</code><code class="p">;</code><code class="w"/></pre>

<p>However, this restriction does discourage building up strings from the end backward. This approach performs poorly because the text must be repeatedly shifted toward the end of the buffer.</p>

<p>Building strings from beginning to end by appending small pieces, however, is efficient. A <code>String</code> behaves the way a vector does, always at least doubling its buffer’s size when it needs more capacity. This keeps recopying overhead proportional to the final size. Even so, using <code>String::with_capacity</code> to create strings with the right buffer size to begin with avoids resizing at all, and can reduce the number of calls to the heap allocator.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Removing Text"><div class="sect2" id="removing-text">
<h2>Removing Text</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="removing text from" data-type="indexterm" id="idm45251586395640"/><a contenteditable="false" data-primary="text" data-secondary="removing from String" data-type="indexterm" id="idm45251586394264"/><code>String</code> has a few methods for removing text (these do not affect the string’s capacity; use <code>shrink_to_fit</code> if you need to free memory):</p>

<ul>
<li><p><strong><code>string.clear()</code></strong> resets <code>string</code> to the empty string.</p></li>

<li><p><strong><code>string.truncate(n)</code></strong> discards all characters after the byte offset <code>n</code>, leaving <code>string</code> with a length of at most <code>n</code>. If <code>string</code> is shorter than <code>n</code> bytes, this has no effect.</p></li>

<li><p><strong><code>string.pop()</code></strong> removes the last character from <code>string</code>, if any, and returns it as an <code>Option&lt;char&gt;</code>.</p></li>

<li><p><strong><code>string.remove(i)</code></strong> removes the character at byte offset <code>i</code> from <code>string</code> and returns it, shifting any following characters toward the front. This takes time linear in the number of following characters.</p></li>

<li><p><strong><code>string.drain(range)</code></strong> returns an iterator over the given range of byte indices, and removes the characters once the iterator is dropped. Characters after the range are shifted toward the front:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">choco</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"chocolate"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">choco</code><code class="p">.</code><code class="n">drain</code><code class="p">(</code><code class="mi">3</code><code class="p">..</code><code class="mi">6</code><code class="p">).</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="s">"col"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">choco</code><code class="p">,</code><code class="w"> </code><code class="s">"choate"</code><code class="p">);</code><code class="w"/></pre>
<p>If you just want to remove the range, you can just drop the iterator immediately, without drawing any items from it:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">winston</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Churchill"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="n">winston</code><code class="p">.</code><code class="n">drain</code><code class="p">(</code><code class="mi">2</code><code class="p">..</code><code class="mi">6</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">winston</code><code class="p">,</code><code class="w"> </code><code class="s">"Chill"</code><code class="p">);</code><code class="w"/></pre></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Conventions for Searching and Iterating"><div class="sect2" id="conventions-for-searching-and-iterating">
<h2>Conventions for Searching and Iterating</h2>

<p><a contenteditable="false" data-primary="search" data-secondary="conventions for searching/iterating text" data-type="indexterm" id="idm45251586246680"/><a contenteditable="false" data-primary="String types" data-secondary="conventions for searching/iterating text" data-type="indexterm" id="idm45251586245272"/><a contenteditable="false" data-primary="text" data-secondary="conventions for searching/iterating" data-type="indexterm" id="idm45251586243864"/>Rust’s standard library functions for searching text and iterating over text follow some naming conventions to make them easier to remember:</p>

<ul>
<li><p>Most operations process text from start to end, but operations with names starting with <strong><code>r</code></strong> work from end to start. For example, <code>rsplit</code> is the end-to-start version of <code>split</code>. In some cases changing direction can affect not only the order in which values are produced but also the values themselves. See the diagram in <a data-type="xref" href="#str-iterator-figure">Figure 17-3</a> for an example of this.</p></li>
<li><p>Iterators with names ending in <strong><code>n</code></strong> limit themselves to a given number of matches.</p></li>
<li><p>Iterators with names ending in <strong><code>_indices</code></strong> produce, together with their usual iteration values, the byte offsets in the slice at which they appear.</p></li>
</ul>
<p>The standard library doesn’t provide all combinations for every operation. For example, many operations don’t need an <code>n</code> variant, as it’s easy enough to simply end the iteration early.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Patterns for Searching Text"><div class="sect2" id="patterns-for-searching-text">
<h2>Patterns for Searching Text</h2>

<p><a contenteditable="false" data-primary="patterns" data-secondary="for searching text" data-type="indexterm" id="idm45251586233464"/><a contenteditable="false" data-primary="search" data-secondary="patterns for searching text" data-type="indexterm" id="idm45251586296568"/><a contenteditable="false" data-primary="String types" data-secondary="patterns for searching text" data-type="indexterm" id="idm45251586295128"/><a contenteditable="false" data-primary="text" data-secondary="patterns for searching" data-type="indexterm" id="idm45251586293736"/>When a standard library function needs to search, match, split, or trim text, it accepts several different types to represent what to look for:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">haystack</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"One fine day, in the middle of the night"</code><code class="p">;</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">haystack</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="sc">','</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">12</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">haystack</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="s">"night"</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">35</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">haystack</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="n">char</code>::<code class="n">is_whitespace</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code><code class="w"/></pre>
<p>These types are called <em>patterns</em>, and most operations support them:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"## Elephants"</code><code class="w"/>
<code class="w">           </code><code class="p">.</code><code class="n">trim_left_matches</code><code class="p">(</code><code class="o">|</code><code class="n">ch</code>: <code class="nc">char</code><code class="o">|</code><code class="w"> </code><code class="n">ch</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">'#'</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">ch</code><code class="p">.</code><code class="n">is_whitespace</code><code class="p">()),</code><code class="w"/>
<code class="w">           </code><code class="s">"Elephants"</code><code class="p">);</code><code class="w"/></pre>
<p>The standard library supports four main kinds of patterns:</p>
<ul>
<li><p>A <code>char</code> as a pattern matches that character.</p></li>
<li><p>A <code>String</code> or <code>&amp;str</code> or <code>&amp;&amp;str</code> as a pattern matches a substring equal to the pattern.</p></li>
<li><p>A <code>FnMut(char) -&gt; bool</code> closure as a pattern matches a single character for which the closure returns true.</p></li>
<li><p>A <code>&amp;[char]</code> as a pattern (not a <code>&amp;str</code>, but a slice of <code>char</code> values) matches any single character that appears in the list. Note that if you write out the list as an array literal, you may need to use an <code>as</code> expression to get the type right:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">code</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"</code><code class="se">\t</code><code class="s">    function noodle() { "</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">code</code><code class="p">.</code><code class="n">trim_left_matches</code><code class="p">(</code><code class="o">&amp;</code><code class="p">[</code><code class="sc">' '</code><code class="p">,</code><code class="w"> </code><code class="sc">'\t'</code><code class="p">]</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="n">char</code><code class="p">]),</code><code class="w"/>
<code class="w">           </code><code class="s">"function noodle() { "</code><code class="p">);</code><code class="w"/>
<code class="c1">// Shorter equivalent: &amp;[' ', '\t'][..]</code></pre>
<p>Otherwise, Rust will be confused by the fixed-size array type <code>&amp;[char; 2]</code>, which is unfortunately not a pattern type.</p></li>
</ul>
<p>In the library’s own code, a pattern is any type that implements the <code>std::str::Pattern</code> trait. The details of <code>Pattern</code> are not yet stable, so you can’t implement it for your own types in stable Rust, but the door is open to permit regular expressions and other sophisticated patterns in the future. Rust does guarantee that the pattern types supported now will continue to work in the future.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Searching and Replacing"><div class="sect2" id="searching-and-replacing">
<h2>Searching and Replacing</h2>

<p><a contenteditable="false" data-primary="patterns" data-secondary="searching and replacing" data-type="indexterm" id="idm45251586057992"/><a contenteditable="false" data-primary="String types" data-secondary="searching and replacing patterns/text" data-type="indexterm" id="idm45251586056616"/><a contenteditable="false" data-primary="text" data-secondary="searching and replacing" data-type="indexterm" id="idm45251586055272"/>Rust has a few methods for searching for patterns in slices and possibly replacing them with new text:</p>

<ul>
<li><p><strong><code>slice.contains(pattern)</code></strong> returns true if <code>slice</code> contains a match for <code>pattern</code>.</p></li>

<li><p><strong><code>slice.starts_with(pattern)</code></strong> and <strong><code>slice.ends_with(pattern)</code></strong> return true if <code>slice</code>’s initial or final text matches <code>pattern</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="s">"2017"</code><code class="p">.</code><code class="n">starts_with</code><code class="p">(</code><code class="n">char</code>::<code class="n">is_numeric</code><code class="p">));</code><code class="w"/></pre></li>

<li><p><strong><code>slice.find(pattern)</code></strong> and <strong><code>slice.rfind(pattern)</code></strong> return <code>Some(i)</code> if <code>slice</code> contains a match for <code>pattern</code>, where <code>i</code> is the byte offset at which the pattern appears. The <code>find</code> method returns the first match, <code>rfind</code> the last:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">quip</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"We also know there are known unknowns"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">quip</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="s">"know"</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">8</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">quip</code><code class="p">.</code><code class="n">rfind</code><code class="p">(</code><code class="s">"know"</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">31</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">quip</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="s">"ya know"</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">quip</code><code class="p">.</code><code class="n">rfind</code><code class="p">(</code><code class="n">char</code>::<code class="n">is_uppercase</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code><code class="w"/></pre></li>

<li><p><strong><code>slice.replace(pattern, replacement)</code></strong> returns a new <code>String</code> formed by replacing all matches for <code>pattern</code> with <code>replacement</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"The only thing we have to fear is fear itself"</code><code class="w"/>
<code class="w">           </code><code class="p">.</code><code class="n">replace</code><code class="p">(</code><code class="s">"fear"</code><code class="p">,</code><code class="w"> </code><code class="s">"spin"</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"The only thing we have to spin is spin itself"</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"`Borrow` and `BorrowMut`"</code><code class="w"/>
<code class="w">           </code><code class="p">.</code><code class="n">replace</code><code class="p">(</code><code class="o">|</code><code class="n">ch</code>:<code class="nc">char</code><code class="o">|</code><code class="w"> </code><code class="o">!</code><code class="n">ch</code><code class="p">.</code><code class="n">is_alphanumeric</code><code class="p">(),</code><code class="w"> </code><code class="s">""</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"BorrowandBorrowMut"</code><code class="p">);</code><code class="w"/></pre></li>

<li><p><strong><code>slice.replacen(pattern, replacement, n)</code></strong> does the same, but replaces at most the first <code>n</code> matches.</p></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Iterating over Text"><div class="sect2" id="iterating-over-text">
<h2>Iterating over Text</h2>

<p><a contenteditable="false" data-primary="iterating" data-secondary="over text" data-type="indexterm" id="C17-text.html10"/><a contenteditable="false" data-primary="String types" data-secondary="iterating over text" data-type="indexterm" id="C17-text.html11"/><a contenteditable="false" data-primary="text" data-secondary="iterating over" data-type="indexterm" id="C17-text.html12"/>The standard library provides several ways to iterate over a slice’s text. <a data-type="xref" href="#str-iterator-figure">Figure 17-3</a> shows examples of some.</p>

<p>You can think of the <code>split</code> and <code>match</code> families as being complements of each other: splits are the ranges between matches.</p>

<figure><div id="str-iterator-figure" class="figure">
<img src="Images/rust_1703.png" alt="(A sample text, and the items various iterators would produce            when applied to it.)"/>
<h6><span class="label">Figure 17-3. </span>
Some ways to iterate over a slice
</h6>
</div></figure>

<p>For some kinds of patterns, working from end to start can change the values produced; for an example, see the splits on the pattern <code>"rr"</code> in the figure. Patterns that always match a single character can’t behave this way. When an iterator would produce the same set of items in either direction (that is, when only the order is affected), the iterator is a <code>DoubleEndedIterator</code>, meaning that you can apply its <code>rev</code> method to iterate in the other order, and draw items from either end:</p>

<ul>
<li><p><strong><code>slice.chars()</code></strong> returns an iterator over <code>slice</code>’s characters.</p></li>

<li><p><strong><code>slice.char_indices()</code></strong> returns an iterator over <code>slice</code>’s characters and their byte offsets:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"élan"</code><code class="p">.</code><code class="n">char_indices</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="sc">'é'</code><code class="p">),</code><code class="w"> </code><code class="c1">// has a two-byte UTF-8 encoding</code>
<code class="w">                </code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="sc">'l'</code><code class="p">),</code><code class="w"/>
<code class="w">                </code><code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="sc">'a'</code><code class="p">),</code><code class="w"/>
<code class="w">                </code><code class="p">(</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="sc">'n'</code><code class="p">)]);</code><code class="w"/></pre>
<p>Note that this is not equivalent to <code>.chars().enumerate()</code>, since it supplies each character’s byte offset within the slice, instead of just numbering the characters.</p></li>

<li><p><strong><code>slice.bytes()</code></strong> returns an iterator over the individual bytes of <code>slice</code>, exposing the UTF-8 encoding:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"élan"</code><code class="p">.</code><code class="n">bytes</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">195</code><code class="p">,</code><code class="w"> </code><code class="mi">169</code><code class="p">,</code><code class="w"> </code><code class="sc">b'l'</code><code class="p">,</code><code class="w"> </code><code class="sc">b'a'</code><code class="p">,</code><code class="w"> </code><code class="sc">b'n'</code><code class="p">]);</code><code class="w"/></pre></li>

<li><p><strong><code>slice.lines()</code></strong> returns an iterator over the lines of <code>slice</code>. Lines are terminated by <code>"\n"</code> or <code>"\r\n"</code>. Each item produced is a <code>&amp;str</code> borrowing from <code>slice</code>. The items do not include the lines’ terminating characters.</p></li>

<li><p><strong><code>slice.split(pattern)</code></strong> returns an iterator over the portions of <code>slice</code> separated by matches of <code>pattern</code>. This produces empty strings between immediately adjacent matches, as well as for matches at the beginning and end of <code>slice</code>.</p></li>

<li><p>The <strong><code>slice.rsplit(pattern)</code></strong> method is the same, but scans <code>slice</code> from end to start, producing matches in that order.</p></li>

<li><p><strong><code>slice.split_terminator(pattern)</code></strong> and <strong><code>slice.rsplit_terminator(pattern)</code></strong> are similar, except that the pattern is treated as a terminator, not a separator: if <code>pattern</code> matches at the right end of <code>slice</code>, the iterators do not produce an empty slice representing the empty string between that match and the end of the slice, as <code>split</code> and <code>rsplit</code> do. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// The ':' characters are separators here. Note the final "".</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"jimb:1000:Jim Blandy:"</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="sc">':'</code><code class="p">).</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"jimb"</code><code class="p">,</code><code class="w"> </code><code class="s">"1000"</code><code class="p">,</code><code class="w"> </code><code class="s">"Jim Blandy"</code><code class="p">,</code><code class="w"> </code><code class="s">""</code><code class="p">]);</code><code class="w"/>

<code class="c1">// The '\n' characters are terminators here.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"127.0.0.1  localhost</code><code class="se">\n</code><code class="s">\</code>
<code class="s">            127.0.0.1  www.reddit.com</code><code class="se">\n</code><code class="s">"</code><code class="w"/>
<code class="w">           </code><code class="p">.</code><code class="n">split_terminator</code><code class="p">(</code><code class="sc">'\n'</code><code class="p">).</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"127.0.0.1  localhost"</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="s">"127.0.0.1  www.reddit.com"</code><code class="p">]);</code><code class="w"/>
<code class="w">                </code><code class="c1">// Note, no final ""!</code></pre></li>

<li><p>The <strong><code>slice.splitn(n, pattern)</code></strong> and <strong><code>slice.rsplitn(n, pattern)</code></strong> are like <code>split</code> and <code>rsplit</code>, except that they split the string into at most <code>n</code> slices, at the first or last <code>n-1</code> matches for <code>pattern</code>.</p></li>

<li><p><strong><code>slice.split_whitespace()</code></strong> returns an iterator over the whitespace-separated portions of <code>slice</code>. A run of multiple whitespace characters is considered a single separator. Trailing whitespace is ignored. This uses the same definition of <em>whitespace</em> as <code>char::is_whitespace</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">poem</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"This  is  just  to say</code><code class="se">\n</code><code class="s">\</code>
<code class="s">            I have eaten</code><code class="se">\n</code><code class="s">\</code>
<code class="s">            the plums</code><code class="se">\n</code><code class="s">\</code>
<code class="s">            again</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">poem</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"This"</code><code class="p">,</code><code class="w"> </code><code class="s">"is"</code><code class="p">,</code><code class="w"> </code><code class="s">"just"</code><code class="p">,</code><code class="w"> </code><code class="s">"to"</code><code class="p">,</code><code class="w"> </code><code class="s">"say"</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="s">"I"</code><code class="p">,</code><code class="w"> </code><code class="s">"have"</code><code class="p">,</code><code class="w"> </code><code class="s">"eaten"</code><code class="p">,</code><code class="w"> </code><code class="s">"the"</code><code class="p">,</code><code class="w"> </code><code class="s">"plums"</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="s">"again"</code><code class="p">]);</code><code class="w"/></pre></li>

<li><p><strong><code>slice.matches(pattern)</code></strong> returns an iterator over the matches for <code>pattern</code> in slice. <strong><code>slice.rmatches(pattern)</code></strong> is the same, but iterates from end to start.</p></li>

<li><p><strong><code>slice.match_indices(pattern)</code></strong> and <strong><code>slice.rmatch_indices(pattern)</code></strong> are similar, except that the items produced are <code>(offset, match)</code> pairs, where <code>offset</code> is the byte offset at which the match begins, and <code>match</code> is the matching slice.<a contenteditable="false" data-primary="" data-startref="C17-text.html12" data-type="indexterm" id="idm45251585415480"/><a contenteditable="false" data-primary="" data-startref="C17-text.html11" data-type="indexterm" id="idm45251585414184"/><a contenteditable="false" data-primary="" data-startref="C17-text.html10" data-type="indexterm" id="idm45251585412808"/></p></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Trimming"><div class="sect2" id="trimming">
<h2>Trimming</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="trimming text" data-type="indexterm" id="idm45251585409944"/><a contenteditable="false" data-primary="text" data-secondary="trimming" data-type="indexterm" id="idm45251585408568"/><a contenteditable="false" data-primary="trimming" data-type="indexterm" id="idm45251585407192"/>To <em>trim</em> a string is to remove text, usually whitespace, from the beginning or end of the string. It’s often useful in cleaning up input read from a file where the user might have indented text for legibility, or accidentally left trailing whitespace on a line.</p>

<ul>
<li><p><strong><code>slice.trim()</code></strong> returns a subslice of <code>slice</code> that omits any leading and trailing whitespace. <strong><code>slice.trim_left()</code></strong> omits only leading whitespace, <strong><code>slice.trim_right()</code></strong> only trailing whitespace:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"</code><code class="se">\t</code><code class="s">*.rs  "</code><code class="p">.</code><code class="n">trim</code><code class="p">(),</code><code class="w"> </code><code class="s">"*.rs"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"</code><code class="se">\t</code><code class="s">*.rs  "</code><code class="p">.</code><code class="n">trim_left</code><code class="p">(),</code><code class="w"> </code><code class="s">"*.rs  "</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"</code><code class="se">\t</code><code class="s">*.rs  "</code><code class="p">.</code><code class="n">trim_right</code><code class="p">(),</code><code class="w"> </code><code class="s">"</code><code class="se">\t</code><code class="s">*.rs"</code><code class="p">);</code><code class="w"/></pre></li>

<li><p><strong><code>slice.trim_matches(pattern)</code></strong> returns a subslice of <code>slice</code> that omits all matches of <code>pattern</code> from the beginning and end. The <strong><code>trim_left_matches</code></strong> and <strong><code>trim_right_matches</code></strong> methods do the same for only leading or trailing matches:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"001990"</code><code class="p">.</code><code class="n">trim_left_matches</code><code class="p">(</code><code class="sc">'0'</code><code class="p">),</code><code class="w"> </code><code class="s">"1990"</code><code class="p">);</code><code class="w"/></pre></li>
</ul>

<p>Note that the terms <code>left</code> and <code>right</code> in these methods’ names always refer to the start and end of the slice, respectively, regardless of the directionality of the text they hold.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Case Conversion for Strings"><div class="sect2" id="case-conversion-for-strings">
<h2>Case Conversion for Strings</h2>

<p><a contenteditable="false" data-primary="case conversion" data-secondary="for strings" data-type="indexterm" id="idm45251585311048"/><a contenteditable="false" data-primary="String types" data-secondary="case conversion for" data-type="indexterm" id="idm45251585309352"/><a contenteditable="false" data-primary="text" data-secondary="case conversion for" data-type="indexterm" id="idm45251585307976"/>The methods <strong><code>slice.to_uppercase()</code></strong> and <strong><code>slice.to_lowercase()</code></strong> return a freshly allocated string holding the text of <code>slice</code> converted to uppercase or lowercase. The result may not be the same length as <code>slice</code>; see <a data-type="xref" href="#case-conversion-for-characters">“Case Conversion for Characters”</a> for details.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Parsing Other Types from Strings"><div class="sect2" id="parsing-other-types-from-strings">
<h2>Parsing Other Types from Strings</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="parsing values from" data-type="indexterm" id="idm45251585370296"/><a contenteditable="false" data-primary="values" data-secondary="parsing from strings" data-type="indexterm" id="idm45251585368920"/>Rust provides standard traits for both parsing values from strings and producing textual representations of values.</p>
<p>If a type implements the <code>std::str::FromStr</code> trait, then it provides a standard way to parse a value from a string slice:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">FromStr</code>: <code class="nb">Sized</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nb">Err</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from_str</code><code class="p">(</code><code class="n">s</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">Self</code><code class="p">,</code><code class="w"> </code><code class="n">Self</code>::<code class="nb">Err</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>All the usual machine types implement <code>FromStr</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="kt">str</code>::<code class="n">FromStr</code><code class="p">;</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="kt">usize</code>::<code class="n">from_str</code><code class="p">(</code><code class="s">"3628800"</code><code class="p">),</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="mi">3628800</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="kt">f64</code>::<code class="n">from_str</code><code class="p">(</code><code class="s">"128.5625"</code><code class="p">),</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="mf">128.5625</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="kt">bool</code>::<code class="n">from_str</code><code class="p">(</code><code class="s">"true"</code><code class="p">),</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="kc">true</code><code class="p">));</code><code class="w"/>

<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="kt">f64</code>::<code class="n">from_str</code><code class="p">(</code><code class="s">"not a float at all"</code><code class="p">).</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="kt">bool</code>::<code class="n">from_str</code><code class="p">(</code><code class="s">"TRUE"</code><code class="p">).</code><code class="n">is_err</code><code class="p">());</code><code class="w"/></pre>
<p>The <code>std::net::IpAddr</code> type, an <code>enum</code> holding either an IPv4 or an IPv6 internet address, implements <code>FromStr</code> too:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">net</code>::<code class="n">IpAddr</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">address</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">IpAddr</code>::<code class="n">from_str</code><code class="p">(</code><code class="s">"fe80::0000:3ea9:f4ff:fe34:7a50"</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">address</code><code class="p">,</code><code class="w"/>
<code class="w">           </code><code class="n">IpAddr</code>::<code class="n">from</code><code class="p">([</code><code class="mh">0xfe80</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mh">0x3ea9</code><code class="p">,</code><code class="w"> </code><code class="mh">0xf4ff</code><code class="p">,</code><code class="w"> </code><code class="mh">0xfe34</code><code class="p">,</code><code class="w"> </code><code class="mh">0x7a50</code><code class="p">]));</code><code class="w"/></pre>
<p>String slices have a <code>parse</code> method that parses the slice into whatever type you like, assuming it implements <code>FromStr</code>. As with <code>Iterator::collect</code>, you will sometimes need to spell out which type you want, so <code>parse</code> is not always much more legible than calling <code>from_str</code> directly:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">address</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"fe80::0000:3ea9:f4ff:fe34:7a50"</code><code class="p">.</code><code class="n">parse</code>::<code class="o">&lt;</code><code class="n">IpAddr</code><code class="o">&gt;</code><code class="p">()</code><code class="o">?</code><code class="p">;</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Converting Other Types to Strings"><div class="sect2" id="converting-other-types-to-strings">
<h2>Converting Other Types to Strings</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="converting nontextual values to" data-type="indexterm" id="idm45251585002760"/>There are three main ways to convert nontextual values to strings:</p>

<ul>
<li><p><a contenteditable="false" data-primary="Display trait" data-type="indexterm" id="idm45251585000616"/>Types that have a natural human-readable printed form can implement the <code>std::fmt::Display</code> trait, which lets you use the <code>{}</code> format specifier in the <code>format!</code> macro:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}, wow"</code><code class="p">,</code><code class="w"> </code><code class="s">"doge"</code><code class="p">),</code><code class="w"> </code><code class="s">"doge, wow"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="kc">true</code><code class="p">),</code><code class="w"> </code><code class="s">"true"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"({:.3}, {:.3})"</code><code class="p">,</code><code class="w"> </code><code class="mf">0.5</code><code class="p">,</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">sqrt</code><code class="p">(</code><code class="mf">3.0</code><code class="p">)</code><code class="o">/</code><code class="mf">2.0</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"(0.500, 0.866)"</code><code class="p">);</code><code class="w"/>

<code class="c1">// Using `address` from above.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">formatted_addr</code>: <code class="nb">String</code> <code class="o">=</code><code class="w"> </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">address</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">formatted_addr</code><code class="p">,</code><code class="w"> </code><code class="s">"fe80::3ea9:f4ff:fe34:7a50"</code><code class="p">);</code><code class="w"/></pre>
<p>All Rust’s machine numeric types implement <code>Display</code>, as do characters, strings, and slices. The smart pointer types <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, and <code>Arc&lt;T&gt;</code> implement <code>Display</code> if <code>T</code> itself does: their displayed form is simply that of their referent. Containers like <code>Vec</code> and <code>HashMap</code> do not implement <code>Display</code>, as there’s no single natural human-readable form for those types.</p></li>

<li><p>If a type implements <code>Display</code>, the standard library automatically implements the <code>std::str::ToString</code> trait for it, whose sole method <code>to_string</code> can be more convenient when you don’t need the flexibility of <code>format!</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// Continued from above.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">address</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"> </code><code class="s">"fe80::3ea9:f4ff:fe34:7a50"</code><code class="p">);</code><code class="w"/></pre>
<p>The <code>ToString</code> trait predates the introduction of <code>Display</code> and is less flexible. For your own types, you should generally implement <code>Display</code> instead of <code>ToString</code>.</p></li>
<li><p><a contenteditable="false" data-primary="Debug trait" data-type="indexterm" id="idm45251584856152"/>Every public type in the standard library implements <code>std::fmt::Debug</code>, which takes a value and formats it as a string in a way helpful to programmers. The easiest way to use <code>Debug</code> to produce a string is via the <code>format!</code> macro’s <code>{:?}</code> format specifier:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// Continued from above.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">addresses</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="n">address</code><code class="p">,</code><code class="w"/>
<code class="w">                     </code><code class="n">IpAddr</code>::<code class="n">from_str</code><code class="p">(</code><code class="s">"192.168.0.1"</code><code class="p">)</code><code class="o">?</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">addresses</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"[V6(fe80::3ea9:f4ff:fe34:7a50), V4(192.168.0.1)]"</code><code class="p">);</code><code class="w"/></pre>
<p>This takes advantage of a blanket implementation of <code>Debug</code> for <code>Vec&lt;T&gt;</code>, for any <code>T</code> that itself implements <code>Debug</code>. All of Rust’s collection types have such implementations.</p>
<p>You should implement <code>Debug</code> for your own types, too. Usually it’s best to let Rust derive an implementation, as we did for the <code>Complex</code> type in <a data-type="xref" href="ch12.xhtml#operator-overloading">Chapter 12</a>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[derive(Copy, Clone, Debug)]</code><code class="w"/>
<code class="k">struct</code> <code class="nc">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code>: <code class="kt">f64</code><code class="p">,</code><code class="w"> </code><code class="n">i</code>: <code class="kt">f64</code> <code class="p">}</code><code class="w"/></pre></li>
</ul>
<p>The <code>Display</code> and <code>Debug</code> formatting traits are just two among several that the <code>format!</code> macro and its relatives use to format values as text. We’ll cover the others, and explain how to implement them all, in <a data-type="xref" href="#formatting-values">“Formatting Values”</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Borrowing as Other Text-Like Types"><div class="sect2" id="borrowing-as-other-text-like-types">
<h2>Borrowing as Other Text-Like Types</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="borrowing slice's content" data-type="indexterm" id="idm45251584774472"/>You can borrow a slice’s contents in several different ways:</p>

<ul>
<li><p>Slices and <code>String</code>s implement <code>AsRef&lt;str&gt;</code>, <code>AsRef&lt;[u8]&gt;</code>, <code>AsRef&lt;Path&gt;</code>, and <code>AsRef&lt;OsStr&gt;</code>. Many standard library functions use these traits as bounds on their parameter types, so you can pass slices and strings to them directly, even when what they really want is some other type. See <a data-type="xref" href="ch13.xhtml#asref-and-asmut">“AsRef and AsMut”</a> for a more detailed explanation.</p></li>

<li><p>Slices and strings also implement the <code>std::borrow::Borrow&lt;str&gt;</code> trait. <code>HashMap</code> and <code>BTreeMap</code> use <code>Borrow</code> to make <code>String</code>s work nicely as keys in a table. See <a data-type="xref" href="ch13.xhtml#borrow-and-borrowmut">“Borrow and BorrowMut”</a> for details.</p></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Accessing Text as UTF-8"><div class="sect2" id="accessing-text-as-utf-8">
<h2>Accessing Text as UTF-8</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="accessing text as UTF-8" data-type="indexterm" id="idm45251584751592"/><a contenteditable="false" data-primary="text" data-secondary="accessing as UTF-8" data-type="indexterm" id="idm45251584750216"/><a contenteditable="false" data-primary="UTF-8" data-secondary="accessing text as" data-type="indexterm" id="idm45251584748840"/>There are two main ways to get at the bytes representing text, depending on whether you want to take ownership of the bytes or just borrow them:</p>

<ul>
<li><p><strong><code>slice.as_bytes()</code></strong> borrows <code>slice</code>’s bytes as a <code>&amp;[u8]</code>. Since this is not a mutable reference, <code>slice</code> can assume its bytes will remain well-formed UTF-8.</p></li>

<li><p><strong><code>string.into_bytes()</code></strong> takes ownership of <code>string</code> and returns a <code>Vec&lt;u8&gt;</code> of the string’s bytes by value. This is a cheap conversion, as it simply hands over the <code>Vec&lt;u8&gt;</code> that the string had been using as its buffer. Since <code>string</code> no longer exists, there’s no need for the bytes to continue to be well-formed UTF-8, and the caller is free to modify the <code>Vec&lt;u8&gt;</code> as it pleases.</p></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Producing Text from UTF-8 Data"><div class="sect2" id="producing-text-from-utf-8-data">
<h2>Producing Text from UTF-8 Data</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="producing text from UTF-8 data" data-type="indexterm" id="idm45251584678232"/><a contenteditable="false" data-primary="text" data-secondary="producing from UTF-8 data" data-type="indexterm" id="idm45251584676888"/><a contenteditable="false" data-primary="UTF-8" data-secondary="producing text from data" data-type="indexterm" id="idm45251584675544"/>If you have a block of bytes that you believe contains UTF-8 data, you have a few options for converting them into <code>String</code>s or slices, depending on how you want to handle errors:</p>

<ul>
<li><p><strong><code>str::from_utf8(byte_slice)</code></strong> takes a <code>&amp;[u8]</code> slice of bytes and returns a <code>Result</code>: either <code>Ok(&amp;str)</code> if <code>byte_slice</code> contains well-formed UTF-8, or an error otherwise.</p></li>

<li><p><strong><code>String::from_utf8(vec)</code></strong> tries to construct a string from a <code>Vec&lt;u8&gt;</code> passed by value. If <code>vec</code> holds well-formed UTF-8, <code>from_utf8</code> returns <code>Ok(string)</code>, where <code>string</code> has taken ownership of <code>vec</code> for use as its buffer. No heap allocation or copying of the text takes place.</p>
<p>If the bytes are not valid UTF-8, this returns <code>Err(e)</code>, where <code>e</code> is a <code>FromUtf8Error</code> error value. The call <code>e.into_bytes()</code> gives you back the original vector <code>vec</code>, so it is not lost when the conversion fails:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">good_utf8</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mh">0xe9</code><code class="p">,</code><code class="w"> </code><code class="mh">0x8c</code><code class="p">,</code><code class="w"> </code><code class="mh">0x86</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="nb">String</code>::<code class="n">from_utf8</code><code class="p">(</code><code class="n">good_utf8</code><code class="p">).</code><code class="n">ok</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"錆"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()));</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">bad_utf8</code>:  <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mh">0x9f</code><code class="p">,</code><code class="w"> </code><code class="mh">0xf0</code><code class="p">,</code><code class="w"> </code><code class="mh">0xa6</code><code class="p">,</code><code class="w"> </code><code class="mh">0x80</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code>::<code class="n">from_utf8</code><code class="p">(</code><code class="n">bad_utf8</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="c1">// Since String::from_utf8 failed, it didn't consume the original</code>
<code class="c1">// vector, and the error value hands it back to us unharmed.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">into_bytes</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mh">0x9f</code><code class="p">,</code><code class="w"> </code><code class="mh">0xf0</code><code class="p">,</code><code class="w"> </code><code class="mh">0xa6</code><code class="p">,</code><code class="w"> </code><code class="mh">0x80</code><code class="p">]);</code><code class="w"/></pre></li>

<li><p><strong><code>String::from_utf8_lossy(byte_slice)</code></strong> tries to construct a <code>String</code> or <code>&amp;str</code> from a <code>&amp;[u8]</code> shared slice of bytes. This conversion always succeeds, replacing any ill-formed UTF-8 with Unicode replacement characters. The return value is a <code>Cow&lt;str&gt;</code> that either borrows a <code>&amp;str</code> directly from <code>byte_slice</code> if it contains well-formed UTF-8, or owns a freshly allocated <code>String</code> with replacement characters substituted for the ill-formed bytes. Hence, when <code>byte_slice</code> is well-formed, no heap allocation or copying takes place. We discuss <code>Cow&lt;str&gt;</code> in more detail in <a data-type="xref" href="#putting-off-allocation">“Putting Off Allocation”</a>.</p></li>

<li><p>If you know for a fact that your <code>Vec&lt;u8&gt;</code> contains well-formed UTF-8, then you can call the unsafe function <strong><code>String::from_utf8_unchecked</code></strong>. This simply wraps the <code>Vec&lt;u8&gt;</code> up as a <code>String</code> and returns it, without examining the bytes at all. You are responsible for making sure you haven’t introduced ill-formed UTF-8 into the system, which is why this function is marked <code>unsafe</code>.</p></li>

<li><p>Similarly, <strong><code>str::from_utf8_unchecked</code></strong> takes a <code>&amp;[u8]</code> and returns it as a <code>&amp;str</code>, without checking to see if it holds well-formed UTF-8. As with <code>String::from​_utf8_unchecked</code>, you are responsible for making sure this is safe.</p></li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Putting Off Allocation"><div class="sect2" id="putting-off-allocation">
<h2>Putting Off Allocation</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="putting off allocation" data-type="indexterm" id="C17-text.html13"/>Suppose you want your program to greet the user. On Unix, you could write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">get_name</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">var</code><code class="p">(</code><code class="s">"USER"</code><code class="p">)</code><code class="w"> </code><code class="c1">// Windows uses "USERNAME"</code>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap_or</code><code class="p">(</code><code class="s">"whoever you are"</code><code class="p">.</code><code class="n">to_string</code><code class="p">())</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Greetings, {}!"</code><code class="p">,</code><code class="w"> </code><code class="n">get_name</code><code class="p">());</code><code class="w"/></pre>
<p>For Unix users, this greets them by username. For Windows users and the tragically unnamed, it provides alternative stock text.</p>
<p>The <code>std::env::var</code> function returns a <code>String</code>—and has good reasons to do so that we won’t go into here. But that means the alternative stock text must also be returned as a <code>String</code>. This is disappointing: when <code>get_name</code> returns a static string, no allocation should be necessary at all.</p>
<p>The nub of the problem is that sometimes the return value of <code>get_name</code> should be an owned <code>String</code>, sometimes it should be a <code>&amp;'static str</code>, and we can’t know which one it will be until we run the program. <a contenteditable="false" data-primary="Cow (clone on write) type" data-type="indexterm" id="C17-text.html14"/>This dynamic character is the hint to consider using <code>std::borrow::Cow</code>, the clone-on-write type that can hold either owned or borrowed data.</p>

<p>As explained in <a data-type="xref" href="ch13.xhtml#borrow-and-toowned-at-work-the-humble-cow">“Borrow and ToOwned at Work: The Humble Cow”</a>, <code>Cow&lt;'a, T&gt;</code> is an enum with two variants: <code>Owned</code> and <code>Borrowed</code>. <code>Borrowed</code> holds a reference <code>&amp;'a T</code>, and <code>Owned</code> holds the owning version of <code>&amp;T</code>: <code>String</code> for <code>&amp;str</code>, <code>Vec&lt;i32&gt;</code> for <code>&amp;[i32]</code>, and so on. Whether <code>Owned</code> or <code>Borrowed</code>, a <code>Cow&lt;'a, T&gt;</code> can always produce a <code>&amp;T</code> for you to use. In fact, <code>Cow&lt;'a, T&gt;</code> dereferences to <code>&amp;T</code>, behaving as a kind of smart pointer.</p>

<p>Changing <code>get_name</code> to return a <code>Cow</code> results in the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">borrow</code>::<code class="n">Cow</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">get_name</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Cow</code><code class="o">&lt;</code><code class="nb">'static</code><code class="p">,</code><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">var</code><code class="p">(</code><code class="s">"USER"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">v</code><code class="o">|</code><code class="w"> </code><code class="n">Cow</code>::<code class="n">Owned</code><code class="p">(</code><code class="n">v</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap_or</code><code class="p">(</code><code class="n">Cow</code>::<code class="n">Borrowed</code><code class="p">(</code><code class="s">"whoever you are"</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If this succeeds in reading the <code>"USER"</code> environment variable, the <code>map</code> returns the resulting <code>String</code> as a <code>Cow::Owned</code>. If it fails, the <code>unwrap_or</code> returns its static <code>&amp;str</code> as a <code>Cow::Borrowed</code>. The caller can remain unchanged:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Greetings, {}!"</code><code class="p">,</code><code class="w"> </code><code class="n">get_name</code><code class="p">());</code><code class="w"/></pre>
<p>As long as <code>T</code> implements the <code>std::fmt::Display</code> trait, displaying a <code>Cow&lt;'a, T&gt;</code> produces the same results as displaying a <code>T</code>.</p>
<p><code>Cow</code> is also useful when you may or may not need to modify some text you’ve borrowed. When no changes are necessary, you can continue to borrow it. But <code>Cow</code>s namesake clone-on-write behavior can give you an owned, mutable copy of the value on demand. <code>Cow</code>’s <code>to_mut</code> method makes sure the <code>Cow</code> is <code>Cow::Owned</code>, applying the value’s <code>ToOwned</code> implementation if necessary, and then returns a mutable reference to the value.</p>
<p>So if you find that some of your users, but not all, have titles by which they would prefer to be addressed, you can say:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">get_title</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_name</code><code class="p">();</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">title</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_title</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code><code class="p">.</code><code class="n">to_mut</code><code class="p">().</code><code class="n">push_str</code><code class="p">(</code><code class="s">", "</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">name</code><code class="p">.</code><code class="n">to_mut</code><code class="p">().</code><code class="n">push_str</code><code class="p">(</code><code class="n">title</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Greetings, {}!"</code><code class="p">,</code><code class="w"> </code><code class="n">name</code><code class="p">);</code><code class="w"/></pre>
<p>This might produce output like the following:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="gp">$</code> cargo run
<code class="go">Greetings, jimb, Esq.!</code>
<code class="gp">$</code></pre>
<p>What’s nice here is that, if <code>get_name()</code> returns a static string and <code>get_title</code> returns <code>None</code>, the <code>Cow</code> simply carries the static string all the way through to the <code>println!</code>. You’ve managed to put off allocation unless it’s really necessary, while still writing straightforward code.</p>
<p>Since <code>Cow</code> is frequently used for strings, the standard library has some special support for <code>Cow&lt;'a, str&gt;</code>. It provides <code>From</code> and <code>Into</code> conversions from both <code>String</code> and <code>&amp;str</code>, so you can write <code>get_name</code> more tersely:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">get_name</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Cow</code><code class="o">&lt;</code><code class="nb">'static</code><code class="p">,</code><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">var</code><code class="p">(</code><code class="s">"USER"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">v</code><code class="o">|</code><code class="w"> </code><code class="n">v</code><code class="p">.</code><code class="n">into</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap_or</code><code class="p">(</code><code class="s">"whoever you are"</code><code class="p">.</code><code class="n">into</code><code class="p">())</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><code>Cow&lt;'a, str&gt;</code> also implements <code>std::ops::Add</code> and <code>std::ops::AddAssign</code>, so to add the title to the name, you could write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">title</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_title</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="s">", "</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">name</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">title</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Or, since a <code>String</code> can be a <code>write!</code> macro’s destination:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Write</code><code class="p">;</code><code class="w"/>

<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">title</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_title</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">write</code><code class="o">!</code><code class="p">(</code><code class="n">name</code><code class="p">.</code><code class="n">to_mut</code><code class="p">(),</code><code class="w"> </code><code class="s">", {}"</code><code class="p">,</code><code class="w"> </code><code class="n">title</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>As before, no allocation occurs until you try to modify the <code>Cow</code>.</p>
<p>Keep in mind that not every <code>Cow&lt;..., str&gt;</code> must be <code>'static</code>: you can use <code>Cow</code> to borrow previously computed text until the moment a copy becomes necessary<a contenteditable="false" data-primary="" data-startref="C17-text.html14" data-type="indexterm" id="idm45251583976744"/>.<a contenteditable="false" data-primary="" data-startref="C17-text.html13" data-type="indexterm" id="idm45251583975352"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Strings as Generic Collections"><div class="sect2" id="strings-as-generic-collections">
<h2>Strings as Generic Collections</h2>

<p><a contenteditable="false" data-primary="collections" data-secondary="strings as generic collections" data-type="indexterm" id="idm45251583972840"/><a contenteditable="false" data-primary="generic collections, strings as" data-type="indexterm" id="idm45251583971096"/><a contenteditable="false" data-primary="String types" data-secondary="as generic collections" data-type="indexterm" id="idm45251583970024"/><code>String</code> implements both <code>std::default::Default</code> and <code>std::iter::Extend</code>: <code>default</code> returns an empty string, and <code>extend</code> can append characters, string slices, or strings to the end of a string. This is the same combination of traits implemented by Rust’s other collection types like <code>Vec</code> and <code>HashMap</code> for generic construction patterns such as <code>collect</code> and <code>partition</code>.</p>

<p>The <code>&amp;str</code> type also implements <code>Default</code>, returning an empty slice. This is handy in some corner cases; for example, it lets you derive <code>Default</code> for structures containing string slices.<a contenteditable="false" data-primary="" data-startref="C17-text.html9" data-type="indexterm" id="idm45251583962952"/><a contenteditable="false" data-primary="" data-startref="C17-text.html8" data-type="indexterm" id="idm45251583961576"/></p>
</div></section>
</div></section>

<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Formatting Values"><div class="sect1" id="formatting-values">
<h1>Formatting Values</h1>

<p><a contenteditable="false" data-primary="formatting values" data-secondary="strings and text" data-type="indexterm" id="C17-text.html15"/><a contenteditable="false" data-primary="strings and text" data-secondary="formatting values" data-type="indexterm" id="C17-text.html16"/>Throughout the book, we’ve been using text formatting macros like <code>println!</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:.3}µs: relocated {} at {:#x} to {:#x}, {} bytes"</code><code class="p">,</code><code class="w"/>
<code class="w">         </code><code class="mf">0.84391</code><code class="p">,</code><code class="w"> </code><code class="s">"object"</code><code class="p">,</code><code class="w"/>
<code class="w">         </code><code class="mi">140737488346304_</code><code class="k">usize</code><code class="p">,</code><code class="w"> </code><code class="mi">6299664_</code><code class="k">usize</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">);</code><code class="w"/></pre>
<p>That call produces the following output:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">0.844µs: relocated object at 0x7fffffffdcc0 to 0x602010, 64 bytes</code></pre>
<p>The string literal serves as a template for the output: each <code>{...}</code> in the template gets replaced by the formatted form of one of the following arguments. The template string must be a constant, so that Rust can check it against the types of the arguments at compile time. Each argument must be used; Rust reports a compile-time error otherwise.</p>
<p>Several standard library features share this little language for formatting strings:</p>

<ul>
<li><p>The <code>format!</code> macro uses it to build <code>String</code>s.</p></li>
<li><p>The <code>println!</code> and <code>print!</code> macros write formatted text to the standard output stream.</p></li>
<li><p>The <code>writeln!</code> and <code>write!</code> macros write it to a designated output stream.</p></li>
<li><p>The <code>panic!</code> macro uses it to build a (hopefully informative) expression of terminal dismay.</p></li>
</ul>

<p>Rust’s formatting facilities are designed to be open-ended. You can extend these macros to support your own types by implementing the <code>std::fmt</code> module’s formatting traits. And you can use the <code>format_args!</code> macro and the <code>std::fmt::Arguments</code> type to make your own functions and macros support the formatting language.</p>
<p>Formatting macros always borrow shared references to their arguments; they never take ownership of them or mutate them.</p>
<p><a contenteditable="false" data-primary="format parameters" data-type="indexterm" id="idm45251583887848"/>The template’s <code>{...}</code> forms are called <em>format parameters</em>, and have the form <code>{<i>which</i>:<i>how</i>}</code>. Both parts are optional; <code>{}</code> is frequently used.</p>

<p>The <em><code>which</code></em> value selects which argument following the template should take the parameter’s place. You can select arguments by index or by name. Parameters with no <em><code>which</code></em> value are simply paired with arguments from left to right.</p>

<p>The <em><code>how</code></em> value says how the argument should be formatted: how much padding, to which precision, in which numeric radix, and so on. If <em><code>how</code></em> is present, the colon before it is required.</p>

<p class="pagebreak-before">Here are some examples:</p>
<table>
<thead>
<tr class="header">
<th>Template string</th>
<th>Argument list</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"number of {}: {}"</code></td>
<td><code>"elephants", 19</code></td>
<td><code>"number of elephants: 19"</code></td>
</tr>
<tr class="even">
<td><code>"from {1} to {0}"</code></td>
<td><code>"the grave", "the cradle"</code></td>
<td><code>"from the cradle to the grave"</code></td>
</tr>
<tr class="odd">
<td><code>"v = {:?}"</code></td>
<td><code>vec![0,1,2,5,12,29]</code></td>
<td><code>"v = [0, 1, 2, 5, 12, 29]"</code></td>
</tr>
<tr class="even">
<td><code>"name = {:?}"</code></td>
<td><code>"Nemo"</code></td>
<td><code>"name = \"Nemo\""</code></td>
</tr>
<tr class="odd">
<td><code>"{:8.2} km/s"</code></td>
<td><code>11.186</code></td>
<td><code>"   11.19 km/s"</code></td>
</tr>
<tr class="even">
<td><code>"{:20} {:02x} {:02x}"</code></td>
<td><code>"adc #42", 105, 42</code></td>
<td><code>"adc #42              69 2a"</code></td>
</tr>
<tr class="odd">
<td><code>"{1:02x} {2:02x}  {0}"</code></td>
<td><code>"adc #42", 105, 42</code></td>
<td><code>"69 2a  adc #42"</code></td>
</tr>
<tr class="even">
<td><code>"{lsb:02x} {msb:02x}  {insn}"</code></td>
<td><code>insn="adc #42", lsb=105, msb=42</code></td>
<td><code>"69 2a  adc #42"</code></td>
</tr>
</tbody>
</table>
<p>If you want to include <code>'{'</code> or <code>'}'</code> characters in your output, double the characters in the template:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{{a, c}} ⊂ {{a, b, c}}"</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"{a, c} ⊂ {a, b, c}"</code><code class="p">);</code><code class="w"/></pre>

<section data-type="sect2" data-pdf-bookmark="Formatting Text Values"><div class="sect2" id="formatting-text-values">
<h2>Formatting Text Values</h2>

<p><a contenteditable="false" data-primary="formatting values" data-secondary="text values" data-type="indexterm" id="idm45251583808456"/><a contenteditable="false" data-primary="strings and text" data-secondary="formatting text values" data-type="indexterm" id="idm45251583800424"/><a contenteditable="false" data-primary="text values" data-type="indexterm" id="idm45251583799048"/>When formatting a textual type like <code>&amp;str</code> or <code>String</code> (<code>char</code> is treated like a single-character string), the <em><code>how</code></em> value of a parameter has several parts, all optional.</p>

<ul>
<li><p>A <em>text length limit</em>. Rust truncates your argument if it is longer than this. If you specify no limit, Rust uses the full text.</p></li>

<li><p>A <em>minimum field width</em>. After any truncation, if your argument is shorter than this, Rust pads it on the right (by default) with spaces (by default) to make a field of this width. If omitted, Rust doesn’t pad your argument.</p></li>

<li><p>An <em>alignment</em>. If your argument needs to be padded to meet the minimum field width, this says where your text should be placed within the field. <code>&lt;</code>, <code>^</code>, and <code>&gt;</code> put your text at the start, middle, and end, respectively.</p></li>

<li><p>A <em>padding</em> character to use in this padding process. If omitted, Rust uses spaces. If you specify the padding character, you must also specify the alignment.</p></li>
</ul>

<p>Here are some examples showing how to write things out, and their effects. All are using the same eight-character argument, <code>"bookends"</code>:</p>
<table>
<thead>
<tr class="header">
<th>Features in use</th>
<th>Template string</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Default</td>
<td><code>"{}"</code></td>
<td><code>"bookends"</code></td>
</tr>
<tr class="even">
<td>Minimum field width</td>
<td><code>"{:4}"</code></td>
<td><code>"bookends"</code></td>
</tr>
<tr class="odd">
<td/>
<td><code>"{:12}"</code></td>
<td><code>"bookends    "</code></td>
</tr>
<tr class="even">
<td>Text length limit</td>
<td><code>"{:.4}"</code></td>
<td><code>"book"</code></td>
</tr>
<tr class="odd">
<td/>
<td><code>"{:.12}"</code></td>
<td><code>"bookends"</code></td>
</tr>
<tr class="even">
<td>Field width, length limit</td>
<td><code>"{:12.20}"</code></td>
<td><code>"bookends    "</code></td>
</tr>
<tr class="odd">
<td/>
<td><code>"{:4.20}"</code></td>
<td><code>"bookends"</code></td>
</tr>
<tr class="even">
<td/>
<td><code>"{:4.6}"</code></td>
<td><code>"booken"</code></td>
</tr>
<tr class="odd">
<td/>
<td><code>"{:6.4}"</code></td>
<td><code>"book  "</code></td>
</tr>
<tr class="even">
<td>Aligned left, width</td>
<td><code>"{:&lt;12}"</code></td>
<td><code>"bookends    "</code></td>
</tr>
<tr class="odd">
<td>Centered, width</td>
<td><code>"{:^12}"</code></td>
<td><code>"  bookends  "</code></td>
</tr>
<tr class="even">
<td>Aligned right, width</td>
<td><code>"{:&gt;12}"</code></td>
<td><code>"    bookends"</code></td>
</tr>
<tr class="odd">
<td>Pad with <code>'='</code>, centered, width</td>
<td><code>"{:=^12}"</code></td>
<td><code>"==bookends=="</code></td>
</tr>
<tr class="even">
<td>Pad <code>'*'</code>, aligned right, width, limit</td>
<td><code>"{:*&gt;12.4}"</code></td>
<td><code>"********book"</code></td>
</tr>
</tbody>
</table>

<p>Rust’s formatter has a naïve understanding of width: it assumes each character occupies one column, with no regard for combining characters, half-width katakana, zero-width spaces, or the other messy realities of Unicode. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:4}"</code><code class="p">,</code><code class="w"> </code><code class="s">"th</code><code class="se">\u{e9}</code><code class="s">"</code><code class="p">),</code><code class="w">   </code><code class="s">"th</code><code class="se">\u{e9}</code><code class="s"> "</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:4}"</code><code class="p">,</code><code class="w"> </code><code class="s">"the</code><code class="se">\u{301}</code><code class="s">"</code><code class="p">),</code><code class="w"> </code><code class="s">"the</code><code class="se">\u{301}</code><code class="s">"</code><code class="p">);</code><code class="w"/></pre>
<p>Although Unicode says these strings are both equivalent to <code>"thé"</code>, Rust’s formatter doesn’t know that characters like <code>'\u{301}'</code>, COMBINING ACUTE ACCENT, need special treatment. It pads the first string correctly, but assumes the second is four columns wide and adds no padding. Although it’s easy to see how Rust could improve in this specific case, true multilingual text formatting for all of Unicode’s scripts is a monumental task, best handled by relying on your platform’s user interface toolkits, or perhaps by generating HTML and CSS and making a web browser sort it all out.</p>
<p>Along with <code>&amp;str</code> and <code>String</code>, you can also pass formatting macros smart pointer types with textual referents, like <code>Rc&lt;String&gt;</code> or <code>Cow&lt;'a, str&gt;</code>, without ceremony.</p>
<p>Since filename paths are not necessarily well-formed UTF-8, <code>std::path::Path</code> isn’t quite a textual type; you can’t pass a <code>std::path::Path</code> directly to a formatting macro. However, a <code>Path</code>’s <code>display</code> method returns a value you can format that sorts things out in a platform-appropriate way:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"processing file: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="n">display</code><code class="p">());</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Formatting Numbers"><div class="sect2" id="formatting-numbers">
<h2>Formatting Numbers</h2>

<p><a contenteditable="false" data-primary="formatting values" data-secondary="numbers" data-type="indexterm" id="C17-text.html17"/><a contenteditable="false" data-primary="numbers, formatting" data-type="indexterm" id="C17-text.html18"/><a contenteditable="false" data-primary="strings and text" data-secondary="formatting numbers" data-type="indexterm" id="C17-text.html19"/>When the formatting argument has a numeric type like <code>usize</code> or <code>f64</code>, the parameter’s <em><code>how</code></em> value has the following parts, all optional:</p>

<ul>
<li><p>A <em>padding</em> and <em>alignment</em>, which work as they do with textual types.</p></li>

<li><p>A <code>+</code> character, requesting that the number’s sign always be shown, even when the argument is positive.</p></li>

<li><p>A <code>#</code> character, requesting an explicit radix prefix like <code>0x</code> or <code>0b</code>. See the “notation” bullet point that concludes this list.</p></li>

<li><p>A <code>0</code> character, requesting that the minimum field width be satisfied by including leading zeros in the number, instead of the usual padding approach.</p></li>

<li><p>A <em>minimum field width</em>. If the formatted number is not at least this wide, Rust pads it on the left (by default) with spaces (by default) to make a field of the given width.</p></li>

<li><p>A <em>precision</em> for floating-point arguments, indicating how many digits Rust should include after the decimal point. Rust rounds or zero-extends as necessary to produce exactly this many fractional digits. If the precision is omitted, Rust tries to accurately represent the value using as few digits as possible. For arguments of integer type, the precision is ignored.</p></li>

<li><p>A <em>notation</em>. For integer types, this can be <code>b</code> for binary, <code>o</code> for octal, or <code>x</code> or <code>X</code> for hexadecimal with lower- or uppercase letters. If you included the <code>#</code> character, these include an explicit Rust-style radix prefix, <code>0b</code>, <code>0o</code>, <code>0x</code>, or <code>0X</code>. For floating-point types, a radix of <code>e</code> or <code>E</code> requests scientific notation, with a normalized coefficient, using <code>e</code> or <code>E</code> for the exponent. If you don’t specify any notation, Rust formats numbers in decimal.</p></li>
</ul>

<p>Some examples of formatting the <code>i32</code> value <code>1234</code>:</p>
<table>
<thead>
<tr class="header">
<th>Features in use</th>
<th>Template string</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Default</td>
<td><code>"{}"</code></td>
<td><code>"1234"</code></td>
</tr>
<tr class="even">
<td>Forced sign</td>
<td><code>"{:+}"</code></td>
<td><code>"+1234"</code></td>
</tr>
<tr class="odd">
<td>Minimum field width</td>
<td><code>"{:12}"</code></td>
<td><code>"        1234"</code></td>
</tr>
<tr class="even">
<td/>
<td><code>"{:2}"</code></td>
<td><code>"1234"</code></td>
</tr>
<tr class="odd">
<td>Sign, width</td>
<td><code>"{:+12}"</code></td>
<td><code>"       +1234"</code></td>
</tr>
<tr class="even">
<td>Leading zeros, width</td>
<td><code>"{:012}"</code></td>
<td><code>"000000001234"</code></td>
</tr>
<tr class="odd">
<td>Sign, zeros, width</td>
<td><code>"{:+012}"</code></td>
<td><code>"+00000001234"</code></td>
</tr>
<tr class="even">
<td>Aligned left, width</td>
<td><code>"{:&lt;12}"</code></td>
<td><code>"1234        "</code></td>
</tr>
<tr class="odd">
<td>Centered, width</td>
<td><code>"{:^12}"</code></td>
<td><code>"    1234    "</code></td>
</tr>
<tr class="even">
<td>Aligned right, width</td>
<td><code>"{:&gt;12}"</code></td>
<td><code>"        1234"</code></td>
</tr>
<tr class="odd">
<td>Aligned left, sign, width</td>
<td><code>"{:&lt;+12}"</code></td>
<td><code>"+1234       "</code></td>
</tr>
<tr class="even">
<td>Centered, sign, width</td>
<td><code>"{:^+12}"</code></td>
<td><code>"   +1234    "</code></td>
</tr>
<tr class="odd">
<td>Aligned right, sign, width</td>
<td><code>"{:&gt;+12}"</code></td>
<td><code>"       +1234"</code></td>
</tr>
<tr class="even">
<td>Padded with <code>'='</code>, centered, width</td>
<td><code>"{:=^12}"</code></td>
<td><code>"====1234===="</code></td>
</tr>
<tr class="odd">
<td>Binary notation</td>
<td><code>"{:b}"</code></td>
<td><code>"10011010010"</code></td>
</tr>
<tr class="even">
<td>Width, octal notation</td>
<td><code>"{:12o}"</code></td>
<td><code>"        2322"</code></td>
</tr>
<tr class="odd">
<td>Sign, width, hexadecimal notation</td>
<td><code>"{:+12x}"</code></td>
<td><code>"        +4d2"</code></td>
</tr>
<tr class="even">
<td>Sign, width, hex with capital digits</td>
<td><code>"{:+12X}"</code></td>
<td><code>"        +4D2"</code></td>
</tr>
<tr class="odd">
<td>Sign, explicit radix prefix, width, hex</td>
<td><code>"{:+#12x}"</code></td>
<td><code>"      +0x4d2"</code></td>
</tr>
<tr class="even">
<td>Sign, radix, zeros, width, hex</td>
<td><code>"{:+#012x}"</code></td>
<td><code>"+0x0000004d2"</code></td>
</tr>
<tr class="odd">
<td/>
<td><code>"{:+#06x}"</code></td>
<td><code>"+0x4d2"</code></td>
</tr>
</tbody>
</table>

<p>As the last two examples show, the minimum field width applies to the entire number, sign, radix prefix, and all.</p>
<p>Negative numbers always include their sign. The results are like those shown in the “forced sign” examples.</p>
<p>When you request leading zeros, alignment and padding characters are simply ignored, since the zeros expand the number to fill the entire field.</p>
<p>Using the argument <code>1234.5678</code>, we can show effects specific to floating-point types:<a contenteditable="false" data-primary="" data-startref="C17-text.html19" data-type="indexterm" id="idm45251583554184"/><a contenteditable="false" data-primary="" data-startref="C17-text.html18" data-type="indexterm" id="idm45251583552808"/><a contenteditable="false" data-primary="" data-startref="C17-text.html17" data-type="indexterm" id="idm45251583551432"/></p>

<table>
<thead>
<tr class="header">
<th>Features in use</th>
<th>Template string</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Default</td>
<td><code>"{}"</code></td>
<td><code>"1234.5678"</code></td>
</tr>
<tr class="even">
<td>Precision</td>
<td><code>"{:.2}"</code></td>
<td><code>"1234.57"</code></td>
</tr>
<tr class="odd">
<td/>
<td><code>"{:.6}"</code></td>
<td><code>"1234.567800"</code></td>
</tr>
<tr class="even">
<td>Minimum field width</td>
<td><code>"{:12}"</code></td>
<td><code>"   1234.5678"</code></td>
</tr>
<tr class="odd">
<td>Minimum, precision</td>
<td><code>"{:12.2}"</code></td>
<td><code>"     1234.57"</code></td>
</tr>
<tr class="even">
<td/>
<td><code>"{:12.6}"</code></td>
<td><code>" 1234.567800"</code></td>
</tr>
<tr class="odd">
<td>Leading zeros, minimum, precision</td>
<td><code>"{:012.6}"</code></td>
<td><code>"01234.567800"</code></td>
</tr>
<tr class="even">
<td>Scientific</td>
<td><code>"{:e}"</code></td>
<td><code>"1.2345678e3"</code></td>
</tr>
<tr class="odd">
<td>Scientific, precision</td>
<td><code>"{:.3e}"</code></td>
<td><code>"1.235e3"</code></td>
</tr>
<tr class="even">
<td>Scientific, minimum, precision</td>
<td><code>"{:12.3e}"</code></td>
<td><code>"     1.235e3"</code></td>
</tr>
<tr class="odd">
<td/>
<td><code>"{:12.3E}"</code></td>
<td><code>"     1.235E3"</code></td>
</tr>
</tbody>
</table>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Formatting Other Types"><div class="sect2" id="formatting-other-types">
<h2>Formatting Other Types</h2>

<p><a contenteditable="false" data-primary="formatting values" data-secondary="various standard library types" data-type="indexterm" id="idm45251583519992"/>Beyond strings and numbers, you can format several other standard library types:</p>

<ul>
<li><p>Error types can all be formatted directly, making it easy to include them in error messages. Every error type should implement the <code>std::error::Error</code> trait, which extends the default formatting trait <code>std::fmt::Display</code>. As a consequence, any type that implements <code>Error</code> is ready to format.</p></li>

<li><p>You can format internet protocol address types like <code>std::net::IpAddr</code> and <code>std::net::SocketAddr</code>.</p></li>

<li><p>The Boolean <code>true</code> and <code>false</code> values can be formatted, although these are usually not the best strings to present directly to end users.</p></li>
</ul>

<p>You should use the same sorts of format parameters that you would for strings. Length limit, field width, and alignment controls work as expected.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Formatting Values for Debugging"><div class="sect2" id="formatting-values-for-debugging">
<h2>Formatting Values for Debugging</h2>

<p><a contenteditable="false" data-primary="debugging" data-secondary="formatting values for" data-type="indexterm" id="idm45251583510312"/><a contenteditable="false" data-primary="formatting values" data-secondary="for debugging" data-type="indexterm" id="idm45251583508936"/><a contenteditable="false" data-primary="logging" data-secondary="formatting values for" data-type="indexterm" id="idm45251583507560"/>To help with debugging and logging, the <code>{:?}</code> parameter formats any public type in the Rust standard library in a way meant to be helpful to programmers. You can use this to inspect vectors, slices, tuples, hash tables, threads, and hundreds of other types.</p>
<p>For example, you can write the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">HashMap</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">map</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashMap</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">map</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Portland"</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="mf">45.5237606</code><code class="p">,</code><code class="o">-</code><code class="mf">122.6819273</code><code class="p">));</code><code class="w"/>
<code class="n">map</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Taipei"</code><code class="p">,</code><code class="w">   </code><code class="p">(</code><code class="mf">25.0375167</code><code class="p">,</code><code class="w"> </code><code class="mf">121.5637</code><code class="p">));</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">map</code><code class="p">);</code><code class="w"/></pre>
<p>This prints:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">{"Taipei": (25.0375167, 121.5637), "Portland": (45.5237606, -122.6819273)}</code></pre>
<p>The <code>HashMap</code> and <code>(f64, f64)</code> types already know how to format themselves, with no effort required on your part.</p>

<p>If you include the <code>#</code> character in the format parameter, Rust will pretty-print the value. Changing this code to say <code>println!("{:#?}", map)</code> leads to this output:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">{</code>
<code class="go">    "Taipei": (</code>
<code class="go">        25.0375167,</code>
<code class="go">        121.5637</code>
<code class="go">    ),</code>
<code class="go">    "Portland": (</code>
<code class="go">        45.5237606,</code>
<code class="go">        -122.6819273</code>
<code class="go">    )</code>
<code class="go">}</code></pre>
<p>These exact forms aren’t guaranteed, and do sometimes change from one Rust release to the next.</p>
<p>As we’ve mentioned, you can use the <code>#[derive(Debug)]</code> syntax to make your own types work with <code>{:?}</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[derive(Copy, Clone, Debug)]</code><code class="w"/>
<code class="k">struct</code> <code class="nc">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code>: <code class="kt">f64</code><code class="p">,</code><code class="w"> </code><code class="n">i</code>: <code class="kt">f64</code> <code class="p">}</code><code class="w"/></pre>
<p>With this definition in place, we can use a <code>{:?}</code> format to print <code>Complex</code> values:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">third</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code>: <code class="o">-</code><code class="mf">0.5</code><code class="p">,</code><code class="w"> </code><code class="n">i</code>: <code class="kt">f64</code>::<code class="n">sqrt</code><code class="p">(</code><code class="mf">0.75</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">third</code><code class="p">);</code><code class="w"/></pre>
<p>This prints:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">Complex { r: -0.5, i: 0.8660254037844386 }</code></pre>
<p>This is fine for debugging, but it might be nice if <code>{}</code> could print them in a more traditional form, like <code>-0.5 + 0.8660254037844386i</code>. In <a data-type="xref" href="#formatting-your-own-types">“Formatting Your Own Types”</a>, we’ll show how to do exactly that.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Formatting Pointers for Debugging"><div class="sect2" id="formatting-pointers-for-debugging">
<h2>Formatting Pointers for Debugging</h2>

<p><a contenteditable="false" data-primary="debugging" data-secondary="formatting pointers for" data-type="indexterm" id="idm45251583284056"/><a contenteditable="false" data-primary="formatting values" data-secondary="pointers for debugging" data-type="indexterm" id="idm45251583282680"/><a contenteditable="false" data-primary="logging" data-secondary="formatting pointers for" data-type="indexterm" id="idm45251583256472"/>Normally, if you pass any sort of pointer to a formatting macro—a reference, a <code>Box</code>, an <code>Rc</code>—the macro simply follows the pointer and formats its referent; the pointer itself is not of interest. But when you’re debugging, it’s sometimes helpful to see the pointer: an address can serve as a rough “name” for an individual value, which can be illuminating when examining structures with cycles or sharing.</p>
<p>The <code>{:p}</code> notation formats references, boxes, and other pointer-like types as addresses:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">rc</code>::<code class="n">Rc</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">original</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="s">"mazurka"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">cloned</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="n">clone</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">impostor</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="s">"mazurka"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"text:     {}, {}, {}"</code><code class="p">,</code><code class="w">       </code><code class="n">original</code><code class="p">,</code><code class="w"> </code><code class="n">cloned</code><code class="p">,</code><code class="w"> </code><code class="n">impostor</code><code class="p">);</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"pointers: {:p}, {:p}, {:p}"</code><code class="p">,</code><code class="w"> </code><code class="n">original</code><code class="p">,</code><code class="w"> </code><code class="n">cloned</code><code class="p">,</code><code class="w"> </code><code class="n">impostor</code><code class="p">);</code><code class="w"/></pre>
<p>This code prints:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">text:     mazurka, mazurka, mazurka</code>
<code class="go">pointers: 0x7f99af80e000, 0x7f99af80e000, 0x7f99af80e030</code></pre>
<p>Of course, the specific pointer values will vary from run to run, but even so, comparing the addresses makes it clear that the first two are references to the same <code>String</code>, whereas the third points to a distinct value.</p>
<p>Addresses do tend to look like hexadecimal soup, so more refined visualizations can be worthwhile, but the <code>{:p}</code> style can still be an effective quick-and-dirty solution.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Referring to Arguments by Index or Name"><div class="sect2" id="referring-to-arguments-by-index-or-name">
<h2>Referring to Arguments by Index or Name</h2>

<p><a contenteditable="false" data-primary="arguments" data-secondary="referring to by index or name" data-type="indexterm" id="idm45251583137080"/><a contenteditable="false" data-primary="formatting values" data-secondary="referring to arguments by index or name" data-type="indexterm" id="idm45251583135736"/>A format parameter can explicitly select which argument it uses. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{1},{0},{2}"</code><code class="p">,</code><code class="w"> </code><code class="s">"zeroth"</code><code class="p">,</code><code class="w"> </code><code class="s">"first"</code><code class="p">,</code><code class="w"> </code><code class="s">"second"</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"first,zeroth,second"</code><code class="p">);</code><code class="w"/></pre>
<p>You can include format parameters after a colon:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{2:#06x},{1:b},{0:=&gt;10}"</code><code class="p">,</code><code class="w"> </code><code class="s">"first"</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"0x0064,1010,=====first"</code><code class="p">);</code><code class="w"/></pre>
<p>You can also select arguments by name. This makes complex templates with many parameters much more legible. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{description:.&lt;25}{quantity:2} @ {price:5.2}"</code><code class="p">,</code><code class="w"/>
<code class="w">                   </code><code class="n">price</code><code class="o">=</code><code class="mf">3.25</code><code class="p">,</code><code class="w"/>
<code class="w">                   </code><code class="n">quantity</code><code class="o">=</code><code class="mi">3</code><code class="p">,</code><code class="w"/>
<code class="w">                   </code><code class="n">description</code><code class="o">=</code><code class="s">"Maple Turmeric Latte"</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"Maple Turmeric Latte..... 3 @  3.25"</code><code class="p">);</code><code class="w"/></pre>
<p>(The named arguments here resemble keyword arguments in Python, but this is just a special feature of the formatting macros, not part of Rust’s function call syntax.)</p>
<p>You can mix indexed, named, and positional (that is, no index or name) parameters together in a single formatting macro use. The positional parameters are paired with arguments from left to right as if the indexed and named parameters weren’t there:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{mode} {2} {} {}"</code><code class="p">,</code><code class="w"/>
<code class="w">                   </code><code class="s">"people"</code><code class="p">,</code><code class="w"> </code><code class="s">"eater"</code><code class="p">,</code><code class="w"> </code><code class="s">"purple"</code><code class="p">,</code><code class="w"> </code><code class="n">mode</code><code class="o">=</code><code class="s">"flying"</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"flying purple people eater"</code><code class="p">);</code><code class="w"/></pre>
<p>Named arguments must appear at the end of the list.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Dynamic Widths and Precisions"><div class="sect2" id="dynamic-widths-and-precisions">
<h2>Dynamic Widths and Precisions</h2>

<p><a contenteditable="false" data-primary="formatting values" data-secondary="dynamic widths and precisions" data-type="indexterm" id="idm45251582964008"/><a contenteditable="false" data-primary="parameters" data-secondary="dynamic widths and precisions" data-type="indexterm" id="idm45251582962616"/>A parameter’s minimum field width, text length limit, and numeric precision need not always be fixed values; you can choose them at runtime.</p>
<p>We’ve been looking at cases like this expression, which gives you the string <code>content</code> right-justified in a field 20 characters wide:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:&gt;20}"</code><code class="p">,</code><code class="w"> </code><code class="n">content</code><code class="p">)</code><code class="w"/></pre>
<p>But if you’d like to choose the field width at runtime, you can write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:&gt;1$}"</code><code class="p">,</code><code class="w"> </code><code class="n">content</code><code class="p">,</code><code class="w"> </code><code class="n">get_width</code><code class="p">())</code><code class="w"/></pre>
<p>Writing <code>1$</code> for the minimum field width tells <code>format!</code> to use the value of the second argument as the width. The cited argument must be a <code>usize</code>. You can also refer to the argument by name:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:&gt;width$}"</code><code class="p">,</code><code class="w"> </code><code class="n">content</code><code class="p">,</code><code class="w"> </code><code class="n">width</code><code class="o">=</code><code class="n">get_width</code><code class="p">())</code><code class="w"/></pre>
<p>The same approach works for the text length limit as well:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:&gt;width$.limit$}"</code><code class="p">,</code><code class="w"> </code><code class="n">content</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">width</code><code class="o">=</code><code class="n">get_width</code><code class="p">(),</code><code class="w"> </code><code class="n">limit</code><code class="o">=</code><code class="n">get_limit</code><code class="p">())</code><code class="w"/></pre>
<p>In place of the text length limit or floating-point precision, you can also write <code>*</code>, which says to take the next positional argument as the precision. The following clips <code>content</code> to at most <code>get_limit()</code> characters:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:.*}"</code><code class="p">,</code><code class="w"> </code><code class="n">get_limit</code><code class="p">(),</code><code class="w"> </code><code class="n">content</code><code class="p">)</code><code class="w"/></pre>
<p>The argument taken as the precision must be a <code>usize</code>. There is no corresponding syntax for the field width.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Formatting Your Own Types"><div class="sect2" id="formatting-your-own-types">
<h2>Formatting Your Own Types</h2>

<p><a contenteditable="false" data-primary="formatting values" data-secondary="implementing traits for" data-type="indexterm" id="C17-text.html20"/>The formatting macros use a set of traits defined in the <code>std::fmt</code> module to convert values to text. You can make Rust’s formatting macros format your own types by implementing one or more of these traits yourself.</p>
<p>The notation of a format parameter indicates which trait its argument’s type must implement:</p>

<table>
<thead>
<tr class="header">
<th>Notation</th>
<th>Example</th>
<th>Trait</th>
<th>purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>none</td>
<td><code>{}</code></td>
<td><code>std::fmt::Display</code></td>
<td>Text, numbers, errors: the catch-all trait</td>
</tr>
<tr class="even">
<td><code>b</code></td>
<td><code>{bits:#b}</code></td>
<td><code>std::fmt::Binary</code></td>
<td>Numbers in binary</td>
</tr>
<tr class="odd">
<td><code>o</code></td>
<td><code>{:#5o}</code></td>
<td><code>std::fmt::Octal</code></td>
<td>Numbers in octal</td>
</tr>
<tr class="even">
<td><code>x</code></td>
<td><code>{:4x}</code></td>
<td><code>std::fmt::LowerHex</code></td>
<td>Numbers in hexadecimal, lower-case digits</td>
</tr>
<tr class="odd">
<td><code>X</code></td>
<td><code>{:016X}</code></td>
<td><code>std::fmt::UpperHex</code></td>
<td>Numbers in hexadecimal, upper-case digits</td>
</tr>
<tr class="even">
<td><code>e</code></td>
<td><code>{:.3e}</code></td>
<td><code>std::fmt::LowerExp</code></td>
<td>Floating-point numbers in scientific notation</td>
</tr>
<tr class="odd">
<td><code>E</code></td>
<td><code>{:.3E}</code></td>
<td><code>std::fmt::UpperExp</code></td>
<td>Same, upper-case <code>E</code></td>
</tr>
<tr class="even">
<td><code>?</code></td>
<td><code>{:#?}</code></td>
<td><code>std::fmt::Debug</code></td>
<td>Debugging view, for developers</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td><code>{:p}</code></td>
<td><code>std::fmt::Pointer</code></td>
<td>Pointer as address, for developers</td>
</tr>
</tbody>
</table>

<p>When you put the <code>#[derive(Debug)]</code> attribute on a type definition so that you can use the <code>{:?}</code> format parameter, you are simply asking Rust to implement the <code>std::fmt::Debug</code> trait for you.</p>
<p>The formatting traits all have the same structure, differing only in their names. We’ll use <code>std::fmt::Display</code> as a representative:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">Display</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">dest</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Formatter</code><code class="p">)</code><code class="w"/>
<code class="w">        </code>-&gt; <code class="nc">std</code>::<code class="n">fmt</code>::<code class="nb">Result</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="fmt method" data-type="indexterm" id="idm45251582665816"/>The <code>fmt</code> method’s job is to produce a properly formatted representation of <code>self</code> and write its characters to <code>dest</code>. In addition to serving as an output stream, the <code>dest</code> argument also carries details parsed from the format parameter, like the alignment and minimum field width.</p>
<p>For example, earlier in this chapter we suggested that it would be nice if <code>Complex</code> values printed themselves in the usual <code>a + bi</code> form. Here’s a <code>Display</code> implementation that does that:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">dest</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Formatter</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">fmt</code>::<code class="nb">Result</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">i_sign</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">0.0</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="sc">'-'</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="sc">'+'</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">        </code><code class="n">write</code><code class="o">!</code><code class="p">(</code><code class="n">dest</code><code class="p">,</code><code class="w"> </code><code class="s">"{} {} {}i"</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="n">i_sign</code><code class="p">,</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">abs</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">i</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This takes advantage of the fact that <code>Formatter</code> is itself an output stream, so the <code>write!</code> macro can do most of the work for us. With this implementation in place, we can write the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">one_twenty</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code>: <code class="o">-</code><code class="mf">0.5</code><code class="p">,</code><code class="w"> </code><code class="n">i</code>: <code class="mf">0.866</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">one_twenty</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"-0.5 + 0.866i"</code><code class="p">);</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">two_forty</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code>: <code class="o">-</code><code class="mf">0.5</code><code class="p">,</code><code class="w"> </code><code class="n">i</code>: <code class="o">-</code><code class="mf">0.866</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">two_forty</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"-0.5 - 0.866i"</code><code class="p">);</code><code class="w"/></pre>
<p>It’s sometimes helpful to display complex numbers in polar form: if you imagine a line drawn on the complex plane from the origin to the number, the polar form gives the line’s length, and its clockwise angle to the positive x-axis. The <code>#</code> character in a format parameter typically selects some alternate display form; the <code>Display</code> implementation could treat it as a request to use polar form:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">dest</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Formatter</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">fmt</code>::<code class="nb">Result</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">dest</code><code class="p">.</code><code class="n">alternate</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">abs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">sqrt</code><code class="p">(</code><code class="n">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">angle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">atan2</code><code class="p">(</code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">std</code>::<code class="kt">f64</code>::<code class="n">consts</code>::<code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">180.0</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">write</code><code class="o">!</code><code class="p">(</code><code class="n">dest</code><code class="p">,</code><code class="w"> </code><code class="s">"{} ∠ {}°"</code><code class="p">,</code><code class="w"> </code><code class="n">abs</code><code class="p">,</code><code class="w"> </code><code class="n">angle</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">i_sign</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">0.0</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="sc">'-'</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="sc">'+'</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">            </code><code class="n">write</code><code class="o">!</code><code class="p">(</code><code class="n">dest</code><code class="p">,</code><code class="w"> </code><code class="s">"{} {} {}i"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="n">i_sign</code><code class="p">,</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">abs</code><code class="p">(</code><code class="n">i</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Using this implementation:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">ninety</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code>: <code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="n">i</code>: <code class="mf">2.0</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">ninety</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"0 + 2i"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{:#}"</code><code class="p">,</code><code class="w"> </code><code class="n">ninety</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"2 ∠ 90°"</code><code class="p">);</code><code class="w"/></pre>
<p>Although the formatting traits’ <code>fmt</code> methods return a <code>fmt::Result</code> value (a typical module-specific <code>Result</code> type), you should propagate failures only from operations on the <code>Formatter</code>, as the <code>fmt::Display</code> implementation does with its calls to <code>write!</code>; your formatting functions must never originate errors themselves. This allows macros like <code>format!</code> to simply return a <code>String</code> instead of a <code>Result&lt;String, ...&gt;</code>, since appending the formatted text to a <code>String</code> never fails. It also ensures that any errors you do get from <code>write!</code> or <code>writeln!</code> reflect real problems from the underlying I/O stream, not formatting issues.</p>
<p><code>Formatter</code> has plenty of other helpful methods, including some for handling structured data like maps, lists, and so on, which we won’t cover here; consult the online documentation for the full details.<a contenteditable="false" data-primary="" data-startref="C17-text.html20" data-type="indexterm" id="idm45251582060696"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Using the Formatting Language in Your Own Code"><div class="sect2" id="using-the-formatting-language-in-your-own-code">
<h2>Using the Formatting Language in Your Own Code</h2>

<p><a contenteditable="false" data-primary="Arguments type" data-type="indexterm" id="idm45251582057480"/><a contenteditable="false" data-primary="format_args! macro" data-type="indexterm" id="idm45251582056376"/><a contenteditable="false" data-primary="formatting values" data-secondary="using formatting language in your own code" data-type="indexterm" id="idm45251582055272"/>You can write your own functions and macros that accept format templates and arguments by using Rust’s <code>format_args!</code> macro and the <code>std::fmt::Arguments</code> type. For example, suppose your program needs to log status messages as it runs, and you’d like to use Rust’s text formatting language to produce them. The following would be a start:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">logging_enabled</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">OpenOptions</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Write</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">write_log_entry</code><code class="p">(</code><code class="n">entry</code>: <code class="nc">std</code>::<code class="n">fmt</code>::<code class="n">Arguments</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">logging_enabled</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Keep things simple for now, and just</code>
<code class="w">        </code><code class="c1">// open the file every time.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">log_file</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">OpenOptions</code>::<code class="n">new</code><code class="p">()</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">append</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">create</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">open</code><code class="p">(</code><code class="s">"log-file-name"</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"failed to open log file"</code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="n">log_file</code><code class="p">.</code><code class="n">write_fmt</code><code class="p">(</code><code class="n">entry</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"failed to write to log"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You can call <code>write_log_entry</code> like so:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">write_log_entry</code><code class="p">(</code><code class="n">format_args</code><code class="o">!</code><code class="p">(</code><code class="s">"Hark! {:?}</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">mysterious_value</code><code class="p">));</code><code class="w"/></pre>
<p>At compile time, the <code>format_args!</code> macro parses the template string and checks it against the arguments’ types, reporting an error if there are any problems. At runtime, it evaluates the arguments and builds an <code>Arguments</code> value carrying all the information necessary to format the text: a pre-parsed form of the template, along with shared references to the argument values.</p>
<p>Constructing an <code>Arguments</code> value is cheap: it’s just gathering up some pointers. No formatting work takes place yet, only the collection of the information needed to do so later. This can be important: if logging is not enabled, any time spent converting numbers to decimal, padding values, and so on would be wasted.</p>
<p>The <code>File</code> type implements the <code>std::io::Write</code> trait, whose <code>write_fmt</code> method takes an <code>Argument</code> and does the formatting. It writes the results to the underlying stream.</p>
<p>That call to <code>write_log_entry</code> isn’t pretty. This is where a macro can help:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">macro_rules</code><code class="o">!</code><code class="w"> </code><code class="n">log</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="c1">// no ! needed after name in macro definitions</code>
<code class="w">    </code><code class="p">(</code><code class="cp">$format</code>:<code class="nc">tt</code><code class="p">,</code><code class="w"> </code><code class="cp">$($arg</code>:<code class="nc">expr</code><code class="p">),</code><code class="o">*</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">        </code><code class="n">write_log_entry</code><code class="p">(</code><code class="n">format_args</code><code class="o">!</code><code class="p">(</code><code class="cp">$format</code><code class="p">,</code><code class="w"> </code><code class="cp">$($arg</code><code class="p">),</code><code class="o">*</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>We cover macros in detail in <a data-type="xref" href="ch20.xhtml#macros">Chapter 20</a>. For now, take it on faith that this defines a new <code>log!</code> macro that passes its arguments along to <code>format_args!</code>, and then calls your <code>write_log_entry</code> function on the resulting <code>Arguments</code> value. The formatting macros like <code>println!</code>, <code>writeln!</code>, and <code>format!</code> are all roughly the same idea.</p>
<p>You can use <code>log!</code> like so:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">log</code><code class="o">!</code><code class="p">(</code><code class="s">"O day and night, but this is wondrous strange! {:?}</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"/>
<code class="w">     </code><code class="n">mysterious_value</code><code class="p">);</code><code class="w"/></pre>
<p>Hopefully, this looks a little better.<a contenteditable="false" data-primary="" data-startref="C17-text.html16" data-type="indexterm" id="idm45251581770728"/><a contenteditable="false" data-primary="" data-startref="C17-text.html15" data-type="indexterm" id="idm45251581769624"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Regular Expressions"><div class="sect1" id="regular-expressions">
<h1>Regular Expressions</h1>

<p><a contenteditable="false" data-primary="regular expressions (regex)" data-type="indexterm" id="C17-text.html21"/><a contenteditable="false" data-primary="strings and text" data-secondary="regular expressions" data-type="indexterm" id="C17-text.html22"/>The external <code>regex</code> crate is Rust’s official regular expression library. It provides the usual searching and matching functions. It has good support for Unicode, but it can search byte strings as well. Although it doesn’t support some features you’ll often find in other regular expression packages, like backreferences and look-around patterns, those simplifications allow <code>regex</code> to ensure that searches take time linear in the size of the expression and in the length of the text being searched. These guarantees, among others, make <code>regex</code> safe to use even with untrusted expressions searching untrusted text.</p>

<p>In this book, we’ll provide only an overview of <code>regex</code>; you should consult its online documentation for details.</p>

<p>Although the <code>regex</code> crate is not in <code>std</code>, it is maintained by the Rust library team, the same group responsible for <code>std</code>. To use <code>regex</code>, put the following line in the <code>[dependencies]</code> section of your crate’s <em>Cargo.toml</em> file:</p>
<pre data-type="programlisting">regex = "0.2.2"</pre>
<p>Then place an <code>extern crate</code> item in your crate’s root:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">regex</code><code class="p">;</code><code class="w"/></pre>

<p>In the following sections, we’ll assume that you have these changes in place.</p>
<section data-type="sect2" data-pdf-bookmark="Basic Regex Use"><div class="sect2" id="basic-regex-use">

<h2>Basic Regex Use</h2>
<p><a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="basic use" data-type="indexterm" id="idm45251581739608"/>A <code>Regex</code> value represents a parsed regular expression, ready to use. The <code>Regex::new</code> constructor tries to parse a <code>&amp;str</code> as a regular expression, and returns a <code>Result</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">regex</code>::<code class="n">Regex</code><code class="p">;</code><code class="w"/>

<code class="c1">// A semver version number, like 0.2.1.</code>
<code class="c1">// May contain a pre-release version suffix, like 0.2.1-alpha.</code>
<code class="c1">// (No build metadata suffix, for brevity.)</code>
<code class="c1">//</code>
<code class="c1">// Note use of r"..." raw string syntax, to avoid backslash blizzard.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">semver</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Regex</code>::<code class="n">new</code><code class="p">(</code><code class="s">r"(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?"</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>

<code class="c1">// Simple search, with a Boolean result.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">haystack</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">r#"regex = "0.2.5""#</code><code class="p">;</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">semver</code><code class="p">.</code><code class="n">is_match</code><code class="p">(</code><code class="n">haystack</code><code class="p">));</code><code class="w"/></pre>
<p>The <code>Regex::captures</code> method searches a string for the first match, and returns a <code>regex::Captures</code> value holding match information for each group in the expression:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// You can retrieve capture groups:</code>
<code class="kd">let</code><code class="w"> </code><code class="n">captures</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">semver</code><code class="p">.</code><code class="n">captures</code><code class="p">(</code><code class="n">haystack</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">ok_or</code><code class="p">(</code><code class="s">"semver regex should have matched"</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">captures</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code><code class="w"> </code><code class="s">"0.2.5"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">captures</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code><code class="w"> </code><code class="s">"0"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">captures</code><code class="p">[</code><code class="mi">2</code><code class="p">],</code><code class="w"> </code><code class="s">"2"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">captures</code><code class="p">[</code><code class="mi">3</code><code class="p">],</code><code class="w"> </code><code class="s">"5"</code><code class="p">);</code><code class="w"/></pre>
<p>Indexing a <code>Captures</code> value panics if the requested group didn’t match. To test whether a particular group matched, you can call <code>Captures::get</code>, which returns an <code>Option&lt;regex::Match&gt;</code>. A <code>Match</code> value records a single group’s match:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">captures</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">4</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">captures</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="n">unwrap</code><code class="p">().</code><code class="n">start</code><code class="p">(),</code><code class="w"> </code><code class="mi">13</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">captures</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="n">unwrap</code><code class="p">().</code><code class="n">end</code><code class="p">(),</code><code class="w"> </code><code class="mi">14</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">captures</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="n">unwrap</code><code class="p">().</code><code class="n">as_str</code><code class="p">(),</code><code class="w"> </code><code class="s">"5"</code><code class="p">);</code><code class="w"/></pre>
<p>You can iterate over all the matches in a string:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">haystack</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"In the beginning, there was 1.0.0. \</code>
<code class="s">                For a while, we used 1.0.1-beta, \</code>
<code class="s">                but in the end, we settled on 1.2.4."</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">matches</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">semver</code><code class="p">.</code><code class="n">find_iter</code><code class="p">(</code><code class="n">haystack</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">match_</code><code class="o">|</code><code class="w"> </code><code class="n">match_</code><code class="p">.</code><code class="n">as_str</code><code class="p">())</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">matches</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"1.0.0"</code><code class="p">,</code><code class="w"> </code><code class="s">"1.0.1-beta"</code><code class="p">,</code><code class="w"> </code><code class="s">"1.2.4"</code><code class="p">]);</code><code class="w"/></pre>
<p>The <code>find_iter</code> iterator produces a <code>Match</code> value for each nonoverlapping match of the expression, working from the start of the string to the end. The <code>captures_iter</code> method is similar, but produces <code>Captures</code> values recording all capture groups. Searching is slower when capture groups must be reported, so if you don’t need them, it’s best to use one of the methods that doesn’t return them.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Building Regex Values Lazily"><div class="sect2" id="building-regex-values-lazily">
<h2>Building Regex Values Lazily</h2>

<p><a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="building regex values lazily" data-type="indexterm" id="idm45251581345416"/>The <code>Regex::new</code> constructor can be expensive: constructing a <code>Regex</code> for a 1200-character regular expression can take almost a millisecond on a fast developer machine, and even a trivial expression takes microseconds. It’s best to keep <code>Regex</code> construction out of heavy computational loops; instead, you should construct your <code>Regex</code> once, and then reuse the same one.</p>

<p><a contenteditable="false" data-primary="lazy_static crate" data-type="indexterm" id="idm45251581341736"/>The <code>lazy_static</code> crate provides a nice way to construct static values lazily the first time they are used. To start with, note the dependency in your <em>Cargo.toml</em> file:</p>
<pre data-type="programlisting">[dependencies]
lazy_static = "0.2.8"</pre>
<p>This crate provides a macro to declare such variables:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="cp">#[macro_use]</code><code class="w"/>
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">lazy_static</code><code class="p">;</code><code class="w"/>

<code class="n">lazy_static</code><code class="o">!</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">static</code><code class="w"> </code><code class="k">ref</code><code class="w"> </code><code class="n">SEMVER</code>: <code class="nc">Regex</code><code class="w"/>
<code class="w">        </code><code class="o">=</code><code class="w"> </code><code class="n">Regex</code>::<code class="n">new</code><code class="p">(</code><code class="s">r"(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?"</code><code class="p">)</code><code class="w"/>
<code class="w">              </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error parsing regex"</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="SEMVER variable" data-type="indexterm" id="idm45251581244680"/>The macro expands to a declaration of a static variable named <code>SEMVER</code>, but its type is not exactly <code>Regex</code>. Instead, it’s a macro-generated type that implements <code>Deref&lt;Target=Regex&gt;</code> and therefore exposes all the same methods as a <code>Regex</code>. The first time <code>SEMVER</code> is dereferenced, the initializer is evaluated, and the value saved for later use. Since <code>SEMVER</code> is a static variable, not just a local variable, the initializer runs at most once per program execution.</p>
<p>With this declaration in place, using <code>SEMVER</code> is straightforward:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">BufRead</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">stdin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">stdin</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">stdin</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">lines</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">match_</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">SEMVER</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="o">&amp;</code><code class="n">line</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">match_</code><code class="p">.</code><code class="n">as_str</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You can put the <code>lazy_static!</code> declaration in a module, or even inside the function that uses the <code>Regex</code>, if that’s the most appropriate scope. The regular expression is still always compiled only once per program execution.<a contenteditable="false" data-primary="" data-startref="C17-text.html22" data-type="indexterm" id="idm45251581293992"/><a contenteditable="false" data-primary="" data-startref="C17-text.html21" data-type="indexterm" id="idm45251581157064"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Normalization"><div class="sect1" id="normalization">
<h1>Normalization</h1>

<p><a contenteditable="false" data-primary="normalization" data-secondary="strings and text" data-type="indexterm" id="C17-text.html23"/><a contenteditable="false" data-primary="strings and text" data-secondary="normalization" data-type="indexterm" id="C17-text.html24"/>Most users would consider the French word for tea, <em>thé</em>, to be three characters long. However, Unicode actually has two ways to represent this text:</p>
<ul>
<li><p>In the <em>composed</em> form, <em>thé</em> comprises the three characters <code>'t'</code>, <code>'h'</code>, and <code>'é'</code>, where <code>'é'</code> is a single Unicode character with code point <code>0xe9</code>.</p></li>
<li><p>In the <em>decomposed</em> form, <em>thé</em> comprises the four characters <code>'t'</code>, <code>'h'</code>, <code>'e'</code>, and <code>'\u{301}'</code>, where the <code>'e'</code> is the plain ASCII character, without an accent, and code point <code>0x301</code> is the “COMBINING ACUTE ACCENT” character, which adds an acute accent to whatever character it follows.</p></li>
</ul>
<p>Unicode does not consider either the composed or the decomposed form of <em>é</em> to be the “correct” one; rather, it considers them both equivalent representations of the same abstract character. Unicode says both forms should be displayed in the same way, and text input methods are permitted to produce either, so users will generally not know which form they are viewing or typing. (Rust lets you use Unicode characters directly in string literals, so you can simply write <code>"thé"</code> if you don’t care which encoding you get. Here we’ll use the <code>\u</code> escapes for clarity.)</p>

<p>However, considered as Rust <code>&amp;str</code> or <code>String</code> values, <code>"th\u{e9}"</code> and <code>"the\u{301}"</code> are completely distinct. They have different lengths, compare as unequal, have different hash values, and order themselves differently with respect to other strings:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="s">"th</code><code class="se">\u{e9}</code><code class="s">"</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="s">"the</code><code class="se">\u{301}</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="s">"th</code><code class="se">\u{e9}</code><code class="s">"</code><code class="w"> </code><code class="o">&gt;</code><code class="w">  </code><code class="s">"the</code><code class="se">\u{301}</code><code class="s">"</code><code class="p">);</code><code class="w"/>

<code class="c1">// A Hasher is designed to accumulate the hash of a series of values,</code>
<code class="c1">// so hashing just one is a bit clunky.</code>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">hash</code>::<code class="p">{</code><code class="n">Hash</code><code class="p">,</code><code class="w"> </code><code class="n">Hasher</code><code class="p">};</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">hash_map</code>::<code class="n">DefaultHasher</code><code class="p">;</code><code class="w"/>
<code class="k">fn</code> <code class="nf">hash</code><code class="o">&lt;</code><code class="n">T</code>: <code class="o">?</code><code class="nb">Sized</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">Hash</code><code class="o">&gt;</code><code class="p">(</code><code class="n">t</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DefaultHasher</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">t</code><code class="p">.</code><code class="n">hash</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">s</code><code class="p">.</code><code class="n">finish</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// These values may change in future Rust releases.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">hash</code><code class="p">(</code><code class="s">"th</code><code class="se">\u{e9}</code><code class="s">"</code><code class="p">),</code><code class="w">   </code><code class="mh">0x53e2d0734eb1dff3</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">hash</code><code class="p">(</code><code class="s">"the</code><code class="se">\u{301}</code><code class="s">"</code><code class="p">),</code><code class="w"> </code><code class="mh">0x90d837f0a0928144</code><code class="p">);</code><code class="w"/></pre>
<p>Clearly, if you intend to compare user-supplied text, or use it as a key in a hash table or B-tree, you will need to put each string in some canonical form first.</p>
<p>Fortunately, Unicode specifies <em>normalized</em> forms for strings. Whenever two strings should be treated as equivalent according to Unicode’s rules, their normalized forms are character-for-character identical. When encoded with UTF-8, they are byte-for-byte identical. This means you can compare normalized strings with <code>==</code>, use them as keys in a <code>HashMap</code> or <code>HashSet</code>, and so on, and you’ll get Unicode’s notion of equality.</p>

<p>Failure to normalize can even have security consequences. For example, if your website normalizes usernames in some cases but not others, you could end up with two distinct users named <code>bananasflambé</code>, which some parts of your code treat as the same user, but others distinguish, resulting in one’s privileges being extended incorrectly to the other. Of course, there are many ways to avoid this sort of problem, but history shows there are also many ways not to.</p>

<section data-type="sect2" data-pdf-bookmark="Normalization Forms"><div class="sect2" id="normalization-forms">
<h2>Normalization Forms</h2>

<p><a contenteditable="false" data-primary="normalization" data-secondary="forms" data-type="indexterm" id="idm45251580968920"/><a contenteditable="false" data-primary="Unicode" data-secondary="normalized forms" data-type="indexterm" id="idm45251580967544"/>Unicode defines four normalized forms, each of which is appropriate for different uses. There are two questions to answer:</p>
<ul>
<li><p>First, do you prefer characters to be as <em>composed</em> as possible or as <em>decomposed</em> as possible?</p>
<p>For example, the most composed representation of the Vietnamese word <em>Phở</em> is the three-character string <code>"Ph\u{1edf}"</code>, where both the tonal mark ̉ and the vowel mark ̛ are applied to the base character “o” in a single Unicode character, <code>'\u{1edf}'</code>, which Unicode dutifully names LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE.</p>
<p>The most decomposed representation splits out the base letter and its two marks into three separate Unicode characters: <code>'o'</code>, <code>'\u{31b}'</code> (COMBINING HORN), and <code>'\u{309}'</code> (COMBINING HOOK ABOVE), resulting in <code>"Pho\u{31b}\u{309}"</code>. (Whenever combining marks appear as separate characters, rather than as part of a composed character, all normalized forms specify a fixed order in which they must appear, so normalization is well specified even when characters have multiple accents.)</p>
<p>The composed form generally has fewer compatibility problems, since it more closely matches the representations most languages used for their text before Unicode became established. It may also work better with naïve string formatting features like Rust’s <code>format!</code> macro. The decomposed form, on the other hand, may be better for displaying text or searching, since it makes the detailed structure of the text more explicit.</p></li>
<li><p>The second question is: if two character sequences represent the same fundamental text, but differ in the way that text should be formatted, do you want to treat them as equivalent, or keep them distinct?</p>
<p>Unicode has separate characters for the ordinary digit <code>'5'</code>, the superscript digit <code>'⁵'</code> (or <code>'\u{2075}'</code>), and the circled digit <code>'⑤'</code> (or <code>'\u{2464}'</code>), but declares all three to be <em>compatibility equivalent</em>. Similarly, Unicode has a single character for the ligature <em>ffi</em> (<code>'\u{fb03}'</code>), but declares this to be compatibility equivalent to the three-character sequence <code>"ffi"</code>.</p>
<p>Compatibility equivalence makes sense for searches: a search for <code>"difficult"</code>, using only ASCII characters, ought to match the string <code>"di\u{fb03}cult"</code>, which uses the <em>ffi</em> ligature. Applying compatibility decomposition to the latter string would replace the ligature with the three plain letters <code>"ffi"</code>, making the search easier. But normalizing text to a compatibility equivalent form can lose essential information, so it should not be applied carelessly. For example, it would be incorrect in most contexts to store <code>"2⁵"</code> as <code>"25"</code>.</p></li>
</ul>
<p>The Unicode Normalization Form C and Normalization Form D (NFC and NFD) use the maximally composed and maximally decomposed forms of each character, but do not try to unify compatibility equivalent sequences. The NFKC and NFKD normalization forms are like NFC and NFD, but normalize all compatibility equivalent sequences to some simple representative of their class.</p>
<p>The World Wide Web Consortium’s “Character Model For the World Wide Web” recommends using NFC for all content. The Unicode Identifier and Pattern Syntax annex suggests using NFKC for identifiers in programming languages, and offers principles for adapting the form when necessary.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="The unicode-normalization Crate"><div class="sect2" id="the-unicode-normalization-crate">
<h2>The unicode-normalization Crate</h2>

<p><a contenteditable="false" data-primary="normalization" data-secondary="unicode-normalization crate" data-type="indexterm" id="idm45251580946296"/><a contenteditable="false" data-primary="Unicode" data-secondary="unicode-normalization crate" data-type="indexterm" id="idm45251580944664"/><a contenteditable="false" data-primary="unicode-normalization crate" data-type="indexterm" id="idm45251580943272"/>Rust’s <code>unicode-normalization</code> crate provides a trait that adds methods to <code>&amp;str</code> to put the text in any of the four normalized forms. To use it, add the following line to the <code>[dependencies]</code> section of your <em>Cargo.toml</em> file:</p>
<pre data-type="programlisting">unicode-normalization = "0.1.5"</pre>
<p>The top file of your crate needs an <code>extern crate</code> declaration:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">unicode_normalization</code><code class="p">;</code><code class="w"/></pre>
<p>With these declarations in place, a <code>&amp;str</code> has four new methods that return iterators over a particular normalized form of the string:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">unicode_normalization</code>::<code class="n">UnicodeNormalization</code><code class="p">;</code><code class="w"/>

<code class="c1">// No matter what representation the lefthand string uses</code>
<code class="c1">// (you shouldn't be able to tell just by looking),</code>
<code class="c1">// these assertions will hold.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"Phở"</code><code class="p">.</code><code class="n">nfd</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="s">"Pho</code><code class="se">\u{31b}\u{309}</code><code class="s">"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"Phở"</code><code class="p">.</code><code class="n">nfc</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="s">"Ph</code><code class="se">\u{1edf}</code><code class="s">"</code><code class="p">);</code><code class="w"/>

<code class="c1">// The lefthand side here uses the "ffi" ligature character.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"① Di</code><code class="se">\u{fb03}</code><code class="s">culty"</code><code class="p">.</code><code class="n">nfkc</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="s">"1 Difficulty"</code><code class="p">);</code><code class="w"/></pre>
<p>Taking a normalized string and normalizing it again in the same form is guaranteed to return identical text.</p>
<p>Although any substring of a normalized string is itself normalized, the concatenation of two normalized strings is not necessarily normalized: for example, the second string might start with combining characters that should be placed before combining characters at the end of the first string.</p>
<p>As long as a text uses no unassigned code points when it is normalized, Unicode promises that its normalized form will not change in future versions of the standard. This means that normalized forms are generally safe to use in persistent storage, even as the Unicode standard evolves<a contenteditable="false" data-primary="" data-startref="C17-text.html24" data-type="indexterm" id="idm45251580780952"/><a contenteditable="false" data-primary="" data-startref="C17-text.html23" data-type="indexterm" id="idm45251580779672"/>.<a contenteditable="false" data-primary="" data-startref="C17-text.html0" data-type="indexterm" id="idm45251580778168"/></p>
</div></section>
</div></section>
</div></section></div></body>
</html>