<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 15. Iterators"><div class="chapter" id="iterators">
<h1><span class="label">Chapter 15. </span>Iterators</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>
It was the end of a very long day.
</p>
<p data-type="attribution">
Phil
</p>
</blockquote>

<p><a contenteditable="false" data-primary="iterators" data-type="indexterm" id="C15-iterators.html0"/>An <em>iterator</em> is a value that produces a sequence of values, typically for a loop to operate on. Rust’s standard library provides iterators that traverse vectors, strings, hash tables, and other collections, but also iterators to produce lines of text from an input stream, connections arriving at a network server, values received from other threads over a communications channel, and so on. And of course, you can implement iterators for your own purposes. Rust’s <code>for</code> loop provides a natural syntax for using iterators, but iterators themselves also provide a rich set of methods for mapping, filtering, joining, collecting, and so on.</p>
<p>Rust’s iterators are flexible, expressive, and efficient. Consider the following function, which returns the sum of the first <code>n</code> positive integers (often called the <em><code>n</code>th triangle number</em>):</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">triangle</code><code class="p">(</code><code class="n">n</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">1</code><code class="p">..</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">sum</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">sum</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The expression <code>1..n+1</code> is a <code>Range&lt;i32&gt;</code> value. A <code>Range&lt;i32&gt;</code> is an iterator that produces the integers from its start value (inclusive) to its end value (exclusive), so you can use it as the operand of the <code>for</code> loop to sum the values from <code>1</code> to <code>n</code>.</p>

<p class="pagebreak-before">But iterators also have a <code>fold</code> method, which you can use in the equivalent definition:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">triangle</code><code class="p">(</code><code class="n">n</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">).</code><code class="n">fold</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">sum</code><code class="p">,</code><code class="w"> </code><code class="n">item</code><code class="o">|</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">item</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Starting with <code>0</code> as the running total, <code>fold</code> takes each value that <code>1..n+1</code> produces and applies the closure <code>|sum, item| sum + item</code> to the running total and the value. The closure’s return value is taken as the new running total. The last value it returns is what <code>fold</code> itself returns—in this case, the total of the entire sequence. This may look strange if you’re used to <code>for</code> and <code>while</code> loops, but once you’ve gotten used to it, <code>fold</code> is a legible and concise alternative.</p>

<p>This is pretty standard fare for functional programming languages, which put a premium on expressiveness. But Rust’s iterators were carefully designed to ensure that the compiler can translate them into excellent machine code as well. In a release build of the second definition shown before, Rust knows the definition of <code>fold</code>, and inlines it into <code>triangle</code>. Next, the closure <code>|sum, item| sum + item</code> is inlined into that. Finally, Rust examines the combined code and recognizes that there’s a simpler way to sum the numbers from one to <code>n</code>: the sum is always equal to <code>n * (n+1) / 2</code>. Rust translates the entire body of <code>triangle</code>, loop, closure, and all, into a single multiplication instruction and a few other bits of arithmetic.</p>

<p>This example happens to involve simple arithmetic, but iterators also perform well when put to heavier use. They’re another example of Rust providing flexible abstractions that impose little or no overhead in typical use.</p>
<p>The rest of this chapter falls into five parts:</p>

<ul>
<li><p>First we’ll explain the <code>Iterator</code> and <code>IntoIterator</code> traits, which are the foundation of Rust’s iterators.</p></li>
<li><p>Then we’ll go over the three stages of a typical iterator pipeline: creating an iterator from some sort of value source; adapting one sort of iterator into another by selecting or processing values as they go by; and then consuming the values the iterator produces.</p></li>
<li><p>Finally, we’ll show how to implement iterators for your own types.</p></li>
</ul>

<p>There are a lot of methods, so it’s fine to skim a section once you’ve got the general idea. But iterators are very common in idiomatic Rust, and being familiar with the tools that come with them is essential to mastering the language.</p>

<section data-type="sect1" data-pdf-bookmark="The Iterator and IntoIterator Traits"><div class="sect1" id="the-iterator-and-intoiterator-traits">
<h1>The Iterator and IntoIterator Traits</h1>

<p><a contenteditable="false" data-primary="IntoIterator trait" data-type="indexterm" id="C15-iterators.html1"/><a contenteditable="false" data-primary="iterators" data-secondary="traits" data-type="indexterm" id="C15-iterators.html2"/><a contenteditable="false" data-primary="traits" data-secondary="Iterator/IntoIterator" data-type="indexterm" id="C15-iterators.html3"/>An iterator is any value that implements the <code>std::iter::Iterator</code> trait:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Iterator</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Item</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">next</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"> </code><code class="c1">// many default methods</code>
<code class="p">}</code><code class="w"/></pre>
<p><code>Item</code> is the type of value the iterator produces. The <code>next</code> method either returns <code>Some(v)</code>, where <code>v</code> is the iterator’s next value, or returns <code>None</code> to indicate the end of the sequence. Here we’ve omitted <code>Iterator</code>’s many default methods; we’ll cover them individually throughout the rest of this chapter.</p>
<p>If there’s a natural way to iterate over some type, it can implement <code>std::iter::IntoIterator</code>, whose <code>into_iter</code> method takes a value and returns an iterator over it:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">IntoIterator</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>::<code class="n">IntoIter</code>::<code class="n">Item</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Self</code>::<code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Item</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">IntoIter</code>: <code class="nb">Iterator</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">into_iter</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">IntoIter</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><code>IntoIter</code> is the type of the iterator value itself, and <code>Item</code> is the type of value it produces. <a contenteditable="false" data-primary="iterable type" data-type="indexterm" id="idm45251601958472"/>We call any type that implements <code>IntoIterator</code> an <em>iterable</em>, because it’s something you could iterate over if you asked.</p>
<p>Rust’s <code>for</code> loop brings all these parts together nicely. To iterate over a vector’s elements, you can write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"There's:"</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"antimony"</code><code class="p">,</code><code class="w"> </code><code class="s">"arsenic"</code><code class="p">,</code><code class="w"> </code><code class="s">"aluminum"</code><code class="p">,</code><code class="w"> </code><code class="s">"selenium"</code><code class="p">];</code><code class="w"/>

<code class="k">for</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">element</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Under the hood, every <code>for</code> loop is just shorthand for calls to <code>IntoIterator</code> and <code>Iterator</code> methods:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="o">&amp;</code><code class="n">v</code><code class="p">).</code><code class="n">into_iter</code><code class="p">();</code><code class="w"/>
<code class="k">while</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">element</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">element</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>for</code> loop uses <code>IntoIterator::into_iter</code> to convert its operand <code>&amp;v</code> into an iterator, and then calls <code>Iterator::next</code> repeatedly. Each time that returns <code>Some(element)</code>, the <code>for</code> loop executes its body; and if it returns <code>None</code>, the loop finishes.</p>
<p>Although a <code>for</code> loop always calls <code>into_iter</code> on its operand, you can also pass iterators to <code>for</code> loops directly; this occurs when you loop over a <code>Range</code>, for example. All iterators automatically implement <code>IntoIterator</code>, with an <code>into_iter</code> method that simply returns the iterator.</p>
<p>If you call an iterator’s <code>next</code> method again after it has returned <code>None</code>, the <code>Iterator</code> trait doesn’t specify what it should do. Most iterators will just return <code>None</code> again, but not all. (If this causes problems, the <code>fuse</code> adaptor covered in <a data-type="xref" href="#fuse">“fuse”</a> can help.)</p>
<p>Here’s some terminology for iterators:</p>

<ul>
<li><p>As we’ve said, an <em>iterator</em> is any type that implements <code>Iterator</code>.</p></li>
<li><p>An <em>iterable</em> is any type that implements <code>IntoIterator</code>: you can get an iterator over it by calling its <code>into_iter</code> method. The vector reference <code>&amp;v</code> is the iterable in this case.</p></li>
<li><p>An iterator <em>produces</em> values.</p></li>
<li><p>The values an iterator produces are <em>items</em>. Here, the items are <code>"antimony"</code>, <code>"arsenic"</code>, and so on.</p></li>
<li><p>The code that receives the items an iterator produces is the <em>consumer</em>. In this example, the <code>for</code> loop consumes the iterator’s items.<a contenteditable="false" data-primary="" data-startref="C15-iterators.html3" data-type="indexterm" id="idm45251601777592"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html2" data-type="indexterm" id="idm45251601776216"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html1" data-type="indexterm" id="idm45251601774840"/></p></li>
</ul>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Creating Iterators"><div class="sect1" id="creating-iterators">
<h1>Creating Iterators</h1>

<p><a contenteditable="false" data-primary="iterators" data-secondary="creating" data-type="indexterm" id="C15-iterators.html4"/>The Rust standard library documentation explains in detail what sort of iterators each type provides, but the library follows some general conventions to help you get oriented and find what you need.</p>
<section data-type="sect2" data-pdf-bookmark="iter and iter_mut Methods"><div class="sect2" id="iter-and-iter_mut-methods">

<h2>iter and iter_mut Methods</h2>
<p><a contenteditable="false" data-primary="iter method" data-type="indexterm" id="idm45251601767976"/><a contenteditable="false" data-primary="iter_mut method" data-type="indexterm" id="idm45251601766712"/><a contenteditable="false" data-primary="iterators" data-secondary="iter and iter_mut methods" data-type="indexterm" id="idm45251601765608"/>Most collection types provide <code>iter</code> and <code>iter_mut</code> methods that return the natural iterators over the type, producing a shared or mutable reference to each item. Slices like <code>&amp;[T]</code> and <code>&amp;str</code> have <code>iter</code> and <code>iter_mut</code> methods too. These methods are the most common way to get an iterator, if you’re not going to let a <code>for</code> loop take care of it for you:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">12</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">v</code><code class="p">.</code><code class="n">iter</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">4</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">20</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">12</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">8</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">6</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>This iterator’s item type is <code>&amp;i32</code>: each call to <code>next</code> produces a reference to the next element, until we reach the end of the vector.</p>
<p>Each type is free to implement <code>iter</code> and <code>iter_mut</code> in whatever way makes the most sense for its purpose. The <code>iter</code> method on <code>std::path::Path</code> returns an iterator that produces one path component at a time:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">OsStr</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">path</code>::<code class="n">Path</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Path</code>::<code class="n">new</code><code class="p">(</code><code class="s">"C:/Users/JimB/Downloads/Fedora.iso"</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="n">iter</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">OsStr</code>::<code class="n">new</code><code class="p">(</code><code class="s">"C:"</code><code class="p">)));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">OsStr</code>::<code class="n">new</code><code class="p">(</code><code class="s">"Users"</code><code class="p">)));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">OsStr</code>::<code class="n">new</code><code class="p">(</code><code class="s">"JimB"</code><code class="p">)));</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre>
<p>This iterator’s item type is <code>&amp;std::ffi::OsStr</code>, a borrowed slice of a string of the sort accepted by operating system calls.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="IntoIterator Implementations"><div class="sect2" id="intoiterator-implementations">
<h2>IntoIterator Implementations</h2>

<p><a contenteditable="false" data-primary="IntoIterator trait" data-secondary="implementations" data-type="indexterm" id="C15-iterators.html5"/><a contenteditable="false" data-primary="iterators" data-secondary="IntoIterator implementations" data-type="indexterm" id="C15-iterators.html6"/><a contenteditable="false" data-primary="types" data-secondary="IntoIterator implementations" data-type="indexterm" id="C15-iterators.html7"/>When a type implements <code>IntoIterator</code>, you can call its <code>into_iter</code> method yourself, just as a <code>for</code> loop would:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="c1">// You should usually use HashSet, but its iteration order is</code>
<code class="c1">// nondeterministic, so BTreeSet works better in examples.</code>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">BTreeSet</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">favorites</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BTreeSet</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">favorites</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Lucy in the Sky With Diamonds"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="n">favorites</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Liebesträume No. 3"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">it</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">favorites</code><code class="p">.</code><code class="n">into_iter</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"Liebesträume No. 3"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"Lucy in the Sky With Diamonds"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>Most collections actually provide several implementations of <code>IntoIterator</code>, for shared references, mutable references, and moves:</p>

<ul>
<li><p><a contenteditable="false" data-primary="shared references" data-secondary="IntoIterator implementation" data-type="indexterm" id="idm45251601357720"/>Given a <em>shared reference</em> to the collection, <code>into_iter</code> returns an iterator that produces shared references to its items. For example, in the preceding code, <code>(&amp;favorites).into_iter()</code> would return an iterator whose <code>Item</code> type is <code>&amp;String</code>.</p></li>
<li><p><a contenteditable="false" data-primary="mutable references (&amp;mutT)" data-secondary="IntoIterator implementation" data-type="indexterm" id="idm45251601353480"/>Given a <em>mutable reference</em> to the collection, <code>into_iter</code> returns an iterator that produces mutable references to the items. For example, if <code>vector</code> is some <code>Vec&lt;String&gt;</code>, the call <code>(&amp;mut vector).into_iter()</code> returns an iterator whose <code>Item</code> type is <code>&amp;mut String</code>.</p></li>
<li><p><a contenteditable="false" data-primary="passing by value/by reference" data-type="indexterm" id="idm45251601348408"/>When passed the collection <em>by value</em>, <code>into_iter</code> returns an iterator that takes ownership of the collection and returns items by value; the items’ ownership moves from the collection to the consumer, and the original collection is consumed in the process. For example, the call <code>favorites.into_iter()</code> in the preceding code returns an iterator that produces each string by value; the consumer receives ownership of each string. When the iterator is dropped, any elements remaining in the <code>BTreeSet</code> are dropped too, and the set’s now-empty husk is disposed of.</p></li>
</ul>

<p>Since a <code>for</code> loop applies <code>IntoIterator::into_iter</code> to its operand, these three implementations are what create the following idioms for iterating over shared or mutable references to a collection, or consuming the collection and taking ownership of its elements:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">for</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">collection</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>Each of these simply results in a call to one of the <code>IntoIterator</code> implementations listed here.</p>
<p>Not every type provides all three implementations. For example, <code>HashSet</code>, <code>BTreeSet</code> and <code>BinaryHeap</code> don’t implement <code>IntoIterator</code> on mutable references, since modifying their elements would probably violate the type’s invariants: the modified value might have a different hash value, or be ordered differently with respect to its neighbors, so modifying it would leave it incorrectly placed. Other types do support mutation, but only partially. For example, <code>HashMap</code> and <code>BTreeMap</code> produce mutable reference to their entries’ values, but only shared references to their keys, for similar reasons to those given earlier.</p>

<p>The general principle is that iteration should be efficient and predictable, so rather than providing implementations that are expensive or could exhibit surprising behavior (for example, rehashing modified <code>HashSet</code> entries, and potentially revisiting them later in the iteration), Rust omits them entirely.</p>

<p><a contenteditable="false" data-primary="slices" data-secondary="IntoIterator implementation" data-type="indexterm" id="idm45251601209832"/>Slices implement two of the three <code>IntoIterator</code> variants; since they don’t own their elements, there is no “by value” case. Instead, <code>into_iter</code> for <code>&amp;[T]</code> and <code>&amp;mut [T]</code> returns an iterator that produces shared and mutable references to the elements. If you imagine the underlying slice type <code>[T]</code> as a collection of some sort, this fits neatly into the overall pattern.</p>
<p>You may have noticed that the first two <code>IntoIterator</code> variants, for shared and mutable references, are equivalent to calling <code>iter</code> or <code>iter_mut</code> on the referent. Why does Rust provide both?</p>
<p><code>IntoIterator</code> is what makes <code>for</code> loops work, so that’s obviously necessary. But when you’re not using a <code>for</code> loop, <code>favorites.iter()</code> is clearer than <code>(&amp;favorites).into_iter()</code>. Iteration by shared reference is something you’ll need frequently, so <code>iter</code> and <code>iter_mut</code> are still valuable for their ergonomics.</p>
<p><a contenteditable="false" data-primary="generic code" data-secondary="IntoIterator and" data-type="indexterm" id="idm45251601306824"/><code>IntoIterator</code> can also be useful in generic code: you can use a bound like <code>T: IntoIterator</code> to restrict the type variable <code>T</code> to types that can be iterated over. Or, you can write <code>T: IntoIterator&lt;Item=U&gt;</code> to further require the iteration to produce a particular type <code>U</code>. For example, this function dumps values from any iterable whose items are printable with the <code>"{:?}"</code> format:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Debug</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">dump</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">U</code><code class="o">&gt;</code><code class="p">(</code><code class="n">t</code>: <code class="nc">T</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nb">IntoIterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">U</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="n">U</code>: <code class="nc">Debug</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">u</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">u</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You can’t write this generic function using <code>iter</code> and <code>iter_mut</code>, since they’re not methods of any trait: most iterable types just happen to have methods by those names.<a contenteditable="false" data-primary="" data-startref="C15-iterators.html7" data-type="indexterm" id="idm45251601137640"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html6" data-type="indexterm" id="idm45251601136328"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html5" data-type="indexterm" id="idm45251601134952"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="drain Methods"><div class="sect2" id="drain-methods">
<h2>drain Methods</h2>

<p><a contenteditable="false" data-primary="drain method" data-type="indexterm" id="idm45251601131896"/><a contenteditable="false" data-primary="iterators" data-secondary="drain methods" data-type="indexterm" id="idm45251601130792"/>Many collection types provide a <code>drain</code> method that takes a mutable reference to the collection and returns an iterator that passes ownership of each element to the consumer. However, unlike the <code>into_iter()</code> method, which takes the collection by value and consumes it, <code>drain</code> merely borrows a mutable reference to the collection, and when the iterator is dropped, it removes any remaining elements from the collection, and leaves it empty.</p>
<p>On types that can be indexed by a range, like <code>String</code>s, vectors, and <code>VecDeque</code>s, the <code>drain</code> method takes a range of elements to remove, rather than draining the entire sequence:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">iter</code>::<code class="n">FromIterator</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">outer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Earth"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">inner</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code>::<code class="n">from_iter</code><code class="p">(</code><code class="n">outer</code><code class="p">.</code><code class="n">drain</code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="mi">4</code><code class="p">));</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">outer</code><code class="p">,</code><code class="w"> </code><code class="s">"Eh"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">inner</code><code class="p">,</code><code class="w"> </code><code class="s">"art"</code><code class="p">);</code><code class="w"/></pre>
<p>If you do need to drain the entire sequence, use the full range, <code>..</code>, as the argument.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Other Iterator Sources"><div class="sect2" id="other-iterator-sources">
<h2>Other Iterator Sources</h2>

<p><a contenteditable="false" data-primary="iterators" data-secondary="in standard library" data-type="indexterm" id="idm45251601055624"/>The previous sections are mostly concerned with collection types like vectors and <code>HashMap</code>, but there are many other types in the standard library that support iteration. <a data-type="xref" href="#iterators-others">Table 15-1</a> summarizes the more interesting ones, but there are many more. We cover some of these methods in more detail in the chapters dedicated to the specific types (namely, Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch16.xhtml#collections">16</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch17.xhtml#strings-and-text">17</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch18.xhtml#input-and-output">18</a>).<a contenteditable="false" data-primary="" data-startref="C15-iterators.html4" data-type="indexterm" id="idm45251601048568"/></p>

<table id="iterators-others" class="tallrow">
<caption><span class="label">Table 15-1. </span>
Other iterators in the standard library
</caption>
<thead>
<tr>
<th>
Type or trait
</th>
<th class="w170">
Expression
</th>
<th>
Notes
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>std::ops::Range</code>
</td>
<td>
<code>1..10</code>
</td>
<td>
Endpoints must be an integer type to be iterable. Range includes start value, and excludes end value.
</td>
</tr>
<tr>
<td>
<code>std::ops::RangeFrom</code>
</td>
<td>
<code>1..</code>
</td>
<td>
Unbounded iteration. Start must be an integer. May panic or overflow if the value reaches the limit of the type.
</td>
</tr>
<tr>
<td>
<code>Option&lt;T&gt;</code>
</td>
<td>
<code>Some(10).iter()</code>
</td>
<td>
Behaves like a vector whose length is either 0 (<code>None</code>) or 1 (<code>Some(v)</code>).
</td>
</tr>
<tr>
<td>
<code>Result&lt;T, E&gt;</code>
</td>
<td>
<code>Ok("blah").iter()</code>
</td>
<td>
Similar to <code>Option</code>, producing <code>Ok</code> values.
</td>
</tr>
<tr>
<td rowspan="7">
<code>Vec&lt;T&gt;</code>, <code>&amp;[T]</code>
</td>
<td>
<code>v.windows(16)</code>
</td>
<td>
Produces every contiguous slice of the given length, from left to right. The windows overlap.
</td>
</tr>
<tr>
<td>
<code>v.chunks(16)</code>
</td>
<td>
Produces nonoverlapping, contiguous slices of the given length, from left to right.
</td>
</tr>
<tr>
<td>
<code>v.chunks_mut(1024)</code>
</td>
<td>
Like <code>chunks</code>, but slices are mutable.
</td>
</tr>
<tr>
<td>
<code>v.split(|byte| byte &amp; 1 != 0)</code>
</td>
<td>
Produces slices separated by elements that match the given predicate.
</td>
</tr>
<tr>
<td>
<code>v.split_mut(...)</code>
</td>
<td>
As above, but produces mutable slices.
</td>
</tr>
<tr>
<td>
<code>v.rsplit(...)</code>
</td>
<td>
Like <code>split</code>, but produces slices from right to left.
</td>
</tr>
<tr>
<td>
<code>v.splitn(n, ...)</code>
</td>
<td>
Like <code>split</code>, but produces at most <code>n</code> slices.
</td>
</tr>
<tr>
<td rowspan="6">
<code>String</code>, <code>&amp;str</code>
</td>
<td>
<code>s.bytes()</code>
</td>
<td>
Produces the bytes of the UTF-8 form.
</td>
</tr>
<tr>
<td>
<code>s.chars()</code>
</td>
<td>
Produces the <code>char</code>s the UTF-8 represents.
</td>
</tr>
<tr>
<td>
<code>s.split_whitespace()</code>
</td>
<td>
Splits string by whitespace, and produces slices of nonspace characters.
</td>
</tr>
<tr>
<td>
<code>s.lines()</code>
</td>
<td>
Produces slices of the lines of the string.
</td>
</tr>
<tr>
<td>
<code>s.split('/')</code>
</td>
<td>
Splits string on a given pattern, producing the slices between matches. Patterns can be many things: characters, strings, closures.
</td>
</tr>
<tr>
<td>
<code>s.matches(char::is_numeric)</code>
</td>
<td>
Produces slices matching the given pattern.
</td>
</tr>
<tr>
<td rowspan="2">
<code>std::collections::HashMap</code>,<br/><code>std::collections::BTreeMap</code>
</td>
<td>
<code>map.keys()</code>,<br/><code>map.values()</code>
</td>
<td>
Produces shared references to keys or values of the map.
</td>
</tr>
<tr>
<td>
<code>map.values_mut()</code>
</td>
<td>
Produces mutable references to entries’ values.
</td>
</tr>
<tr>
<td rowspan="2">
<code>std::collections::HashSet</code>,<br/><code>std::collections::BTreeSet</code>
</td>
<td>
<code>set1.union(set2)</code>
</td>
<td>
Produces shared references to elements of union of <code>set1</code> and <code>set2</code>.
</td>
</tr>
<tr>
<td>
<code>set1.intersection(set2)</code>
</td>
<td>
Produces shared references to elements of intersection of <code>set1</code> and <code>set2</code>.
</td>
</tr>
<tr>
<td>
<code>std::sync::mpsc::Receiver</code>
</td>
<td>
<code>recv.iter()</code>
</td>
<td>
Produces values sent from another thread on the corresponding <code>Sender</code>.
</td>
</tr>
<tr>
<td rowspan="2">
<code>std::io::Read</code>
</td>
<td>
<code>stream.bytes()</code>
</td>
<td>
Produces bytes from an I/O stream.
</td>
</tr>
<tr>
<td>
<code>stream.chars()</code>
</td>
<td>
Parses stream as UTF-8 and produces <code>char</code>s.
</td>
</tr>
<tr>
<td rowspan="2">
<code>std::io::BufRead</code>
</td>
<td>
<code>bufstream.lines()</code>
</td>
<td>
Parses stream as UTF-8, produces lines as <code>String</code>s.
</td>
</tr>
<tr>
<td>
<code>bufstream.split(0)</code>
</td>
<td>
Splits stream on given byte, produces inter-byte <code>Vec&lt;u8&gt;</code> buffers.
</td>
</tr>
<tr>
<td>
<code>std::fs::ReadDir</code>
</td>
<td>
<code>std::fs::read_dir(path)</code>
</td>
<td>
Produces directory entries.
</td>
</tr>
<tr>
<td>
<code>std::net::TcpListener</code>
</td>
<td>
<code>listener.incoming()</code>
</td>
<td>
Produces incoming network connections.
</td>
</tr>
<tr>
<td rowspan="3">
Free functions
</td>
<td>
<code>std::iter::empty()</code>
</td>
<td>
Returns <code>None</code> immediately.
</td>
</tr>
<tr>
<td>
<code>std::iter::once(5)</code>
</td>
<td>
Produces the given value, and then ends.
</td>
</tr>
<tr>
<td>
<code>std::iter::repeat("#9")</code>
</td>
<td>
Produces the given value forever.
</td>
</tr>
</tbody>
</table>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Iterator Adapters"><div class="sect1" id="iterator-adapters">
<h1>Iterator Adapters</h1>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="iterators" data-type="indexterm" id="C15-iterators.html8"/><a contenteditable="false" data-primary="iterators" data-secondary="adapter methods" data-type="indexterm" id="C15-iterators.html9"/>Once you have an iterator in hand, the <code>Iterator</code> trait provides a broad selection of <em>adapter methods</em>, or simply <em>adapters</em>, that consume one iterator and build a new one with useful behaviors. To see how adapters work, we’ll show how to use two of the most popular ones.</p>

<section data-type="sect2" data-pdf-bookmark="map and filter"><div class="sect2" id="map-and-filter">
<h2>map and filter</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="map and filter" data-type="indexterm" id="C15-iterators.html10"/><a contenteditable="false" data-primary="filter adapter" data-type="indexterm" id="C15-iterators.html11"/><a contenteditable="false" data-primary="iterators" data-secondary="map and filter methods" data-type="indexterm" id="C15-iterators.html12"/><a contenteditable="false" data-primary="map adapter" data-type="indexterm" id="C15-iterators.html13"/>The <code>Iterator</code> trait’s <code>map</code> adapter lets you transform an iterator by applying a closure to its items. The <code>filter</code> adapter lets you filter out items from an iterator, using a closure to decide which to keep and which to drop.</p>

<p>For example, suppose you’re iterating over lines of text, and want to omit leading and trailing whitespace from each line. The standard library’s <code>str::trim</code> method drops leading and trailing whitespace from a single <code>&amp;str</code>, returning a new, trimmed <code>&amp;str</code> that borrows from the original. You can use the <code>map</code> adapter to apply <code>str::trim</code> to each line from the iterator:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"  ponies  </code><code class="se">\n</code><code class="s">   giraffes</code><code class="se">\n</code><code class="s">iguanas  </code><code class="se">\n</code><code class="s">squid"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="n">lines</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="kt">str</code>::<code class="n">trim</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="s">"ponies"</code><code class="p">,</code><code class="w"> </code><code class="s">"giraffes"</code><code class="p">,</code><code class="w"> </code><code class="s">"iguanas"</code><code class="p">,</code><code class="w"> </code><code class="s">"squid"</code><code class="p">]);</code><code class="w"/></pre>
<p>The <code>text.lines()</code> call returns an iterator that produces the string’s lines. Calling <code>map</code> on that iterator returns a second iterator that applies <code>str::trim</code> to each line, and produces the results as its items. Finally, <code>collect</code> gathers those items into a vector.</p>
<p>The iterator that <code>map</code> returns is, of course, itself a candidate for further adaptation. If you want to exclude iguanas from the result, you can write the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"  ponies  </code><code class="se">\n</code><code class="s">   giraffes</code><code class="se">\n</code><code class="s">iguanas  </code><code class="se">\n</code><code class="s">squid"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="n">lines</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="kt">str</code>::<code class="n">trim</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">s</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">s</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="s">"iguanas"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="s">"ponies"</code><code class="p">,</code><code class="w"> </code><code class="s">"giraffes"</code><code class="p">,</code><code class="w"> </code><code class="s">"squid"</code><code class="p">]);</code><code class="w"/></pre>
<p>Here, <code>filter</code> returns a third iterator that produces only those items from the <code>map</code> iterator for which the closure <code>|s| *s != "iguanas"</code> returns <code>true</code>. A chain of iterator adapters is like a pipeline in the Unix shell: each adapter has a single purpose, and it’s clear how the sequence is being transformed as one reads from left to right.</p>
<p>These adapters’ signatures are as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">map</code><code class="o">&lt;</code><code class="n">B</code><code class="p">,</code><code class="w"> </code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">B</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">B</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">filter</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">predicate</code>: <code class="nc">P</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">P</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code><code class="p">;</code><code class="w"/></pre>

<p>The <code>some Iterator&lt;...&gt;</code> notation we’re using for the return types is not valid Rust.<sup><a data-type="noteref" id="idm45251600717960-marker" href="ch15.xhtml#idm45251600717960">1</a></sup> The real return types are opaque <code>struct</code> types, which aren’t informative; what matters in practice is that these methods return iterators with the given <code>Item</code> type.</p>

<p>Since most adapters take <code>self</code> by value, they require <code>Self</code> to be <code>Sized</code> (which all common iterators are).</p>
<p>A <code>map</code> iterator passes each item to its closure by value, and in turn, passes along ownership of the closure’s result to its consumer. A <code>filter</code> iterator passes each item to its closure by shared reference, retaining ownership in case the item is selected to be passed on to its consumer. This is why the example must dereference <code>s</code> to compare it with <code>"iguanas"</code>: the <code>filter</code> iterator’s item type is <code>&amp;str</code>, so the type of the closure’s argument <code>s</code> is <code>&amp;&amp;str</code>.</p>
<p>There are two important points to notice about iterator adapters.</p>
<p>First, simply calling an adapter on an iterator doesn’t consume any items; it just returns a new iterator, ready to produce its own items by drawing from the first iterator as needed. In a chain of adapters, the only way to make any work actually get done is to call <code>next</code> on the final iterator.</p>
<p>So in our earlier example, the method call <code>text.lines()</code> itself doesn’t actually parse any lines from the string; it just returns an iterator that <em>would</em> parse lines if asked. Similarly, <code>map</code> and <code>filter</code> just return new iterators that <em>would</em> map or filter if asked. No work takes place until <code>collect</code> starts calling <code>next</code> on the <code>filter</code> iterator.</p>
<p>This point is especially important if you use adapters that have side effects. For example, this code prints nothing at all:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="p">[</code><code class="s">"earth"</code><code class="p">,</code><code class="w"> </code><code class="s">"water"</code><code class="p">,</code><code class="w"> </code><code class="s">"air"</code><code class="p">,</code><code class="w"> </code><code class="s">"fire"</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">elt</code><code class="o">|</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">elt</code><code class="p">));</code><code class="w"/></pre>
<p>The <code>iter</code> call returns an iterator over the array’s elements, and the <code>map</code> call returns a second iterator that applies the closure to each value the first produces. But there is nothing here that ever actually demands a value from the whole chain, so no <code>next</code> method ever runs. In fact, Rust will warn you about this:</p>
<pre data-type="programlisting" data-code-language="console"><code class="go">warning: unused result which must be used:</code>
<code class="go">iterator adaptors are lazy and do nothing unless consumed</code>
<code class="go">    |</code>
<code class="go">387 | /         ["earth", "water", "air", "fire"]</code>
<code class="go">388 | |             .iter().map(|elt| println!("{}", elt));</code>
<code class="go">    | |___________________________________________________^</code>
<code class="go">    |</code>
<code class="go">= note: #[warn(unused_must_use)] on by default</code></pre>
<p>The term “lazy” in the error message is not a disparaging term; it’s just jargon for any mechanism that puts off a computation until its value is needed. It is Rust’s convention that iterators should do the minimum work necessary to satisfy each call to <code>next</code>; in the example, there are no such calls at all, so no work takes place.</p>
<p>The second important point is that iterator adapters are a zero-overhead abstraction. Since <code>map</code>, <code>filter</code>, and their companions are generic, applying them to an iterator specializes their code for the specific iterator type involved. This means that Rust has enough information to inline each iterator’s <code>next</code> method into its consumer, and then translate the entire arrangement into machine code as a unit. So the <code>lines</code>/<code>map</code>/<code>filter</code> chain of iterators we showed before is as efficient as the code you would probably write by hand:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">for</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="n">lines</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="p">.</code><code class="n">trim</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="s">"iguanas"</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">line</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The rest of this section covers the various adapters available on the <code>Iterator</code> trait.<a contenteditable="false" data-primary="" data-startref="C15-iterators.html13" data-type="indexterm" id="idm45251600409848"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html12" data-type="indexterm" id="idm45251600408568"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html11" data-type="indexterm" id="idm45251600407192"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html10" data-type="indexterm" id="idm45251600405816"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="filter_map and flat_map"><div class="sect2" id="filter_map-and-flat_map">
<h2>filter_map and flat_map</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="filter_map and flat_map adapters" data-type="indexterm" id="C15-iterators.html14"/><a contenteditable="false" data-primary="filter_map adapter" data-type="indexterm" id="C15-iterators.html15"/><a contenteditable="false" data-primary="iterators" data-secondary="filter_map and flat_map adapters" data-type="indexterm" id="C15-iterators.html16"/>The <code>map</code> adapter is fine in situations where each incoming item produces one outgoing item. But what if you want to delete certain items from the iteration instead of processing them, or replace single items with zero or more items? The <code>filter_map</code> and <code>flat_map</code> adapters grant you this flexibility.</p>
<p>The <code>filter_map</code> adapter is similar to <code>map</code> except that it lets its closure either transform the item into a new item (as <code>map</code> does) or drop the item from the iteration. Thus, it’s a bit like a combination of <code>filter</code> and <code>map</code>. Its signature is as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">filter_map</code><code class="o">&lt;</code><code class="n">B</code><code class="p">,</code><code class="w"> </code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">B</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">B</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/></pre>
<p>This is the same as <code>map</code>’s signature, except that here the closure returns <code>Option&lt;B&gt;</code>, not simply <code>B</code>. When the closure returns <code>None</code>, the item is dropped from the iteration; when it returns <code>Some(b)</code>, then <code>b</code> is the next item the <code>filter_map</code> iterator produces.</p>
<p>For example, suppose you want to scan a string for whitespace-separated words that can be parsed as numbers, and process the numbers, dropping the other words. You can write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="kt">str</code>::<code class="n">FromStr</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"1</code><code class="se">\n</code><code class="s">frond .25  289</code><code class="se">\n</code><code class="s">3.1415 estuary</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">number</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">()</code><code class="w"/>
<code class="w">                  </code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">w</code><code class="o">|</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">from_str</code><code class="p">(</code><code class="n">w</code><code class="p">).</code><code class="n">ok</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:4.2}"</code><code class="p">,</code><code class="w"> </code><code class="n">number</code><code class="p">.</code><code class="n">sqrt</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This prints the following:</p>
<pre data-type="programlisting" data-code-language="console"><code class="go">1.00</code>
<code class="go">0.50</code>
<code class="go">17.00</code>
<code class="go">1.77</code></pre>
<p>The closure given to <code>filter_map</code> tries to parse each whitespace-separated slice using <code>f64::from_str</code>. That returns a <code>Result&lt;f64, ParseFloatError&gt;</code>, which <code>.ok()</code> turns into an <code>Option&lt;f64&gt;</code>: a parse error becomes <code>None</code>, whereas a successful parse result becomes <code>Some(v)</code>. The <code>filter_map</code> iterator drops all the <code>None</code> values, and produces the value <code>v</code> for each <code>Some(v)</code>.</p>

<p>But what’s the point in fusing <code>map</code> and <code>filter</code> into a single operation like this, instead of just using those adapters directly? The <code>filter_map</code> adapter shows its value in situations like the one just shown, when the best way to decide whether to include the item in the iteration is to actually try to process it. You can do the same thing with only <code>filter</code> and <code>map</code>, but it’s a bit ungainly:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="n">text</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">w</code><code class="o">|</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">from_str</code><code class="p">(</code><code class="n">w</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">is_ok</code><code class="p">())</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">unwrap</code><code class="p">())</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="flat_map adapter" data-type="indexterm" id="idm45251600169864"/>You can think of the <code>flat_map</code> adapter as continuing in the same vein as <code>map</code> and <code>filter_map</code>, except that now the closure can return not just one item (as with <code>map</code>) or zero or one items (as with <code>filter_map</code>), but a sequence of any number of items. The <code>flat_map</code> iterator produces the concatenation of the sequences the closure returns.</p>
<p>The signature of <code>flat_map</code> is shown here:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">flat_map</code><code class="o">&lt;</code><code class="n">U</code><code class="p">,</code><code class="w"> </code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">U</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">U</code><code class="p">,</code><code class="w"> </code><code class="n">U</code>: <code class="nb">IntoIterator</code><code class="p">;</code><code class="w"/></pre>
<p>The closure passed to <code>flat_map</code> must return an iterable, but any sort of iterable <span class="keep-together">will do.</span><sup><a data-type="noteref" id="idm45251600036616-marker" href="ch15.xhtml#idm45251600036616">2</a></sup></p>
<p>For example, suppose we have a table mapping countries to their major cities. Given a list of countries, how can we iterate over their major cities?</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">HashMap</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">major_cities</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashMap</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">major_cities</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Japan"</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"Tokyo"</code><code class="p">,</code><code class="w"> </code><code class="s">"Kyoto"</code><code class="p">]);</code><code class="w"/>
<code class="n">major_cities</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"The United States"</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"Portland"</code><code class="p">,</code><code class="w"> </code><code class="s">"Nashville"</code><code class="p">]);</code><code class="w"/>
<code class="n">major_cities</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Brazil"</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"São Paulo"</code><code class="p">,</code><code class="w"> </code><code class="s">"Brasília"</code><code class="p">]);</code><code class="w"/>
<code class="n">major_cities</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Kenya"</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"Nairobi"</code><code class="p">,</code><code class="w"> </code><code class="s">"Mombasa"</code><code class="p">]);</code><code class="w"/>
<code class="n">major_cities</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"The Netherlands"</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"Amsterdam"</code><code class="p">,</code><code class="w"> </code><code class="s">"Utrecht"</code><code class="p">]);</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">countries</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s">"Japan"</code><code class="p">,</code><code class="w"> </code><code class="s">"Brazil"</code><code class="p">,</code><code class="w"> </code><code class="s">"Kenya"</code><code class="p">];</code><code class="w"/>

<code class="k">for</code><code class="w"> </code><code class="o">&amp;</code><code class="n">city</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">countries</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">flat_map</code><code class="p">(</code><code class="o">|</code><code class="n">country</code><code class="o">|</code><code class="w"> </code><code class="o">&amp;</code><code class="n">major_cities</code><code class="p">[</code><code class="n">country</code><code class="p">])</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">city</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This prints the following:</p>
<pre data-type="programlisting" data-code-language="console"><code class="go">Tokyo</code>
<code class="go">Kyoto</code>
<code class="go">São Paulo</code>
<code class="go">Brasília</code>
<code class="go">Nairobi</code>
<code class="go">Mombasa</code></pre>
<p>One way to look at this would be to say that, for each country, we retrieve the vector of its cities, concatenate all the vectors together into a single sequence, and print that.</p>
<p>But remember that iterators are lazy: it’s only the <code>for</code> loop’s calls to the <code>flat_map</code> iterator’s <code>next</code> method that cause work to be done. The full concatenated sequence is never constructed in memory. Instead, what we have here is a little state machine that draws from the city iterator, one item at a time, until it’s exhausted, and only then produces a new city iterator for the next country. The effect is that of a nested loop, but packaged up for use as an iterator.<a contenteditable="false" data-primary="" data-startref="C15-iterators.html16" data-type="indexterm" id="idm45251599827672"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html15" data-type="indexterm" id="idm45251599826408"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html14" data-type="indexterm" id="idm45251599825032"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="scan"><div class="sect2" id="scan">
<h2>scan</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="scan adapter" data-type="indexterm" id="idm45251599822328"/><a contenteditable="false" data-primary="iterators" data-secondary="scan adapter" data-type="indexterm" id="idm45251599820728"/><a contenteditable="false" data-primary="scan adapter" data-type="indexterm" id="idm45251599819352"/>The <code>scan</code> adapter resembles <code>map</code>, except that the closure is given a mutable value it can consult, and has the option of terminating the iteration early. It takes an initial state value, and then a closure that accepts a mutable reference to the state, and the next item from the underlying iterator. The closure must return an <code>Option</code>, which the <code>scan</code> iterator takes as its next item.</p>
<p>For example, here’s an iterator chain that squares another iterator’s items, and terminates the iteration once their sum exceeds 10:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">..</code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">scan</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">sum</code><code class="p">,</code><code class="w"> </code><code class="n">item</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="o">*</code><code class="n">sum</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">item</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="o">*</code><code class="n">sum</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nb">None</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nb">Some</code><code class="p">(</code><code class="n">item</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">item</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">});</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;&gt;</code><code class="p">(),</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">16</code><code class="p">]);</code><code class="w"/></pre>
<p>The closure’s <code>sum</code> argument is a mutable reference to a value private to the iterator and initialized to <code>scan</code>’s first argument—in this case, <code>0</code>. The closure updates <code>*sum</code>, checks whether it has exceeded the limit, and returns the iterator’s next result.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="take and take_while"><div class="sect2" id="take-and-take_while">
<h2>take and take_while</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="take and take_while" data-type="indexterm" id="idm45251599725080"/><a contenteditable="false" data-primary="iterators" data-secondary="take and take_while adapters" data-type="indexterm" id="idm45251599723480"/><a contenteditable="false" data-primary="take adapter" data-type="indexterm" id="idm45251599722136"/><a contenteditable="false" data-primary="take_while adapter" data-type="indexterm" id="idm45251599721032"/>The <code>Iterator</code> trait’s <code>take</code> and <code>take_while</code> adapters let you end an iteration after a certain number of items, or when a closure decides to cut things off. Their signatures are as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">take</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">n</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">take_while</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">predicate</code>: <code class="nc">P</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">P</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code><code class="p">;</code><code class="w"/></pre>
<p>Both take ownership of an iterator and return a new iterator that passes along items from the first one, possibly ending the sequence earlier. The <code>take</code> iterator returns <code>None</code> after producing at most <code>n</code> items. The <code>take_while</code> iterator applies <code>predicate</code> to each item, and returns <code>None</code> in place of the first item for which <code>predicate</code> returns <code>false</code>, and on every subsequent call to <code>next</code>.</p>
<p>For example, given an email message with a blank line separating the headers from the message body, you can use <code>take_while</code> to iterate over only the headers:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">message</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"To: jimb</code><code class="se">\r\n</code><code class="s">\</code>
<code class="s">               From: superego &lt;editor@oreilly.com&gt;</code><code class="se">\r\n</code><code class="s">\</code>
<code class="s">               </code><code class="se">\r\n</code><code class="s">\</code>
<code class="s">               Did you get any writing done today?</code><code class="se">\r\n</code><code class="s">\</code>
<code class="s">               When will you stop wasting time plotting fractals?</code><code class="se">\r\n</code><code class="s">"</code><code class="p">;</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">header</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">message</code><code class="p">.</code><code class="n">lines</code><code class="p">().</code><code class="n">take_while</code><code class="p">(</code><code class="o">|</code><code class="n">l</code><code class="o">|</code><code class="w"> </code><code class="o">!</code><code class="n">l</code><code class="p">.</code><code class="n">is_empty</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="w"> </code><code class="p">,</code><code class="w"> </code><code class="n">header</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Recall from <a data-type="xref" href="ch03.xhtml#string-literals">“String Literals”</a> that when a line in a string ends with a backslash, Rust doesn’t include the indentation of the next line in the string, so none of the lines in the string have any leading whitespace. This means that the third line of <code>message</code> is blank. The <code>take_while</code> adapter terminates the iteration as soon as it sees that blank line, so this code prints only the two lines:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">To</code>: <code class="nc">jimb</code><code class="w"/>
<code class="nb">From</code>: <code class="nc">superego</code><code class="w"> </code><code class="o">&lt;</code><code class="n">editor</code><code class="o">@</code><code class="n">oreilly</code><code class="p">.</code><code class="n">com</code><code class="o">&gt;</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="skip and skip_while"><div class="sect2" id="skip-and-skip_while">
<h2>skip and skip_while</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="skip and skip_while" data-type="indexterm" id="idm45251599409224"/><a contenteditable="false" data-primary="iterators" data-secondary="skip and skip_while adapters" data-type="indexterm" id="idm45251599407624"/><a contenteditable="false" data-primary="skip adapter" data-type="indexterm" id="idm45251599453352"/><a contenteditable="false" data-primary="skip_while adapter" data-type="indexterm" id="idm45251599452248"/>The <code>Iterator</code> trait’s <code>skip</code> and <code>skip_while</code> methods are the complement of <code>take</code> and <code>take_while</code>: they drop a certain number of items from the beginning of an iteration, or drop items until a closure finds one acceptable, and then pass the remaining items through unchanged. Their signatures are as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">skip</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">n</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">skip_while</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">predicate</code>: <code class="nc">P</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">P</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code><code class="p">;</code><code class="w"/></pre>
<p>One common use for the <code>skip</code> adapter is to skip the command name when iterating over a program’s command-line arguments. In <a data-type="xref" href="ch02.xhtml#a-tour-of-rust">Chapter 2</a>, our greatest common denominator calculator used the following code to loop over its command-line arguments:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">for</code><code class="w"> </code><code class="n">arg</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">skip</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>std::env::args</code> function returns an iterator that produces the program’s arguments as <code>String</code>s, the first item being the name of the program itself. That’s not a string we want to process in this loop. Calling <code>skip(1)</code> on that iterator returns a new iterator that drops the program name the first time it’s called, and then produces all the subsequent arguments.</p>
<p>The <code>skip_while</code> adapter uses a closure to decide how many items to drop from the beginning of the sequence. You can iterate over the body lines of the message from the previous section like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">for</code><code class="w"> </code><code class="n">body</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">message</code><code class="p">.</code><code class="n">lines</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">skip_while</code><code class="p">(</code><code class="o">|</code><code class="n">l</code><code class="o">|</code><code class="w"> </code><code class="o">!</code><code class="n">l</code><code class="p">.</code><code class="n">is_empty</code><code class="p">())</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">skip</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="w"> </code><code class="p">,</code><code class="w"> </code><code class="n">body</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This uses <code>skip_while</code> to skip nonblank lines, but that iterator does produce the blank line itself—after all, the closure returned <code>false</code> for that line. So we use the <code>skip</code> method as well to drop that, giving us an iterator whose first item will be the message body’s first line. Taken together with the declaration of <code>message</code> from the previous section, this code prints:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="n">Did</code><code class="w"> </code><code class="n">you</code><code class="w"> </code><code class="n">get</code><code class="w"> </code><code class="n">any</code><code class="w"> </code><code class="n">writing</code><code class="w"> </code><code class="n">done</code><code class="w"> </code><code class="n">today</code><code class="o">?</code><code class="w"/>
<code class="n">When</code><code class="w"> </code><code class="n">will</code><code class="w"> </code><code class="n">you</code><code class="w"> </code><code class="n">stop</code><code class="w"> </code><code class="n">wasting</code><code class="w"> </code><code class="n">time</code><code class="w"> </code><code class="n">plotting</code><code class="w"> </code><code class="n">fractals</code><code class="o">?</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="peekable"><div class="sect2" id="peekable">
<h2>peekable</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="peekable" data-type="indexterm" id="idm45251599111688"/><a contenteditable="false" data-primary="iterators" data-secondary="peekable" data-type="indexterm" id="idm45251599110312"/><a contenteditable="false" data-primary="peekable iterator" data-type="indexterm" id="idm45251599108936"/>A peekable iterator lets you peek at the next item that will be produced without actually consuming it. You can turn almost any iterator into a peekable iterator by calling the <code>Iterator</code> trait’s <code>peekable</code> method:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">peekable</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">std</code>::<code class="n">iter</code>::<code class="n">Peekable</code><code class="o">&lt;</code><code class="n">Self</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">;</code><code class="w"/></pre>
<p>Here, <code>Peekable&lt;Self&gt;</code> is a <code>struct</code> that implements <code>Iterator&lt;Item=Self::Item&gt;</code>, and <code>Self</code> is the type of the underlying iterator.</p>
<p>A <code>Peekable</code> iterator has an additional method <code>peek</code> that returns an <code>Option&lt;&amp;Item&gt;</code>: <code>None</code> if the underlying iterator is done, and otherwise <code>Some(r)</code>, where <code>r</code> is a shared reference to the next item. (Note that, if the iterator’s item type is already a reference to something, this ends up being a reference to a reference.)</p>
<p>Calling <code>peek</code> tries to draw the next item from the underlying iterator, and if there is one, caches it until the next call to <code>next</code>. All the other <code>Iterator</code> methods on <code>Peekable</code> know about this cache: for example, <code>iter.last()</code> on a peekable iterator <code>iter</code> knows to check the cache after exhausting the underlying iterator.</p>
<p>Peekable iterators are essential when you can’t decide how many items to consume from an iterator until you’ve gone too far. For example, if you’re parsing numbers from a stream of characters, you can’t decide where the number ends until you’ve seen the first non-number character following it:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">iter</code>::<code class="n">Peekable</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">parse_number</code><code class="o">&lt;</code><code class="n">I</code><code class="o">&gt;</code><code class="p">(</code><code class="n">tokens</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Peekable</code><code class="o">&lt;</code><code class="n">I</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code>
    <code class="nc">where</code><code class="w"> </code><code class="n">I</code>: <code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">char</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="n">tokens</code><code class="p">.</code><code class="n">peek</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nb">Some</code><code class="p">(</code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">is_digit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">to_digit</code><code class="p">(</code><code class="mi">10</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">n</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="n">tokens</code><code class="p">.</code><code class="n">next</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">chars</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"226153980,1766319049"</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">peekable</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_number</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">chars</code><code class="p">),</code><code class="w"> </code><code class="mi">226153980</code><code class="p">);</code><code class="w"/>
<code class="c1">// Look, `parse_number` didn't consume the comma! So we will.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">chars</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">','</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_number</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">chars</code><code class="p">),</code><code class="w"> </code><code class="mi">1766319049</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">chars</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>The <code>parse_number</code> function uses <code>peek</code> to check the next character, and consumes it only if it is a digit. If it isn’t a digit or the iterator is exhausted (that is, if <code>peek</code> returns <code>None</code>), we return the number we’ve parsed and leave the next character in the iterator, ready to be consumed.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="fuse"><div class="sect2" id="fuse">
<h2>fuse</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="fuse" data-type="indexterm" id="idm45251598858488"/><a contenteditable="false" data-primary="fuse adapter" data-type="indexterm" id="idm45251598856920"/><a contenteditable="false" data-primary="iterators" data-secondary="fuse adapter" data-type="indexterm" id="idm45251598855816"/>Once an <code>Iterator</code> has returned <code>None</code>, the trait doesn’t specify how it ought to behave if you call its <code>next</code> method again. Most iterators just return <code>None</code> again, but not all. If your code counts on that behavior, you may be in for a surprise.</p>
<p>The <code>fuse</code> adapter takes any iterator and turns into one that will definitely continue to return <code>None</code> once it has done so the first time:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Flaky</code><code class="p">(</code><code class="kt">bool</code><code class="p">);</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="nb">Iterator</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Flaky</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">next</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="nb">Some</code><code class="p">(</code><code class="s">"totally the last item"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="p">;</code><code class="w"> </code><code class="c1">// D'oh!</code>
<code class="w">            </code><code class="nb">None</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">flaky</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Flaky</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">flaky</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"totally the last item"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">flaky</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">flaky</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"totally the last item"</code><code class="p">));</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">not_flaky</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Flaky</code><code class="p">(</code><code class="kc">true</code><code class="p">).</code><code class="n">fuse</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">not_flaky</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"totally the last item"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">not_flaky</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">not_flaky</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>The <code>fuse</code> adapter is probably most useful in generic code that needs to work with iterators of uncertain origin. Rather than hoping that every iterator you’ll have to deal with will be well-behaved, you can use <code>fuse</code> to make sure.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Reversible Iterators and rev"><div class="sect2" id="reversible-iterators-and-rev">
<h2>Reversible Iterators and rev</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="reversible iterators and rev" data-type="indexterm" id="C15-iterators.html17"/><a contenteditable="false" data-primary="iterators" data-secondary="reversible" data-type="indexterm" id="C15-iterators.html18"/><a contenteditable="false" data-primary="rev adapter" data-type="indexterm" id="C15-iterators.html19"/><a contenteditable="false" data-primary="reversible iterators" data-type="indexterm" id="C15-iterators.html20"/>Some iterators are able to draw items from both ends of the sequence. You can reverse such iterators by using the <code>rev</code> adapter. For example, an iterator over a vector could just as easily draw items from the end of the vector as from the start. Such <span class="keep-together">iterators</span> can implement the <code>std::iter::DoubleEndedIterator</code> trait, which extends <code>Iterator</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">DoubleEndedIterator</code>: <code class="nb">Iterator</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">next_back</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You can think of a double-ended iterator as having two fingers marking the current front and back of the sequence. Drawing items from either end advances that finger toward the other; when the two meet, the iteration is done:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">iter</code>::<code class="nb">DoubleEndedIterator</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">bee_parts</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s">"head"</code><code class="p">,</code><code class="w"> </code><code class="s">"thorax"</code><code class="p">,</code><code class="w"> </code><code class="s">"abdomen"</code><code class="p">];</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bee_parts</code><code class="p">.</code><code class="n">iter</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w">      </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"head"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next_back</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"abdomen"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w">      </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"thorax"</code><code class="p">));</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next_back</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w">      </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>The structure of an iterator over a slice makes this behavior easy to implement: it is literally a pair of pointers to the start and end of the range of elements we haven’t yet produced; <code>next</code> and <code>next_back</code> simply draw an item from the one or the other. Iterators for ordered collections like <code>BTreeSet</code> and <code>BTreeMap</code> are double-ended too: their <code>next_back</code> method draws the greatest elements or entries first. In general, the standard library provides double-ended iteration whenever it’s practical.</p>
<p>But not all iterators can do this so easily: an iterator producing values from other threads arriving at a channel’s <code>Receiver</code> has no way to anticipate what the last value received might be. In general, you’ll need to check the standard library’s documentation to see which iterators implement <code>DoubleEndedIterator</code> and which don’t.</p>
<p>If an iterator is double-ended, you can reverse it with the <code>rev</code> adapter:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">rev</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code> <code class="o">+</code><code class="w"> </code><code class="nb">DoubleEndedIterator</code><code class="p">;</code><code class="w"/></pre>
<p>The returned iterator is also double-ended: its <code>next</code> and <code>next_back</code> methods are simply exchanged:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">meals</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s">"breakfast"</code><code class="p">,</code><code class="w"> </code><code class="s">"lunch"</code><code class="p">,</code><code class="w"> </code><code class="s">"dinner"</code><code class="p">];</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">meals</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">rev</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"dinner"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"lunch"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"breakfast"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>Most iterator adapters, if applied to a reversible iterator, return another reversible iterator. For example, <code>map</code> and <code>filter</code> preserve reversibility.<a contenteditable="false" data-primary="" data-startref="C15-iterators.html20" data-type="indexterm" id="idm45251598317416"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html19" data-type="indexterm" id="idm45251598193560"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html18" data-type="indexterm" id="idm45251598192184"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html17" data-type="indexterm" id="idm45251598190808"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="inspect"><div class="sect2" id="inspect">
<h2>inspect</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="inspect" data-type="indexterm" id="idm45251598187752"/><a contenteditable="false" data-primary="closures" data-secondary="inspect adapter and" data-type="indexterm" id="idm45251598186376"/><a contenteditable="false" data-primary="inspect adapter" data-type="indexterm" id="idm45251598185000"/><a contenteditable="false" data-primary="iterators" data-secondary="inspect adapter" data-type="indexterm" id="idm45251598183896"/>The <code>inspect</code> adapter is handy for debugging pipelines of iterator adapters, but it isn’t used much in production code. It simply applies a closure to a shared reference to each item, and then passes the item through. The closure can’t affect the items, but it can do things like print them or make assertions about them.</p>
<p>This example shows a case in which converting a string to uppercase changes its length:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">upper_case</code>: <code class="nb">String</code> <code class="o">=</code><code class="w"> </code><code class="s">"große"</code><code class="p">.</code><code class="n">chars</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">inspect</code><code class="p">(</code><code class="o">|</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"before: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">c</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">flat_map</code><code class="p">(</code><code class="o">|</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="n">to_uppercase</code><code class="p">())</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">inspect</code><code class="p">(</code><code class="o">|</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">" after:     {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">c</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">upper_case</code><code class="p">,</code><code class="w"> </code><code class="s">"GROSSE"</code><code class="p">);</code><code class="w"/></pre>

<p>The uppercase equivalent of the lowercase German letter “ß” is “SS”, which is why <code>char::to_uppercase</code> returns an iterator over characters, not a single replacement character. The preceding code uses <code>flat_map</code> to concatenate all the sequences that <code>to_uppercase</code> returns into a single <code>String</code>, printing the following as it does so:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">before: 'g'</code>
<code class="go"> after:     'G'</code>
<code class="go">before: 'r'</code>
<code class="go"> after:     'R'</code>
<code class="go">before: 'o'</code>
<code class="go"> after:     'O'</code>
<code class="go">before: 'ß'</code>
<code class="go"> after:     'S'</code>
<code class="go"> after:     'S'</code>
<code class="go">before: 'e'</code>
<code class="go"> after:     'E'</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="chain"><div class="sect2" id="chain">
<h2>chain</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="chain" data-type="indexterm" id="idm45251598056680"/><a contenteditable="false" data-primary="chain adapter" data-type="indexterm" id="idm45251598055080"/><a contenteditable="false" data-primary="iterators" data-secondary="chain adapter" data-type="indexterm" id="idm45251598053976"/>The <code>chain</code> adapter appends one iterator to another. More precisely, <code>i1.chain(i2)</code> returns an iterator that draws items from <code>i1</code> until it’s exhausted, and then draws items from <code>i2</code>.</p>
<p>The <code>chain</code> adapter’s signature is as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">chain</code><code class="o">&lt;</code><code class="n">U</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="nc">U</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">some</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">U</code>: <code class="nb">IntoIterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/></pre>
<p>In other words, you can chain an iterator together with any iterable that produces the same item type.</p>
<p>For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="mi">4</code><code class="p">).</code><code class="n">chain</code><code class="p">(</code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">]).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">]);</code><code class="w"/></pre>
<p>A <code>chain</code> iterator is reversible, if both of its underlying iterators are:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="mi">4</code><code class="p">).</code><code class="n">chain</code><code class="p">(</code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">]).</code><code class="n">rev</code><code class="p">().</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="mi">40</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">]);</code><code class="w"/></pre>
<p>A <code>chain</code> iterator keeps track of whether each of the two underlying iterators has returned <code>None</code>, and directs <code>next</code> and <code>next_back</code> calls to one or the other as appropriate.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="enumerate"><div class="sect2" id="enumerate">
<h2>enumerate</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="enumerate" data-type="indexterm" id="idm45251597782648"/><a contenteditable="false" data-primary="enumerate adapter" data-secondary="about" data-type="indexterm" id="idm45251597781048"/><a contenteditable="false" data-primary="iterators" data-secondary="enumerate adapter" data-type="indexterm" id="idm45251597779672"/>The <code>Iterator</code> trait’s <code>enumerate</code> adapter attaches a running index to the sequence, taking an iterator that produces items <code>A, B, C, ...</code> and returning an iterator that produces pairs <code>(0, A), (1, B), (2, C), ...</code>. It looks trivial at first glance, but it’s used surprisingly often.</p>

<p>Consumers can use that index to distinguish one item from another, and establish the context in which to process each one. For example, the Mandelbrot set plotter in <a data-type="xref" href="ch02.xhtml#a-tour-of-rust">Chapter 2</a> splits the image into eight horizontal bands and assigns each one to a different thread. That code uses <code>enumerate</code> to tell each thread which portion of the image its band corresponds to.</p>
<p>Starting with a rectangular buffer of pixels:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">pixels</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">columns</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">rows</code><code class="p">];</code><code class="w"/></pre>
<p>It uses <code>chunks_mut</code> to split the image into horizontal bands, one per thread:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">threads</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">8</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">band_rows</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rows</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">threads</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="p">...</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">bands</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="k">mut</code><code class="w"> </code><code class="p">[</code><code class="kt">u8</code><code class="p">]</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pixels</code><code class="p">.</code><code class="n">chunks_mut</code><code class="p">(</code><code class="n">band_rows</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">columns</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"/></pre>
<p>And then it iterates over the bands, starting a thread for each one:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">band</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">bands</code><code class="p">.</code><code class="n">into_iter</code><code class="p">().</code><code class="n">enumerate</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">top</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">band_rows</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="c1">// start a thread to render rows `top..top + band_rows`</code>
<code class="p">}</code><code class="w"/></pre>
<p>Each iteration gets a pair <code>(i, band)</code>, where <code>band</code> is the <code>&amp;mut [u8]</code> slice of the pixel buffer the thread should draw into, and <code>i</code> is the index of that band in the overall image, courtesy of the <code>enumerate</code> adapter. Given the boundaries of the plot and the size of the bands, this is enough information for the thread to determine which portion of the image it has been assigned, and thus what to draw into <code>band</code>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="zip"><div class="sect2" id="zip">
<h2>zip</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="zip" data-type="indexterm" id="idm45251597615720"/><a contenteditable="false" data-primary="iterators" data-secondary="zip adapter" data-type="indexterm" id="idm45251597614344"/><a contenteditable="false" data-primary="zip adapter" data-type="indexterm" id="idm45251597612968"/>The <code>zip</code> adapter combines two iterators into a single iterator that produces pairs holding one value from each iterator, like a zipper joining its two sides into a single seam. The zipped iterator ends when either of the two underlying iterators ends.</p>
<p>For example, you can get the same effect as the <code>enumerate</code> adapter by zipping the half-open range <code>0..</code> with the other iterator:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">..).</code><code class="n">zip</code><code class="p">(</code><code class="s">"ABCD"</code><code class="p">.</code><code class="n">chars</code><code class="p">()).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="sc">'A'</code><code class="p">),</code><code class="w"> </code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="sc">'B'</code><code class="p">),</code><code class="w"> </code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="sc">'C'</code><code class="p">),</code><code class="w"> </code><code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="sc">'D'</code><code class="p">)]);</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="enumerate adapter" data-secondary="zip and" data-type="indexterm" id="idm45251597562504"/>In this sense, you can think of <code>zip</code> as a generalization of <code>enumerate</code>: whereas <code>enumerate</code> attaches indices to the sequence, <code>zip</code> attaches any arbitrary iterator’s items. We suggested before that <code>enumerate</code> can help provide context for processing items; <code>zip</code> is a more flexible way to do the same.</p>
<p>The argument to <code>zip</code> doesn’t need to be an iterator itself; it can be any iterable:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">iter</code>::<code class="n">repeat</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">endings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"once"</code><code class="p">,</code><code class="w"> </code><code class="s">"twice"</code><code class="p">,</code><code class="w"> </code><code class="s">"chicken soup with rice"</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">rhyme</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">repeat</code><code class="p">(</code><code class="s">"going"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">zip</code><code class="p">(</code><code class="n">endings</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">rhyme</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[(</code><code class="s">"going"</code><code class="p">,</code><code class="w"> </code><code class="s">"once"</code><code class="p">),</code><code class="w"/>
<code class="w">                       </code><code class="p">(</code><code class="s">"going"</code><code class="p">,</code><code class="w"> </code><code class="s">"twice"</code><code class="p">),</code><code class="w"/>
<code class="w">                       </code><code class="p">(</code><code class="s">"going"</code><code class="p">,</code><code class="w"> </code><code class="s">"chicken soup with rice"</code><code class="p">)]);</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="by_ref"><div class="sect2" id="by_ref">
<h2>by_ref</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="by_ref" data-type="indexterm" id="idm45251597366296"/><a contenteditable="false" data-primary="by_ref adapter" data-type="indexterm" id="idm45251597365032"/><a contenteditable="false" data-primary="iterators" data-secondary="by_ref adapter" data-type="indexterm" id="idm45251597363928"/>Throughout this section, we’ve been attaching adapters to iterators. Once you’ve done so, can you ever take the adapter off again? Usually, no: adapters take ownership of the underlying iterator, and provide no method to give it back.</p>
<p>An iterator’s <code>by_ref</code> method borrows a mutable reference to the iterator, so that you can apply adaptors to the reference. When you’re done consuming items from these adaptors, you drop them, the borrow ends, and you regain access to your original iterator.</p>
<p>For example, earlier in the chapter we showed how to use <code>take_while</code> and <code>skip_while</code> to process the header lines and body of a mail message. But what if you want to do both, using the same underlying iterator? Using <code>by_ref</code>, we can use <code>take_while</code> to handle the headers, and when that’s done, get the underlying iterator back, which <code>take_while</code> has left exactly in position to handle the message body:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">message</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"To: jimb</code><code class="se">\r\n</code><code class="s">\</code>
<code class="s">               From: id</code><code class="se">\r\n</code><code class="s">\</code>
<code class="s">               </code><code class="se">\r\n</code><code class="s">\</code>
<code class="s">               Oooooh, donuts!!</code><code class="se">\r\n</code><code class="s">"</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">lines</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">message</code><code class="p">.</code><code class="n">lines</code><code class="p">();</code><code class="w"/>

<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Headers:"</code><code class="p">);</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">header</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">lines</code><code class="p">.</code><code class="n">by_ref</code><code class="p">().</code><code class="n">take_while</code><code class="p">(</code><code class="o">|</code><code class="n">l</code><code class="o">|</code><code class="w"> </code><code class="o">!</code><code class="n">l</code><code class="p">.</code><code class="n">is_empty</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="w"> </code><code class="p">,</code><code class="w"> </code><code class="n">header</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"</code><code class="se">\n</code><code class="s">Body:"</code><code class="p">);</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">body</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">lines</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="w"> </code><code class="p">,</code><code class="w"> </code><code class="n">body</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The call <code>lines.by_ref()</code> borrows a mutable reference to the iterator, and it is this reference that the <code>take_while</code> iterator takes ownership of. That iterator goes out of scope at the end of the first <code>for</code> loop, meaning that the borrow has ended, so you can use <code>lines</code> again in the second <code>for</code> loop. This prints the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">Headers</code>:
<code class="nc">To</code>: <code class="nc">jimb</code><code class="w"/>
<code class="nb">From</code>: <code class="nc">id</code><code class="w"/>

<code class="n">Body</code>:
<code class="nc">Oooooh</code><code class="p">,</code><code class="w"> </code><code class="n">donuts</code><code class="o">!!</code><code class="w"/></pre>
<p>The <code>by_ref</code> adapter’s definition is trivial: it returns a mutable reference to the iterator. Then, the standard library includes this strange little implementation:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">I</code>: <code class="nb">Iterator</code> <code class="o">+</code><code class="w"> </code><code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">Iterator</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">I</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">I</code>::<code class="n">Item</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">next</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">I</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="o">**</code><code class="bp">self</code><code class="p">).</code><code class="n">next</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">size_hint</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="o">**</code><code class="bp">self</code><code class="p">).</code><code class="n">size_hint</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="size_hint method" data-type="indexterm" id="idm45251597214808"/>In other words, if <code>I</code> is some iterator type, then <code>&amp;mut I</code> is an iterator too, whose <code>next</code> and <code>size_hint</code> methods defer to its referent. When you call an adapter on a mutable reference to an iterator, the adapter takes ownership of the <em>reference</em>, not the iterator itself. That’s just a borrow that ends when the adapter goes out of scope.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="cloned"><div class="sect2" id="cloned">
<h2>cloned</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="cloned" data-type="indexterm" id="idm45251597038280"/><a contenteditable="false" data-primary="cloned adapter" data-type="indexterm" id="idm45251597036904"/><a contenteditable="false" data-primary="iterators" data-secondary="cloned adapter" data-type="indexterm" id="idm45251597035800"/>The <code>cloned</code> adapter takes an iterator that produces references, and returns an iterator that produces values cloned from those references. Naturally, the referent type must implement <code>Clone</code>. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="sc">'1'</code><code class="p">,</code><code class="w"> </code><code class="sc">'2'</code><code class="p">,</code><code class="w"> </code><code class="sc">'3'</code><code class="p">,</code><code class="w"> </code><code class="sc">'∞'</code><code class="p">];</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">next</code><code class="p">(),</code><code class="w">          </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="sc">'1'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">cloned</code><code class="p">().</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'1'</code><code class="p">));</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="cycle"><div class="sect2" id="cycle">
<h2>cycle</h2>

<p><a contenteditable="false" data-primary="adapter methods" data-secondary="cycle" data-type="indexterm" id="idm45251596917272"/><a contenteditable="false" data-primary="cycle adapter" data-type="indexterm" id="idm45251596915896"/><a contenteditable="false" data-primary="iterators" data-secondary="cycle adapter" data-type="indexterm" id="idm45251596914792"/>The <code>cycle</code> adapter returns an iterator that endlessly repeats the sequence produced by the underlying iterator. The underlying iterator must implement <code>std::clone::Clone</code>, so that <code>cycle</code> can save its initial state and reuse it each time the cycle starts again.</p>
<p>For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">dirs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s">"North"</code><code class="p">,</code><code class="w"> </code><code class="s">"East"</code><code class="p">,</code><code class="w"> </code><code class="s">"South"</code><code class="p">,</code><code class="w"> </code><code class="s">"West"</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">spin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dirs</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">cycle</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">spin</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"North"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">spin</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"East"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">spin</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"South"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">spin</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"West"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">spin</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"North"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">spin</code><code class="p">.</code><code class="n">next</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"East"</code><code class="p">));</code><code class="w"/></pre>
<p>Or, for a really gratuitous use of iterators:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">iter</code>::<code class="p">{</code><code class="n">once</code><code class="p">,</code><code class="w"> </code><code class="n">repeat</code><code class="p">};</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">fizzes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">repeat</code><code class="p">(</code><code class="s">""</code><code class="p">).</code><code class="n">take</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="n">chain</code><code class="p">(</code><code class="n">once</code><code class="p">(</code><code class="s">"fizz"</code><code class="p">)).</code><code class="n">cycle</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">buzzes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">repeat</code><code class="p">(</code><code class="s">""</code><code class="p">).</code><code class="n">take</code><code class="p">(</code><code class="mi">4</code><code class="p">).</code><code class="n">chain</code><code class="p">(</code><code class="n">once</code><code class="p">(</code><code class="s">"buzz"</code><code class="p">)).</code><code class="n">cycle</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">fizzes_buzzes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fizzes</code><code class="p">.</code><code class="n">zip</code><code class="p">(</code><code class="n">buzzes</code><code class="p">);</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">fizz_buzz</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="mi">100</code><code class="p">).</code><code class="n">zip</code><code class="p">(</code><code class="n">fizzes_buzzes</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">tuple</code><code class="o">|</code><code class="w"/>
<code class="w">         </code><code class="k">match</code><code class="w"> </code><code class="n">tuple</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">             </code><code class="p">(</code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="s">""</code><code class="p">))</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">i</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">             </code><code class="p">(</code><code class="n">_</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="n">fizz</code><code class="p">,</code><code class="w"> </code><code class="n">buzz</code><code class="p">))</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}{}"</code><code class="p">,</code><code class="w"> </code><code class="n">fizz</code><code class="p">,</code><code class="w"> </code><code class="n">buzz</code><code class="p">)</code><code class="w"/>
<code class="w">         </code><code class="p">});</code><code class="w"/>

<code class="k">for</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">fizz_buzz</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">line</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This plays a children’s word game, now sometimes used as a job interview question for coders, in which the players take turns counting, replacing any number divisible by three with the word “fizz”, and any number divisible by five with “buzz”. Numbers divisible by both become “fizzbuzz”.<a contenteditable="false" data-primary="" data-startref="C15-iterators.html9" data-type="indexterm" id="idm45251596762184"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html8" data-type="indexterm" id="idm45251596760968"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Consuming Iterators"><div class="sect1" id="consuming-iterators">
<h1>Consuming Iterators</h1>

<p><a contenteditable="false" data-primary="consuming iterators" data-type="indexterm" id="C15-iterators.html21"/><a contenteditable="false" data-primary="iterators" data-secondary="consuming" data-type="indexterm" id="C15-iterators.html22"/>So far we’ve covered creating iterators, and adapting them into new iterators; here we finish off the process by showing ways to consume them.</p>
<p>Of course, you can consume an iterator with a <code>for</code> loop, or call <code>next</code> explicitly, but there are many common tasks that you shouldn’t have to write out again and again. The <code>Iterator</code> trait provides a broad selection of methods to cover many of these.</p>

<section data-type="sect2" data-pdf-bookmark="Simple Accumulation: count, sum, product"><div class="sect2" id="simple-accumulation-count-sum-product">
<h2>Simple Accumulation: count, sum, product</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="count method" data-type="indexterm" id="idm45251596624104"/><a contenteditable="false" data-primary="consuming iterators" data-secondary="simple accumulation" data-type="indexterm" id="idm45251596622728"/><a contenteditable="false" data-primary="count method" data-type="indexterm" id="idm45251596621352"/>The <code>count</code> method draws items from an iterator until it returns <code>None</code>, and tells you how many it got. Here’s a short program that counts the number of lines on its standard input:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">prelude</code>::<code class="o">*</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">stdin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">stdin</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">stdin</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">lines</code><code class="p">().</code><code class="n">count</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="product method" data-type="indexterm" id="idm45251596501048"/><a contenteditable="false" data-primary="consuming iterators" data-secondary="sum method" data-type="indexterm" id="idm45251596484776"/><a contenteditable="false" data-primary="product method" data-type="indexterm" id="idm45251596591432"/><a contenteditable="false" data-primary="sum method" data-type="indexterm" id="idm45251596590328"/>The <code>sum</code> and <code>product</code> methods compute the sum or product of the iterator’s items, which must be integers or floating-point numbers:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">triangle</code><code class="p">(</code><code class="n">n</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">).</code><code class="n">sum</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">triangle</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code><code class="w"> </code><code class="mi">210</code><code class="p">);</code><code class="w"/>

<code class="k">fn</code> <code class="nf">factorial</code><code class="p">(</code><code class="n">n</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">).</code><code class="n">product</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">factorial</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code><code class="w"> </code><code class="mi">2432902008176640000</code><code class="p">);</code><code class="w"/></pre>
<p>(You can extend <code>sum</code> and <code>product</code> to work with other types by implementing the <code>std::iter::Sum</code> and <code>std::iter::Product</code> traits, which we won’t describe in this book.)</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="max, min"><div class="sect2" id="max-min">
<h2>max, min</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="min and max methods" data-type="indexterm" id="idm45251596366584"/><a contenteditable="false" data-primary="max method" data-type="indexterm" id="idm45251596364984"/><a contenteditable="false" data-primary="min method" data-type="indexterm" id="idm45251596363880"/>The <code>min</code> and <code>max</code> methods on <code>Iterator</code> return the least or greatest item the iterator produces. The iterator’s item type must implement <code>std::cmp::Ord</code>, so that items can be compared with one another. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">([</code><code class="o">-</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">5</code><code class="p">].</code><code class="n">iter</code><code class="p">().</code><code class="n">max</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">1</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">([</code><code class="o">-</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">5</code><code class="p">].</code><code class="n">iter</code><code class="p">().</code><code class="n">min</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;-</code><code class="mi">5</code><code class="p">));</code><code class="w"/></pre>
<p>These methods return an <code>Option&lt;Self::Item&gt;</code>, so that they can return <code>None</code> if the iterator produces no items.</p>
<p>As explained in <a data-type="xref" href="ch12.xhtml#eq">“Equality Tests”</a>, Rust’s floating-point types <code>f32</code> and <code>f64</code> implement only <code>std::cmp::PartialOrd</code>, not <code>std::cmp::Ord</code>, so you can’t use the <code>min</code> and <code>max</code> methods to compute the least or greatest of a sequence of floating-point numbers. This is not a popular aspect of Rust’s design, but it is deliberate: it’s not clear what such functions should do with IEEE NaN values. Simply ignoring them would risk masking more serious problems in the code.</p>
<p>If you know how you would like to handle NaN values, you can use the <code>max_by</code> and <code>min_by</code> iterator methods instead, which let you supply your own comparison function.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="max_by, min_by"><div class="sect2" id="max_by-min_by">
<h2>max_by, min_by</h2>

<p><a contenteditable="false" data-primary="concurrency/concurrent programming" data-secondary="max_by and min_by methods" data-type="indexterm" id="idm45251596247704"/><a contenteditable="false" data-primary="max_by method" data-type="indexterm" id="idm45251596246392"/><a contenteditable="false" data-primary="min_by method" data-type="indexterm" id="idm45251596245288"/>The <code>max_by</code> and <code>min_by</code> methods return the maximum or minimum item the iterator produces, as determined by a comparison function you provide:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="p">{</code><code class="nb">PartialOrd</code><code class="p">,</code><code class="w"> </code><code class="n">Ordering</code><code class="p">};</code><code class="w"/>

<code class="c1">// Compare two f64 values. Panic if given a NaN.</code>
<code class="k">fn</code> <code class="nf">cmp</code><code class="p">(</code><code class="n">lhs</code>: <code class="kp">&amp;&amp;</code><code class="kt">f64</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="kp">&amp;&amp;</code><code class="kt">f64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Ordering</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">lhs</code><code class="p">.</code><code class="n">partial_cmp</code><code class="p">(</code><code class="n">rhs</code><code class="p">).</code><code class="n">unwrap</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">4.0</code><code class="p">,</code><code class="w"> </code><code class="mf">2.0</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">numbers</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">max_by</code><code class="p">(</code><code class="n">cmp</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mf">4.0</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">numbers</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">min_by</code><code class="p">(</code><code class="n">cmp</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mf">1.0</code><code class="p">));</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">4.0</code><code class="p">,</code><code class="w"> </code><code class="n">std</code>::<code class="kt">f64</code>::<code class="n">NAN</code><code class="p">,</code><code class="w"> </code><code class="mf">2.0</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">numbers</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">max_by</code><code class="p">(</code><code class="n">cmp</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mf">4.0</code><code class="p">));</code><code class="w"> </code><code class="c1">// panics</code></pre>
<p>(The double references in <code>cmp</code>’s parameters arise because <code>numbers.iter()</code> produces references to the elements, and then <code>max_by</code> and <code>min_by</code> pass the closure references to the iterator’s items.)</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="max_by_key, min_by_key"><div class="sect2" id="max_by_key-min_by_key">
<h2>max_by_key, min_by_key</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="max_by_key and min_by_key methods" data-type="indexterm" id="idm45251596086392"/><a contenteditable="false" data-primary="max_by_key method" data-type="indexterm" id="idm45251596084824"/><a contenteditable="false" data-primary="min_by_key method" data-type="indexterm" id="idm45251596083720"/>The <code>max_by_key</code> and <code>min_by_key</code> methods on <code>Iterator</code> let you select the maximum or minimum item as determined by a closure applied to each item. The closure can select some field of the item, or perform a computation on the items. Since you’re often interested in data associated with some minimum or maximum, not just the extremum itself, these functions are often more useful than <code>min</code> and <code>max</code>. Their signatures are as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">min_by_key</code><code class="o">&lt;</code><code class="n">B</code>: <code class="nb">Ord</code><code class="p">,</code><code class="w"> </code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">B</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">max_by_key</code><code class="o">&lt;</code><code class="n">B</code>: <code class="nb">Ord</code><code class="p">,</code><code class="w"> </code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">B</code><code class="p">;</code><code class="w"/></pre>
<p>That is, given a closure that takes an item and returns any ordered type <code>B</code>, return the item for which the closure returned the maximum or minimum <code>B</code>, or <code>None</code> if no items were produced.</p>
<p>For example, if you need to scan a hash table of cities to find the cities with the largest and smallest populations, you could write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">HashMap</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">populations</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashMap</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">populations</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Portland"</code><code class="p">,</code><code class="w">  </code><code class="mi">583_776</code><code class="p">);</code><code class="w"/>
<code class="n">populations</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Fossil"</code><code class="p">,</code><code class="w">        </code><code class="mi">449</code><code class="p">);</code><code class="w"/>
<code class="n">populations</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Greenhorn"</code><code class="p">,</code><code class="w">       </code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="n">populations</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Boring"</code><code class="p">,</code><code class="w">      </code><code class="mi">7_762</code><code class="p">);</code><code class="w"/>
<code class="n">populations</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"The Dalles"</code><code class="p">,</code><code class="w"> </code><code class="mi">15_340</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">populations</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">max_by_key</code><code class="p">(</code><code class="o">|&amp;</code><code class="p">(</code><code class="n">_name</code><code class="p">,</code><code class="w"> </code><code class="n">pop</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">pop</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="nb">Some</code><code class="p">((</code><code class="o">&amp;</code><code class="s">"Portland"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="mi">583_776</code><code class="p">)));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">populations</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">min_by_key</code><code class="p">(</code><code class="o">|&amp;</code><code class="p">(</code><code class="n">_name</code><code class="p">,</code><code class="w"> </code><code class="n">pop</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">pop</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="nb">Some</code><code class="p">((</code><code class="o">&amp;</code><code class="s">"Greenhorn"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="mi">2</code><code class="p">)));</code><code class="w"/></pre>
<p>The closure <code>|&amp;(_name, pop)| pop</code> gets applied to each item the iterator produces, and returns the value to use for comparison—in this case, the city’s population. The value returned is the entire item, not just the value the closure returns. (Naturally, if you were making queries like this often, you’d probably want to arrange for a more efficient way to find the entries than making a linear search through the table.)</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Comparing Item Sequences"><div class="sect2" id="comparing-item-sequences">
<h2>Comparing Item Sequences</h2>

<p><a contenteditable="false" data-primary="comparison operators" data-secondary="with iterators" data-type="indexterm" id="idm45251595768376"/><a contenteditable="false" data-primary="consuming iterators" data-secondary="comparing item sequences" data-type="indexterm" id="idm45251595766776"/>You can use the <code>&lt;</code> and <code>==</code> operators to compare strings, vectors, and slices, assuming their individual elements can be compared. Although iterators do not support Rust’s comparison operators, they do provide methods like <code>eq</code> and <code>lt</code> that do the same job, drawing pairs of items from the iterators and comparing them until a decision can be reached. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">packed</code><code class="w"> </code><code class="o">=</code><code class="w">  </code><code class="s">"Helen of Troy"</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">spaced</code><code class="w"> </code><code class="o">=</code><code class="w">  </code><code class="s">"Helen   of    Troy"</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">obscure</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Helen of Sandusky"</code><code class="p">;</code><code class="w"> </code><code class="c1">// nice person, just not famous</code>

<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">packed</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="n">spaced</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">packed</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">().</code><code class="n">eq</code><code class="p">(</code><code class="n">spaced</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">()));</code><code class="w"/>

<code class="c1">// This is true because ' ' &lt; 'o'.</code>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">spaced</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">obscure</code><code class="p">);</code><code class="w"/>

<code class="c1">// This is true because 'Troy' &gt; 'Sandusky'.</code>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">spaced</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">().</code><code class="n">gt</code><code class="p">(</code><code class="n">obscure</code><code class="p">.</code><code class="n">split_whitespace</code><code class="p">()));</code><code class="w"/></pre>
<p>The calls to <code>split_whitespace</code> return iterators over the whitespace-separated words of the string. Using the <code>eq</code> and <code>gt</code> methods on these iterators performs a word-by-word comparison, instead of a character-by-character comparison. These are all possible because <code>&amp;str</code> implements <code>PartialOrd</code> and <code>PartialEq</code>.</p>
<p>Iterators provide the <code>eq</code> and <code>ne</code> methods for equality comparisons, and <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> methods for ordered comparisons. The <code>cmp</code> and <code>partial_cmp</code> methods behave like the corresponding methods of the <code>Ord</code> and <code>PartialOrd</code> traits.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="any and all"><div class="sect2" id="any-and-all">
<h2>any and all</h2>

<p><a contenteditable="false" data-primary="all method" data-type="indexterm" id="idm45251595719256"/><a contenteditable="false" data-primary="any method" data-type="indexterm" id="idm45251595717928"/><a contenteditable="false" data-primary="consuming iterators" data-secondary="and all methods" data-type="indexterm" id="idm45251595716824"/>The <code>any</code> and <code>all</code> methods apply a closure to each item the iterator produces, and return <code>true</code> if the closure returns <code>true</code> for any item, or for all the items:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">id</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Iterator"</code><code class="p">;</code><code class="w"/>

<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="w"> </code><code class="n">id</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">any</code><code class="p">(</code><code class="n">char</code>::<code class="n">is_uppercase</code><code class="p">));</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">!</code><code class="n">id</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">all</code><code class="p">(</code><code class="n">char</code>::<code class="n">is_uppercase</code><code class="p">));</code><code class="w"/></pre>
<p>These methods consume only as many items as they need to determine the answer. For example, if the closure ever returns <code>true</code> for a given item, then <code>any</code> returns <code>true</code> immediately, without drawing any more items from the iterator.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="position, rposition, and ExactSizeIterator"><div class="sect2" id="position-rposition-and-exactsizeiterator">
<h2>position, rposition, and ExactSizeIterator</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="position, rposition, and ExactSizeIterator" data-type="indexterm" id="idm45251595522312"/><a contenteditable="false" data-primary="position method" data-type="indexterm" id="idm45251595520616"/>The <code>position</code> method applies a closure to each item from the iterator and returns the index of the first item for which the closure returns <code>true</code>. More precisely, it returns an <code>Option</code> of the index: if the closure returns <code>true</code> for no item, <code>position</code> returns <code>None</code>. It stops drawing items as soon as the closure returns <code>true</code>. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Xerxes"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">text</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">position</code><code class="p">(</code><code class="o">|</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">'e'</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">text</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">position</code><code class="p">(</code><code class="o">|</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">'z'</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="rposition method" data-type="indexterm" id="idm45251595684280"/>The <code>rposition</code> method is the same, except that it searches from the right. For <span class="keep-together">example:</span></p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"Xerxes"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">bytes</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">rposition</code><code class="p">(</code><code class="o">|&amp;</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">b'e'</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">4</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">bytes</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">rposition</code><code class="p">(</code><code class="o">|&amp;</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">b'X'</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code><code class="w"/></pre>
<p>The <code>rposition</code> method requires a reversible iterator, so that it can draw items from the right end of the sequence. It also requires an exact-size iterator, so that it can assign indices the same way <code>position</code> would, starting with <code>0</code> at the left. <a contenteditable="false" data-primary="ExactSizeIterator trait" data-type="indexterm" id="idm45251595385096"/>An exact-size iterator is one that implements the <code>std::iter::ExactSizeIterator</code> trait:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="nb">ExactSizeIterator</code>: <code class="nb">Iterator</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">len</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">is_empty</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>len</code> method returns the number of items remaining, and the <code>is_empty</code> method returns <code>true</code> if iteration is complete.</p>
<p>Naturally, not every iterator knows how many items it will produce in advance; in the preceding examples, the <code>chars</code> iterator on <code>&amp;str</code> does not (UTF-8 is a variable-width encoding), so you can’t use <code>rposition</code> on strings. But an iterator over an array of bytes certainly knows the array’s length, so it can implement <code>ExactSizeIterator</code>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="fold"><div class="sect2" id="fold">
<h2>fold</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="fold method" data-type="indexterm" id="idm45251595363128"/><a contenteditable="false" data-primary="fold method" data-type="indexterm" id="idm45251595302664"/>The <code>fold</code> method is a very general tool for accumulating some sort of result over the entire sequence of items an iterator produces. Given an initial value, which we’ll call the <em>accumulator</em>, and a closure, <code>fold</code> repeatedly applies the closure to the current accumulator and the next item from the iterator. The value the closure returns is taken as the new accumulator, to be passed to the closure with the next item. The final accumulator value is what <code>fold</code> itself returns. If the sequence is empty, <code>fold</code> simply returns the initial accumulator.</p>
<p>Many of the other methods for consuming an iterator’s values can be written as uses of <code>fold</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">];</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">fold</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">n</code><code class="p">,</code><code class="w"> </code><code class="n">_</code><code class="o">|</code><code class="w"> </code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">),</code><code class="w"> </code><code class="mi">6</code><code class="p">);</code><code class="w">        </code><code class="c1">// count</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">fold</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">n</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">n</code><code class="o">+</code><code class="n">i</code><code class="p">),</code><code class="w"> </code><code class="mi">45</code><code class="p">);</code><code class="w">       </code><code class="c1">// sum</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">fold</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">n</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">n</code><code class="o">*</code><code class="n">i</code><code class="p">),</code><code class="w"> </code><code class="mi">151200</code><code class="p">);</code><code class="w">   </code><code class="c1">// product</code>

<code class="c1">// max</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">fold</code><code class="p">(</code><code class="kt">i32</code>::<code class="n">min_value</code><code class="p">(),</code><code class="w"> </code><code class="o">|</code><code class="n">m</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="n">max</code><code class="p">(</code><code class="n">m</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">)),</code><code class="w"/>
<code class="w">           </code><code class="mi">10</code><code class="p">);</code><code class="w"/></pre>
<p>The <code>fold</code> method’s signature is as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">fold</code><code class="o">&lt;</code><code class="n">A</code><code class="p">,</code><code class="w"> </code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">init</code>: <code class="nc">A</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">A</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="n">A</code><code class="p">,</code><code class="w"> </code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">A</code><code class="p">;</code><code class="w"/></pre>
<p>Here, <code>A</code> is the accumulator type. The <code>init</code> argument is an <code>A</code>, as is the closure’s first argument and return value, and the return value of <code>fold</code> itself.</p>
<p>Note that the accumulator values are moved into and out of the closure, so you can use <code>fold</code> with non-<code>Copy</code> accumulator types:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s">"Pack "</code><code class="p">,</code><code class="w"> </code><code class="s">"my "</code><code class="p">,</code><code class="w"> </code><code class="s">"box "</code><code class="p">,</code><code class="w"> </code><code class="s">"with "</code><code class="p">,</code><code class="w"/>
<code class="w">         </code><code class="s">"five "</code><code class="p">,</code><code class="w"> </code><code class="s">"dozen "</code><code class="p">,</code><code class="w"> </code><code class="s">"liquor "</code><code class="p">,</code><code class="w"> </code><code class="s">"jugs"</code><code class="p">];</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">pangram</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">a</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">fold</code><code class="p">(</code><code class="nb">String</code>::<code class="n">new</code><code class="p">(),</code><code class="w"/>
<code class="w">                            </code><code class="o">|</code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">w</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">push_str</code><code class="p">(</code><code class="n">w</code><code class="p">);</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="p">});</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">pangram</code><code class="p">,</code><code class="w"> </code><code class="s">"Pack my box with five dozen liquor jugs"</code><code class="p">);</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="nth"><div class="sect2" id="nth">
<h2>nth</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="nth method" data-type="indexterm" id="idm45251594929720"/><a contenteditable="false" data-primary="nth method" data-type="indexterm" id="idm45251594928152"/>The <code>nth</code> method takes an index <code>n</code>, skips that many items from the iterator, and returns the next item, or <code>None</code> if the sequence ends before that point. Calling <code>.nth(0)</code> is equivalent to <code>.next()</code>.</p>
<p>It doesn’t take ownership of the iterator the way an adapter would, so you can call it many times.</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">..</code><code class="mi">10</code><code class="p">).</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">i</code><code class="o">*</code><code class="n">i</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">squares</code><code class="p">.</code><code class="n">nth</code><code class="p">(</code><code class="mi">4</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">16</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">squares</code><code class="p">.</code><code class="n">nth</code><code class="p">(</code><code class="mi">0</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">25</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">squares</code><code class="p">.</code><code class="n">nth</code><code class="p">(</code><code class="mi">6</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
<p>Its signature is shown here:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">nth</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">n</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">;</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="last"><div class="sect2" id="last">
<h2>last</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="last method" data-type="indexterm" id="idm45251594814024"/><a contenteditable="false" data-primary="last method" data-type="indexterm" id="idm45251594812424"/>The <code>last</code> method consumes items until the iterator returns <code>None</code>, and then returns the last item. If the iterator produces no items, then <code>last</code> returns <code>None</code>. Its signature is as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">last</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/></pre>
<p>For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">..</code><code class="mi">10</code><code class="p">).</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">i</code><code class="o">*</code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">squares</code><code class="p">.</code><code class="n">last</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">81</code><code class="p">));</code><code class="w"/></pre>
<p>This consumes all the iterator’s items starting from the front, even if the iterator is reversible. If you have a reversible iterator and don’t need to consume all its items, you should instead just write <code>iter.rev().next()</code>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="find"><div class="sect2" id="find">
<h2>find</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="find method" data-type="indexterm" id="idm45251594665880"/><a contenteditable="false" data-primary="find method" data-type="indexterm" id="idm45251594664504"/>The <code>find</code> method draws items from an iterator, returning the first item for which the given closure returns <code>true</code>, or <code>None</code> if the sequence ends before a suitable item is found. Its signature is:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">find</code><code class="o">&lt;</code><code class="n">P</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">predicate</code>: <code class="nc">P</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="n">P</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code><code class="p">;</code><code class="w"/></pre>
<p>For example, using the table of cities and populations from <a data-type="xref" href="#max_by_key-min_by_key">“max_by_key, min_by_key”</a>, you could write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">populations</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">find</code><code class="p">(</code><code class="o">|&amp;</code><code class="p">(</code><code class="n">_name</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">pop</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">pop</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">1_000_000</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">populations</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">find</code><code class="p">(</code><code class="o">|&amp;</code><code class="p">(</code><code class="n">_name</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">pop</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">pop</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">500_000</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="nb">Some</code><code class="p">((</code><code class="o">&amp;</code><code class="s">"Portland"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="mi">583_776</code><code class="p">)));</code><code class="w"/></pre>
<p>None of the cities in the table have a population above a million, but there is one city with half a million people.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Building Collections: collect and FromIterator"><div class="sect2" id="building-collections-collect-and-fromiterator">
<h2>Building Collections: collect and FromIterator</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="collect method" data-type="indexterm" id="idm45251594487032"/>Throughout the book, we’ve been using the <code>collect</code> method to build vectors holding an iterator’s items. For example, in <a data-type="xref" href="ch02.xhtml#a-tour-of-rust">Chapter 2</a>, we called <code>std::env::args()</code> to get an iterator over the program’s command-line arguments, and then called that iterator’s <code>collect</code> method to gather them into a vector:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">args</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">collect</code><code class="p">();</code><code class="w"/></pre>
<p>But <code>collect</code> isn’t specific to vectors: in fact, it can build any kind of collection from Rust’s standard library, as long as the iterator produces a suitable item type:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="p">{</code><code class="n">HashSet</code><code class="p">,</code><code class="w"> </code><code class="n">BTreeSet</code><code class="p">,</code><code class="w"> </code><code class="n">LinkedList</code><code class="p">,</code><code class="w"> </code><code class="n">HashMap</code><code class="p">,</code><code class="w"> </code><code class="n">BTreeMap</code><code class="p">};</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">args</code>: <code class="nc">HashSet</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">args</code>: <code class="nc">BTreeSet</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">args</code>: <code class="nc">LinkedList</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">collect</code><code class="p">();</code><code class="w"/>

<code class="c1">// Collecting a map requires (key, value) pairs, so for this example,</code>
<code class="c1">// zip the sequence of strings with a sequence of integers.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">args</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">zip</code><code class="p">(</code><code class="mi">0</code><code class="p">..).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">args</code>: <code class="nc">BTreeMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">zip</code><code class="p">(</code><code class="mi">0</code><code class="p">..).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>

<code class="c1">// and so on</code></pre>
<p>Naturally, <code>collect</code> itself doesn’t know how to construct all these types. <a contenteditable="false" data-primary="consuming iterators" data-secondary="FromIterator trait" data-type="indexterm" id="idm45251594461832"/>Rather, when some collection type like <code>Vec</code> or <code>HashMap</code> knows how to construct itself from an iterator, it implements the <code>std::iter::FromIterator</code> trait, for which <code>collect</code> is just a convenient veneer:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">FromIterator</code><code class="o">&lt;</code><code class="n">A</code><code class="o">&gt;</code>: <code class="nb">Sized</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from_iter</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nb">IntoIterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">A</code><code class="o">&gt;&gt;</code><code class="p">(</code><code class="n">iter</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If a collection type implements <code>FromIterator&lt;A&gt;</code>, then its static method <code>from_iter</code> builds a value of that type from an iterable producing items of type <code>A</code>.</p>
<p>In the simplest case, the implementation could simply construct an empty collection, and then add the items from the iterator one by one. For example, <code>std::collections::LinkedList</code>’s implementation of <code>FromIterator</code> works this way.</p>
<p>However, some types can do better than that. For example, constructing a vector from some iterator <code>iter</code> could be as simple as:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">vec</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">item</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">vec</code><code class="w"/></pre>
<p>But this isn’t ideal: as the vector grows, it may need to expand its buffer, requiring a call to the heap allocator and a copy of the extant elements. Vectors do take algorithmic measures to keep this overhead low, but if there were some way to simply allocate an initial buffer of the right size to begin with, there would be no need to resize at all.</p>
<p><a contenteditable="false" data-primary="size_hint method" data-type="indexterm" id="idm45251594148216"/>This is where the <code>Iterator</code> trait’s <code>size_hint</code> method comes in:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Iterator</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">size_hint</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nb">None</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This method returns a lower bound and optional upper bound on the number of items the iterator will produce. The default definition returns zero as the lower bound and declines to name an upper bound, saying, in effect, “I have no idea,” but many iterators can do better than this. An iterator over a <code>Range</code>, for example, knows exactly how many items it will produce, as does an iterator over a <code>Vec</code> or <code>HashMap</code>. Such iterators provide their own specialized definitions for <code>size_hint</code>.</p>
<p>These bounds are exactly the information that <code>Vec</code>’s implementation of <code>FromIterator</code> needs to size the new vector’s buffer correctly from the start. Insertions still check that the buffer is large enough, so even if the hint is incorrect, only performance is affected, not safety. Other types can take similar steps: for example, <code>HashSet</code> and <code>HashMap</code> also use <code>Iterator::size_hint</code> to choose an appropriate initial size for their hash table.</p>
<p>One note about type inference: at the top of this section, it’s a bit strange to see the same call, <code>std::env::args().collect()</code>, produce four different kinds of collections depending on its context. The return type of <code>collect</code> is its type parameter, so the first two calls are equivalent to the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;&gt;</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="n">HashSet</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;&gt;</code><code class="p">();</code><code class="w"/></pre>
<p>But as long as there’s only one type that could possibly work as <code>collect</code>’s argument, Rust’s type inference will supply it for you. When you spell out the type of <code>args</code>, you ensure this is the case.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="The Extend Trait"><div class="sect2" id="the-extend-trait">
<h2>The Extend Trait</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="Extend trait" data-type="indexterm" id="idm45251594015224"/><a contenteditable="false" data-primary="Extend trait" data-type="indexterm" id="idm45251594013848"/>If a type implements the <code>std::iter::Extend</code> trait, then its <code>extend</code> method adds an iterable’s items to the collection:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">..</code><code class="mi">5</code><code class="p">).</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">i</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">v</code><code class="p">.</code><code class="n">extend</code><code class="p">(</code><code class="o">&amp;</code><code class="p">[</code><code class="mi">31</code><code class="p">,</code><code class="w"> </code><code class="mi">57</code><code class="p">,</code><code class="w"> </code><code class="mi">99</code><code class="p">,</code><code class="w"> </code><code class="mi">163</code><code class="p">]);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">16</code><code class="p">,</code><code class="w"> </code><code class="mi">31</code><code class="p">,</code><code class="w"> </code><code class="mi">57</code><code class="p">,</code><code class="w"> </code><code class="mi">99</code><code class="p">,</code><code class="w"> </code><code class="mi">163</code><code class="p">]);</code><code class="w"/></pre>
<p>All of the standard collections implement <code>Extend</code>, so they all have this method; so does <code>String</code>. Arrays and slices, which have a fixed length, do not.</p>
<p>The trait’s definition is as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Extend</code><code class="o">&lt;</code><code class="n">A</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">extend</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">iter</code>: <code class="nc">T</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nb">IntoIterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">A</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Obviously, this is very similar to <code>std::iter::FromIterator</code>: that creates a new collection, whereas <code>Extend</code> extends an existing collection. In fact, several implementations of <code>FromIterator</code> in the standard library simply create a new empty collection, and then call <code>extend</code> to populate it. For example, the implementation of <code>FromIterator</code> for <code>std::collections::LinkedList</code> works this way:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">FromIterator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">LinkedList</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from_iter</code><code class="o">&lt;</code><code class="n">I</code>: <code class="nb">IntoIterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="p">(</code><code class="n">iter</code>: <code class="nc">I</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Self</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">list</code><code class="p">.</code><code class="n">extend</code><code class="p">(</code><code class="n">iter</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">list</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="partition"><div class="sect2" id="partition">
<h2>partition</h2>

<p><a contenteditable="false" data-primary="consuming iterators" data-secondary="partition method" data-type="indexterm" id="idm45251593728680"/><a contenteditable="false" data-primary="partition method" data-type="indexterm" id="idm45251593727304"/>The <code>partition</code> method divides an iterator’s items among two collections, using a closure to decide where each item belongs:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">things</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s">"doorknob"</code><code class="p">,</code><code class="w"> </code><code class="s">"mushroom"</code><code class="p">,</code><code class="w"> </code><code class="s">"noodle"</code><code class="p">,</code><code class="w"> </code><code class="s">"giraffe"</code><code class="p">,</code><code class="w"> </code><code class="s">"grapefruit"</code><code class="p">];</code><code class="w"/>

<code class="c1">// Amazing fact: the name of a living thing always starts with an</code>
<code class="c1">// odd-numbered letter.</code>
<code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">living</code><code class="p">,</code><code class="w"> </code><code class="n">nonliving</code><code class="p">)</code>: <code class="p">(</code><code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="o">=</code><code class="w"> </code><code class="n">things</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">partition</code><code class="p">(</code><code class="o">|</code><code class="n">name</code><code class="o">|</code><code class="w"> </code><code class="n">name</code><code class="p">.</code><code class="n">as_bytes</code><code class="p">()[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">living</code><code class="p">,</code><code class="w">    </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"mushroom"</code><code class="p">,</code><code class="w"> </code><code class="s">"giraffe"</code><code class="p">,</code><code class="w"> </code><code class="s">"grapefruit"</code><code class="p">]);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">nonliving</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"doorknob"</code><code class="p">,</code><code class="w"> </code><code class="s">"noodle"</code><code class="p">]);</code><code class="w"/></pre>

<p>Like <code>collect</code>, <code>partition</code> can make any sort of collections you like, although both must be of the same type. And like <code>collect</code>, you’ll need to specify the return type: the preceding example writes out the type of <code>living</code> and <code>nonliving</code>, and lets type inference choose the right type parameters for the call to <code>partition</code>.</p>

<p>The signature of <code>partition</code> is as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">partition</code><code class="o">&lt;</code><code class="n">B</code><code class="p">,</code><code class="w"> </code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="n">B</code><code class="p">,</code><code class="w"> </code><code class="n">B</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">Self</code>: <code class="nb">Sized</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="n">B</code>: <code class="nb">Default</code> <code class="o">+</code><code class="w"> </code><code class="nb">Extend</code><code class="o">&lt;</code><code class="n">Self</code>::<code class="n">Item</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Self</code>::<code class="n">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code><code class="p">;</code><code class="w"/></pre>
<p>Whereas <code>collect</code> requires its result type to implement <code>FromIterator</code>, <code>partition</code> instead requires <code>std::default::Default</code>, which all Rust collections implement by returning an empty collection, and <code>std::default::Extend</code>.</p>
<p>Why doesn’t <code>partition</code> just split the iterator into two iterators, instead of building two collections? One reason is that items drawn from the underlying iterator but not yet drawn from the appropriate partitioned iterator would need to be buffered somewhere; you would end up building a collection of some sort internally, anyway. But the more fundamental reason has to do with safety. Partitioning one iterator into two would require the two partitions to share the same underlying iterator. Iterators must be mutable to be used; so the underlying iterator would necessarily be shared, mutable state, which Rust’s safety depends on avoiding.<a contenteditable="false" data-primary="" data-startref="C15-iterators.html22" data-type="indexterm" id="idm45251593433640"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html21" data-type="indexterm" id="idm45251593572184"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Implementing Your Own Iterators"><div class="sect1" id="implementing-your-own-iterators">
<h1>Implementing Your Own Iterators</h1>

<p><a contenteditable="false" data-primary="IntoIterator trait" data-secondary="implementing for your own types" data-type="indexterm" id="C15-iterators.html23"/><a contenteditable="false" data-primary="Iterator trait" data-secondary="implementing for your own types" data-type="indexterm" id="C15-iterators.html24"/><a contenteditable="false" data-primary="iterators" data-secondary="implementing for your own types" data-type="indexterm" id="C15-iterators.html25"/>You can implement the <code>IntoIterator</code> and <code>Iterator</code> traits for your own types, making all the adapters and consumers shown in this chapter available for use, along with lots of other library and crate code written to work with the standard iterator interface. In this section, we’ll show a simple iterator over a range type, and then a more complex iterator over a binary tree type.</p>
<p>Suppose we have the following range type (simplified from the standard library’s <code>std::ops::Range&lt;T&gt;</code> type):</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">I32Range</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">start</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">end</code>: <code class="kt">i32</code>
<code class="p">}</code><code class="w"/></pre>
<p>Iterating over an <code>I32Range</code> requires two pieces of state: the current value, and the limit at which the iteration should end. This happens to be a nice fit for the <code>I32Range</code> type itself, using <code>start</code> as the next value, and <code>end</code> as the limit. So you can implement <code>Iterator</code> like so:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="nb">Iterator</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">I32Range</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">i32</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">next</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nb">None</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">start</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">result</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This iterator produces <code>i32</code> items, so that’s the <code>Item</code> type. If the iteration is complete, <code>next</code> returns <code>None</code>; otherwise, it produces the next value, and updates its state to prepare for the next call.</p>
<p>Of course, a <code>for</code> loop uses <code>IntoIterator::into_iter</code> to convert its operand into an iterator. But the standard library provides a blanket implementation of <code>IntoIterator</code> for every type that implements <code>Iterator</code>, so <code>I32Range</code> is ready for use:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">pi</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0.0</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">numerator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1.0</code><code class="p">;</code><code class="w"/>

<code class="k">for</code><code class="w"> </code><code class="n">k</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="p">(</code><code class="n">I32Range</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">start</code>: <code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">end</code>: <code class="mi">14</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">pi</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">numerator</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="p">(</code><code class="mi">2</code><code class="o">*</code><code class="n">k</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">f64</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">numerator</code><code class="w"> </code><code class="o">/=</code><code class="w"> </code><code class="o">-</code><code class="mf">3.0</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">pi</code><code class="w"> </code><code class="o">*=</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">sqrt</code><code class="p">(</code><code class="mf">12.0</code><code class="p">);</code><code class="w"/>

<code class="c1">// IEEE 754 specifies this result exactly.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">pi</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">f32</code><code class="p">,</code><code class="w"> </code><code class="n">std</code>::<code class="kt">f32</code>::<code class="n">consts</code>::<code class="n">PI</code><code class="p">);</code><code class="w"/></pre>
<p>But <code>I32Range</code> is a special case, in that the iterable and iterator are the same type. Many cases aren’t so simple. For example, here’s the binary tree type from <a data-type="xref" href="ch10.xhtml#enums-and-patterns">Chapter 10</a>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Empty</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code><code class="o">&lt;</code><code class="n">TreeNode</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">struct</code> <code class="nc">TreeNode</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">element</code>: <code class="nc">T</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">left</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">right</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The classic way to walk a binary tree is to recurse, using the stack of function calls to keep track of your place in the tree and the nodes yet to be visited. But when implementing <code>Iterator</code> for <code>BinaryTree&lt;T&gt;</code>, each call to <code>next</code> must produce exactly one value and return. To keep track of the tree nodes it has yet to produce, the iterator must maintain its own stack. Here’s one possible iterator type for <code>BinaryTree</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="bp">self</code>::<code class="n">BinaryTree</code>::<code class="o">*</code><code class="p">;</code><code class="w"/>

<code class="c1">// The state of an in-order traversal of a `BinaryTree`.</code>
<code class="k">struct</code> <code class="nc">TreeIter</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// A stack of references to tree nodes. Since we use `Vec`'s</code>
<code class="w">    </code><code class="c1">// `push` and `pop` methods, the top of the stack is the end of the</code>
<code class="w">    </code><code class="c1">// vector.</code>
<code class="w">    </code><code class="c1">//</code>
<code class="w">    </code><code class="c1">// The node the iterator will visit next is at the top of the stack,</code>
<code class="w">    </code><code class="c1">// with those ancestors still unvisited below it. If the stack is empty,</code>
<code class="w">    </code><code class="c1">// the iteration is over.</code>
<code class="w">    </code><code class="n">unvisited</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">TreeNode</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>It turns out that pushing the nodes running down the left edge of a subtree is a common operation, so we’ll define a method on <code>TreeIter</code> to do that:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="n">TreeIter</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">push_left_edge</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">tree</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">while</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="n">NonEmpty</code><code class="p">(</code><code class="k">ref</code><code class="w"> </code><code class="n">node</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">tree</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">unvisited</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">node</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">node</code><code class="p">.</code><code class="n">left</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>With this helper method in place, we can give <code>BinaryTree</code> an <code>iter</code> method that returns an iterator over the tree:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">iter</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">TreeIter</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">TreeIter</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">unvisited</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">        </code><code class="n">iter</code><code class="p">.</code><code class="n">push_left_edge</code><code class="p">(</code><code class="bp">self</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">iter</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>iter</code> method constructs an empty <code>TreeIter</code>, and then calls <code>push_left_edge</code> to set up the initial stack. The leftmost node ends up on the top, as required by the <code>unvisited</code> stack’s rules.</p>
<p>Following the standard library’s practices, we can then implement <code>IntoIterator</code> on a shared reference to a tree with a call to <code>BinaryTree::iter</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">IntoIterator</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">IntoIter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">TreeIter</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">into_iter</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">IntoIter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">iter</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>IntoIter</code> definition establishes <code>TreeIter</code> as the iterator type for a <code>&amp;BinaryTree</code>.</p>
<p>Finally, in the <code>Iterator</code> implementation, we get to actually walk the tree. Like <code>BinaryTree</code>’s <code>iter</code> method, the iterator’s <code>next</code> method is guided by the stack’s rules:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">Iterator</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">TreeIter</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">next</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Find the node this iteration must produce,</code>
<code class="w">        </code><code class="c1">// or finish the iteration.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">node</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">unvisited</code><code class="p">.</code><code class="n">pop</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="nb">None</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="nb">Some</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">n</code><code class="w"/>
<code class="w">        </code><code class="p">};</code><code class="w"/>

<code class="w">        </code><code class="c1">// The next node after this one is the leftmost child of</code>
<code class="w">        </code><code class="c1">// this node's right child, so push the path from here down.</code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">push_left_edge</code><code class="p">(</code><code class="o">&amp;</code><code class="n">node</code><code class="p">.</code><code class="n">right</code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="c1">// Produce a reference to this node's value.</code>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="n">node</code><code class="p">.</code><code class="n">element</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If the stack is empty, the iteration is complete. Otherwise, <code>node</code> is a reference to the node to visit now; this call will return a reference to its <code>element</code> field. But first, we must advance the iterator’s state to the next node. If this node has a right subtree, the next node to visit is the subtree’s leftmost node, and we can use <code>push_left_edge</code> to push it, and its unvisited ancestors, onto the stack. But if this node has no right subtree, <code>push_left_edge</code> has no effect, which is just what we want: we can count on the new top of the stack to be <code>node</code>’s first unvisited ancestor, if any.</p>
<p>With <code>IntoIterator</code> and <code>Iterator</code> implementations in place, we can finally use a <code>for</code> loop to iterate over a <code>BinaryTree</code> by reference:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">make_node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">left</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">element</code>: <code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="n">right</code>: <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="w"/>
<code class="w">           </code>-&gt; <code class="nc">BinaryTree</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">NonEmpty</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">TreeNode</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">left</code><code class="p">,</code><code class="w"> </code><code class="n">element</code><code class="p">,</code><code class="w"> </code><code class="n">right</code><code class="w"> </code><code class="p">}))</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Build a small tree.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">subtree_l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">make_node</code><code class="p">(</code><code class="n">Empty</code><code class="p">,</code><code class="w"> </code><code class="s">"mecha"</code><code class="p">,</code><code class="w"> </code><code class="n">Empty</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">subtree_rl</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">make_node</code><code class="p">(</code><code class="n">Empty</code><code class="p">,</code><code class="w"> </code><code class="s">"droid"</code><code class="p">,</code><code class="w"> </code><code class="n">Empty</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">subtree_r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">make_node</code><code class="p">(</code><code class="n">subtree_rl</code><code class="p">,</code><code class="w"> </code><code class="s">"robot"</code><code class="p">,</code><code class="w"> </code><code class="n">Empty</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">make_node</code><code class="p">(</code><code class="n">subtree_l</code><code class="p">,</code><code class="w"> </code><code class="s">"Jaeger"</code><code class="p">,</code><code class="w"> </code><code class="n">subtree_r</code><code class="p">);</code><code class="w"/>

<code class="c1">// Iterate over it.</code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">kind</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">tree</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="o">*</code><code class="n">kind</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="s">"mecha"</code><code class="p">,</code><code class="w"> </code><code class="s">"Jaeger"</code><code class="p">,</code><code class="w"> </code><code class="s">"droid"</code><code class="p">,</code><code class="w"> </code><code class="s">"robot"</code><code class="p">]);</code><code class="w"/></pre>
<p><a data-type="xref" href="#tree-iterator-figure">Figure 15-1</a> shows how the <code>unvisited</code> stack behaves as we iterate through a sample tree. At every step, the next node to be visited is at the top of the stack, with all its unvisited ancestors below it.</p>
<figure><div id="tree-iterator-figure" class="figure">
<img src="Images/rust_1501.png" alt="A tree of four nodes. The root is &quot;Jaeger&quot;, with left and right children &quot;mecha&quot; and &quot;robot&quot;. &quot;Robot&quot; has a left child, &quot;droid&quot;. Iterating over this tree takes the stack through five states: First stack, top to bottom: (mecha Jaeger). Second stack: (Jaeger). Third stack: (droid robot). Fourth stack: (robot). Fifth stack: empty." width="1489" height="995"/>
<h6><span class="label">Figure 15-1. </span>
Iterating over a binary tree
</h6>
</div></figure>
<p>All the usual iterator adapters and consumers are ready for use on our trees<a contenteditable="false" data-primary="" data-startref="C15-iterators.html25" data-type="indexterm" id="idm45251592274584"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html24" data-type="indexterm" id="idm45251592273208"/><a contenteditable="false" data-primary="" data-startref="C15-iterators.html23" data-type="indexterm" id="idm45251592271832"/>:<a contenteditable="false" data-primary="" data-startref="C15-iterators.html0" data-type="indexterm" id="idm45251592270328"/></p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">tree</code><code class="p">.</code><code class="n">iter</code><code class="p">()</code><code class="w"/>
<code class="w">           </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">name</code><code class="o">|</code><code class="w"> </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"mega-{}"</code><code class="p">,</code><code class="w"> </code><code class="n">name</code><code class="p">))</code><code class="w"/>
<code class="w">           </code><code class="p">.</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"mega-mecha"</code><code class="p">,</code><code class="w"> </code><code class="s">"mega-Jaeger"</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="s">"mega-droid"</code><code class="p">,</code><code class="w"> </code><code class="s">"mega-robot"</code><code class="p">]);</code><code class="w"/></pre>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45251600717960"><sup><a href="ch15.xhtml#idm45251600717960-marker">1</a></sup> Rust RFC 1522 will add syntax to the language very much like our <code>some Iterator</code> notation. As of Rust 1.17, it is not yet included in the language by default.</p><p data-type="footnote" id="idm45251600036616"><sup><a href="ch15.xhtml#idm45251600036616-marker">2</a></sup> In fact, since <code>Option</code> is an iterable behaving like a sequence of zero or one items, <code>iterator.filter_map​(closure)</code> is equivalent to <code>iterator.flat_map(closure)</code>, assuming <code>closure</code> returns an <code>Option&lt;T&gt;</code>.</p></div></div></section></div></body>
</html>