<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Unsafe Code"><div class="chapter" id="unsafe-code">
<h1><span class="label">Chapter 21. </span>Unsafe Code</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>Let no one think of me that I am humble or weak or passive;<br/>
Let them understand I am of a different kind:<br/>
dangerous to my enemies, loyal to my friends.<br/>
To such a life glory belongs.</p>

<p data-type="attribution">Euripides, <em>Medea</em></p>
</blockquote>

<p><a contenteditable="false" data-primary="unsafe code" data-type="indexterm" id="C21-unsafe.html0"/>The secret joy of systems programming is that, underneath every single safe language and carefully designed abstraction is a swirling maelstrom of wildly unsafe machine language and bit-fiddling. You can write that in Rust, too.</p>

<p>The language we’ve presented up to this point in the book ensures your programs are free of memory errors and data races entirely automatically, through types, lifetimes, bounds checks, and so on. But this sort of automated reasoning has its limits; there are many valuable techniques that Rust cannot recognize as safe.</p>

<p><em>Unsafe code</em> lets you tell Rust, “In this case, just trust me.” By marking off a block or function as unsafe, you acquire the ability to call <code>unsafe</code> functions in the standard library, dereference unsafe pointers, and call functions written in other languages like C and C++, among other powers. All of Rust’s usual safety checks still apply: type checks, lifetime checks, and bounds checks on indices all occur normally. Unsafe code just enables a small set of additional features.</p>

<p>This ability to step outside the boundaries of safe Rust is what makes it possible to implement many of Rust’s most fundamental features in Rust itself, as is commonly done in C and C++ systems. Unsafe code is what allows the <code>Vec</code> type to manage its buffer efficiently; the <code>std::io</code> module to talk to the operating system; and the <code>std::thread</code> and <code>std::sync</code> modules to provide concurrency primitives.</p>

<p class="pagebreak-before">This chapter covers the essentials of working with unsafe features:</p>

<ul>
	<li>
	<p>Rust’s <code>unsafe</code> blocks establish the boundary between ordinary, safe Rust code and code that uses unsafe features.</p>
	</li>
	<li>
	<p>You can mark functions as <code>unsafe</code>, alerting callers to the presence of extra contracts they must follow to avoid undefined behavior.</p>
	</li>
	<li>
	<p>Raw pointers and their methods allow unconstrained access to memory, and let you build data structures Rust’s type system would otherwise forbid.</p>
	</li>
	<li>
	<p>Understanding the definition of undefined behavior will help you appreciate why it can have consequences far more serious than just getting incorrect results.</p>
	</li>
	<li>
	<p>Rust’s foreign function interface lets you use libraries written in other languages.</p>
	</li>
	<li>
	<p>Unsafe traits, analogous to <code>unsafe</code> functions, impose a contract that each implementation (rather than each caller) must follow.</p>
	</li>
</ul>

<section data-type="sect1" data-pdf-bookmark="Unsafe from What?"><div class="sect1" id="unsafe-from-what">
<h1>Unsafe from What?</h1>

<p><a contenteditable="false" data-primary="unsafe code" data-secondary="incorrect use of" data-type="indexterm" id="idm45251566075880"/>At the start of this book, we showed a C program that crashes in a surprising way because it fails to follow one of the rules prescribed by the C standard. You can do the same in Rust:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cat crash.rs
<code class="go">fn main() {</code>
<code class="go">    let mut a: usize = 0;</code>
<code class="go">    let ptr = &amp;mut a as *mut usize;</code>
<code class="go">    unsafe {</code>
<code class="go">        *ptr.offset(3) = 0x7ffff72f484c;</code>
<code class="go">    }</code>
<code class="go">}</code>
<code class="gp">$</code> cargo build
<code class="go">   Compiling unsafe-samples v0.1.0</code>
<code class="go">    Finished debug [unoptimized + debuginfo] target(s) in 0.44 secs</code>
<code class="gp">$</code> ../../target/debug/crash
<code class="go">crash: Error: .netrc file is readable by others.</code>
<code class="go">crash: Remove password or make file unreadable by others.</code>
<code class="go">Segmentation fault (core dumped)</code>
<code class="gp">$</code></pre>

<p>This program borrows a mutable reference to the local variable <code>a</code>, casts it to a raw pointer of type <code>*mut usize</code>, and then uses the <a contenteditable="false" data-primary="offset method" data-type="indexterm" id="idm45251566057736"/><code>offset</code> method to produce a pointer three words further along in memory. This happens to be where <code>main</code>’s return address is stored. The program overwrites the return address with a constant, such that returning from <code>main</code> behaves in a surprising way. What makes this crash possible is the program’s incorrect use of unsafe features—in this case, the ability to dereference raw pointers.</p>

<p><a contenteditable="false" data-primary="contracts" data-secondary="unsafe features and" data-type="indexterm" id="idm45251566054856"/><a contenteditable="false" data-primary="undefined behavior" data-type="indexterm" id="idm45251566053480"/>An unsafe feature is one that imposes a <em>contract</em>: rules that Rust cannot enforce automatically, but which you must nonetheless follow to avoid <em>undefined behavior</em>.</p>

<p>A contract goes beyond the usual type checks and lifetime checks, imposing further rules specific to that unsafe feature. Typically, Rust itself doesn’t know about the contract at all; it’s just explained in the feature’s documentation. For example, the raw pointer type has a contract forbidding you to dereference a pointer that has been advanced beyond the end of its original referent. The expression <code>*ptr.offset(3) = ...</code> in this example breaks this contract. But, as the transcript shows, Rust compiles the program without complaint: its safety checks do not detect this violation. When you use unsafe features, you, as the programmer, bear the responsibility for checking that your code adheres to their contracts.</p>

<p>Lots of features have rules you should follow to use them correctly, but such rules are not contracts in the sense we mean here unless the possible consequences include undefined behavior. Undefined behavior is behavior Rust firmly assumes your code could never exhibit. For example, Rust assumes you will not overwrite a function call’s return address with something else. Code that passes Rust’s usual safety checks and complies with the contracts of the unsafe features it uses cannot possibly do such a thing. Since the program violates the raw pointer contract, its behavior is undefined, and it goes off the rails.</p>

<p>If your code exhibits undefined behavior, you have broken your half of your bargain with Rust, and Rust declines to predict the consequences. Dredging up irrelevant error messages from the depths of system libraries and crashing is one possible consequence; handing control of your computer over to an attacker is another. The effects could vary from one release of Rust to the next, without warning. Sometimes, however, undefined behavior has no visible consequences. For example, if the <code>main</code> function never returns (perhaps it calls <code>std::process::exit</code> to terminate the program early), then the corrupted return address probably won’t matter.</p>

<p>You may only use unsafe features within an <code>unsafe</code> block or an <code>unsafe</code> function; we’ll explain both in the sections that follow. This makes it harder to use unsafe features unknowingly: by forcing you to write an <code>unsafe</code> block or function, Rust makes sure you have acknowledged that your code may have additional rules to follow.</p>
</div></section><!--Unsafe from What?-->

<section data-type="sect1" data-pdf-bookmark="Unsafe Blocks"><div class="sect1" id="unsafe-blocks">
<h1>Unsafe Blocks</h1>

<p><a contenteditable="false" data-primary="blocks" data-secondary="unsafe" data-type="indexterm" id="C21-unsafe.html1"/><a contenteditable="false" data-primary="unsafe blocks" data-type="indexterm" id="C21-unsafe.html2"/><a contenteditable="false" data-primary="unsafe code" data-secondary="unsafe blocks" data-type="indexterm" id="C21-unsafe.html3"/>An <code>unsafe</code> block looks just like an ordinary Rust block preceded by the <code>unsafe</code> keyword, with the difference that you can use unsafe features in the block:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">String</code>::<code class="n">from_utf8_unchecked</code><code class="p">(</code><code class="n">ascii</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Without the <code>unsafe</code> keyword in front of the block, Rust would object to the use of <code>from_utf8_unchecked</code>, which is an <code>unsafe</code> function. With the <code>unsafe</code> block around it, you can use this code anywhere.</p>

<p>Like an ordinary Rust block, the value of an <code>unsafe</code> block is that of its final expression, or <code>()</code> if it doesn’t have one. The call to <code>String::from_utf8_unchecked</code> shown earlier provides the value of the block.</p>

<p>An <code>unsafe</code> block unlocks four additional options for you:</p>

<ul>
	<li>
	<p>You can call <code>unsafe</code> functions. Each <code>unsafe</code> function must specify its own contract, depending on its purpose.</p>
	</li>
	<li>
	<p>You can dereference raw pointers. Safe code can pass raw pointers around, compare them, and create them by conversion from references (or even from integers), but only unsafe code can actually use them to access memory. We’ll cover raw pointers in detail and explain how to use them safely in <a data-type="xref" href="#unsafe-code-raw-pointers">“Raw Pointers”</a>.</p>
	</li>
	<li>
	<p>You can access mutable <code>static</code> variables. As explained in <a data-type="xref" href="ch19.xhtml#global-variables">“Global Variables”</a>, Rust can’t be sure when threads are using mutable <code>static</code> variables, so their contract requires you to ensure all access is properly synchronized.</p>
	</li>
	<li>
	<p>You can access functions and variables declared through Rust’s foreign function interface. These are considered <code>unsafe</code> even when immutable, since they are visible to code written in other languages that may not respect Rust’s safety rules.</p>
	</li>
</ul>

<p>Restricting unsafe features to <code>unsafe</code> blocks doesn’t really prevent you from doing whatever you want. It’s perfectly possible to just stick an <code>unsafe</code> block into your code and move on. The benefit of the rule lies mainly in drawing human attention to code whose safety Rust can’t guarantee:</p>

<ul>
	<li>
	<p>You won’t accidentally use unsafe features, and then discover you were responsible for contracts you didn’t even know existed.</p>
	</li>
	<li>
	<p>An <code>unsafe</code> block attracts more attention from reviewers. Some projects even have automation to ensure this, flagging code changes that affect <code>unsafe</code> blocks for special attention.</p>
	</li>
	<li>
	<p>When you’re considering writing an <code>unsafe</code> block, you can take a moment to ask yourself whether your task really requires such measures. If it’s for performance, do you have measurements to show that this is actually a bottleneck? Perhaps there is a good way to accomplish the same thing in safe Rust.</p>
	</li>
</ul>

<section data-type="sect2" data-pdf-bookmark="Example: An Efficient ASCII String Type"><div class="sect2" id="example-an-efficient-ascii-string-type">
<h2>Example: An Efficient ASCII String Type</h2>

<p><a contenteditable="false" data-primary="Ascii string type" data-secondary="unsafe code for conversion into String" data-type="indexterm" id="C21-unsafe.html4"/><a contenteditable="false" data-primary="String types" data-secondary="Ascii" data-type="indexterm" id="C21-unsafe.html5"/><a contenteditable="false" data-primary="unsafe blocks" data-secondary="Ascii string type conversion" data-type="indexterm" id="C21-unsafe.html6"/>Here’s the definition of <code>Ascii</code>, a string type that ensures its contents are always valid ASCII. This type uses an unsafe feature to provide zero-cost conversion into <code>String</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">mod</code> <code class="nn">my_ascii</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ascii</code>::<code class="n">AsciiExt</code><code class="p">;</code><code class="w"> </code><code class="c1">// for u8::is_ascii</code>

<code class="w">    </code><code class="sd">/// An ASCII-encoded string.</code>
<code class="w">    </code><code class="cp">#[derive(Debug, Eq, PartialEq)]</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Ascii</code><code class="p">(</code><code class="w"/>
<code class="w">        </code><code class="c1">// This must hold only well-formed ASCII text:</code>
<code class="w">        </code><code class="c1">// bytes from `0` to `0x7f`.</code>
<code class="w">        </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="k">impl</code><code class="w"> </code><code class="n">Ascii</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="sd">/// Create an `Ascii` from the ASCII text in `bytes`. Return a</code>
<code class="w">        </code><code class="sd">/// `NotAsciiError` error if `bytes` contains any non-ASCII</code>
<code class="w">        </code><code class="sd">/// characters.</code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">from_bytes</code><code class="p">(</code><code class="n">bytes</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">Ascii</code><code class="p">,</code><code class="w"> </code><code class="n">NotAsciiError</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="n">bytes</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">any</code><code class="p">(</code><code class="o">|&amp;</code><code class="n">byte</code><code class="o">|</code><code class="w"> </code><code class="o">!</code><code class="n">byte</code><code class="p">.</code><code class="n">is_ascii</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">NotAsciiError</code><code class="p">(</code><code class="n">bytes</code><code class="p">));</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="nb">Ok</code><code class="p">(</code><code class="n">Ascii</code><code class="p">(</code><code class="n">bytes</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// When conversion fails, we give back the vector we couldn't convert.</code>
<code class="w">    </code><code class="c1">// This should implement `std::error::Error`; omitted for brevity.</code>
<code class="w">    </code><code class="cp">#[derive(Debug, Eq, PartialEq)]</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">NotAsciiError</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="c1">// Safe, efficient conversion, implemented using unsafe code.</code>
<code class="w">    </code><code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">Ascii</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="nb">String</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">ascii</code>: <code class="nc">Ascii</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// If this module has no bugs, this is safe, because</code>
<code class="w">            </code><code class="c1">// well-formed ASCII text is also well-formed UTF-8.</code>
<code class="w">            </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nb">String</code>::<code class="n">from_utf8_unchecked</code><code class="p">(</code><code class="n">ascii</code><code class="p">.</code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The key to this module is the definition of the <code>Ascii</code> type. The type itself is marked <code>pub</code>, to make it visible outside the <code>my_ascii</code> module. But the type’s <code>Vec&lt;u8&gt;</code> element is <em>not</em> public, so only the <code>my_ascii</code> module can construct an <code>Ascii</code> value or refer to its element. This leaves the module’s code in complete control over what may or may not appear there. As long as the public constructors and methods ensure that freshly created <code>Ascii</code> values are well-formed and remain so throughout their lives, then the rest of the program cannot violate that rule. And indeed, the public constructor <code>Ascii::from_bytes</code> carefully checks the vector it’s given before agreeing to construct an <code>Ascii</code> from it. For brevity’s sake, we don’t show any methods, but you can imagine a set of text-handling methods that ensure <code>Ascii</code> values always contain proper ASCII text, just as a <code>String</code>’s methods ensure that its contents remain well-formed UTF-8.</p>

<p>This arrangement lets us implement <code>From&lt;Ascii&gt;</code> for <code>String</code> very efficiently. The unsafe function <code>String::from_utf8_unchecked</code> takes a byte vector and builds a <code>String</code> from it without checking whether its contents are well-formed UTF-8 text; the function’s contract holds its caller responsible for that. Fortunately, the rules enforced by the <code>Ascii</code> type are exactly what we need to satisfy <code>from_utf8_unchecked</code>’s contract. As we explained in <a data-type="xref" href="ch17.xhtml#utf-8">“UTF-8”</a>, any block of ASCII text is also well-formed UTF-8, so an <code>Ascii</code>’s underlying <code>Vec&lt;u8&gt;</code> is immediately ready to serve as a <code>String</code>’s buffer.</p>

<p>With these definitions in place, you can write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">my_ascii</code>::<code class="n">Ascii</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">bytes</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"ASCII and ye shall receive"</code><code class="p">.</code><code class="n">to_vec</code><code class="p">();</code><code class="w"/>

<code class="c1">// This call entails no allocation or text copies, just a scan.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">ascii</code>: <code class="nc">Ascii</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Ascii</code>::<code class="n">from_bytes</code><code class="p">(</code><code class="n">bytes</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">unwrap</code><code class="p">();</code><code class="w"> </code><code class="c1">// We know these chosen bytes are ok.</code>

<code class="c1">// This call is zero-cost: no allocation, copies, or scans.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">string</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code>::<code class="n">from</code><code class="p">(</code><code class="n">ascii</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">string</code><code class="p">,</code><code class="w"> </code><code class="s">"ASCII and ye shall receive"</code><code class="p">);</code><code class="w"/></pre>

<p>No <code>unsafe</code> blocks are required to use <code>Ascii</code>. We have implemented a safe interface using unsafe operations, and arranged to meet their contracts depending only on the module’s own code, not on its users’ behavior.</p>

<p>An <code>Ascii</code> is nothing more than a wrapper around a <code>Vec&lt;u8&gt;</code>, hidden inside a module that enforces extra rules about its contents. A type of this sort is called a <em>newtype</em>, a common pattern in Rust. Rust’s own <code>String</code> type is defined in exactly the same way, except that its contents are restricted to be UTF-8, not ASCII. In fact, here’s the definition of <code>String</code> from the standard library:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nb">String</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">vec</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>At the machine level, with Rust’s types out of the picture, a newtype and its element have identical representations in memory, so constructing a newtype doesn’t require any machine instructions at all. In <code>Ascii::from_bytes</code>, the expression <code>Ascii(bytes)</code> simply deems the <code>Vec&lt;u8&gt;</code>’s representation to now hold an <code>Ascii</code> value. Similarly, <code>String::from_utf8_unchecked</code> probably requires no machine instructions when inlined: the <code>Vec&lt;u8&gt;</code> is now considered to be a <code>String</code><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html6" data-type="indexterm" id="idm45251565650584"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html5" data-type="indexterm" id="idm45251565649432"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html4" data-type="indexterm" id="idm45251565642136"/>.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html3" data-type="indexterm" id="idm45251565640632"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html2" data-type="indexterm" id="idm45251565639224"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html1" data-type="indexterm" id="idm45251565637848"/></p>
</div></section><!--Example: An Efficient ASCII String Type-->
</div></section><!--Unsafe Blocks-->

<section data-type="sect1" data-pdf-bookmark="Unsafe Functions"><div class="sect1" id="unsafe-functions">
<h1>Unsafe Functions</h1>

<p><a contenteditable="false" data-primary="functions" data-secondary="unsafe" data-type="indexterm" id="C21-unsafe.html7"/><a contenteditable="false" data-primary="unsafe code" data-secondary="unsafe functions" data-type="indexterm" id="C21-unsafe.html8"/><a contenteditable="false" data-primary="unsafe functions" data-type="indexterm" id="C21-unsafe.html9"/>An <code>unsafe</code> function definition looks like an ordinary function definition preceded by the <code>unsafe</code> keyword. The body of an <code>unsafe</code> function is automatically considered an <code>unsafe</code> block.</p>

<p>You may call <code>unsafe</code> functions only within <code>unsafe</code> blocks. This means that marking a function <code>unsafe</code> warns its callers that the function has a contract they must satisfy to avoid undefined behavior.</p>

<p><a contenteditable="false" data-primary="Ascii string type" data-secondary="unsafe functions" data-type="indexterm" id="idm45251565625912"/>For example, here’s a new constructor for the <code>Ascii</code> type we introduced before that builds an <code>Ascii</code> from a byte vector without checking if its contents are valid ASCII:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// This must be placed inside the `my_ascii` module.</code>
<code class="k">impl</code><code class="w"> </code><code class="n">Ascii</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Construct an `Ascii` value from `bytes`, without checking</code>
<code class="w">    </code><code class="sd">/// whether `bytes` actually contains well-formed ASCII.</code>
<code class="w">    </code><code class="sd">///</code>
<code class="w">    </code><code class="sd">/// This constructor is infallible, and returns an `Ascii` directly,</code>
<code class="w">    </code><code class="sd">/// rather than a `Result&lt;Ascii, NotAsciiError&gt;` as the `from_bytes`</code>
<code class="w">    </code><code class="sd">/// constructor does.</code>
<code class="w">    </code><code class="sd">///</code>
<code class="w">    </code><code class="sd">/// # Safety</code>
<code class="w">    </code><code class="sd">///</code>
<code class="w">    </code><code class="sd">/// The caller must ensure that `bytes` contains only ASCII</code>
<code class="w">    </code><code class="sd">/// characters: bytes no greater than 0x7f. Otherwise, the effect is</code>
<code class="w">    </code><code class="sd">/// undefined.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="k">fn</code> <code class="nf">from_bytes_unchecked</code><code class="p">(</code><code class="n">bytes</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Ascii</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Ascii</code><code class="p">(</code><code class="n">bytes</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Presumably, code calling <code>Ascii::from_bytes_unchecked</code> already knows somehow that the vector in hand contains only ASCII characters, so the check that <code>Ascii::from_bytes</code> insists on carrying out would be a waste of time, and the caller would have to write code to handle <code>Err</code> results that it knows will never occur. <code>Ascii::from_bytes_unchecked</code> lets such a caller sidestep the checks and the error handling.</p>
<p>But earlier we emphasized the importance of <code>Ascii</code>’s public constructors and methods ensuring that <code>Ascii</code> values are well-formed. Doesn’t <code>from_bytes_unchecked</code> fail to meet that responsibility?</p>
<p>Not quite: <code>from_bytes_unchecked</code> meets its obligations by passing them on to its caller via its contract. The presence of this contract is what makes it correct to mark this function <code>unsafe</code>: despite the fact that the function itself carries out no unsafe operations, its callers must follow rules Rust cannot enforce automatically to avoid undefined behavior.</p>

<p>Can you really cause undefined behavior by breaking the contract of <code>Ascii::from_bytes_unchecked</code>? Yes. You can construct a <code>String</code> holding ill-formed UTF-8 as follows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Imagine that this vector is the result of some complicated process</code>
<code class="c1">// that we expected to produce ASCII. Something went wrong!</code>
<code class="kd">let</code><code class="w"> </code><code class="n">bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mh">0xf7</code><code class="p">,</code><code class="w"> </code><code class="mh">0xbf</code><code class="p">,</code><code class="w"> </code><code class="mh">0xbf</code><code class="p">,</code><code class="w"> </code><code class="mh">0xbf</code><code class="p">];</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">ascii</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// This unsafe function's contract is violated</code>
<code class="w">    </code><code class="c1">// when `bytes` holds non-ASCII bytes.</code>
<code class="w">    </code><code class="n">Ascii</code>::<code class="n">from_bytes_unchecked</code><code class="p">(</code><code class="n">bytes</code><code class="p">)</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">bogus</code>: <code class="nb">String</code> <code class="o">=</code><code class="w"> </code><code class="n">ascii</code><code class="p">.</code><code class="n">into</code><code class="p">();</code><code class="w"/>

<code class="c1">// `bogus` now holds ill-formed UTF-8. Parsing its first character</code>
<code class="c1">// produces a `char` that is not a valid Unicode code point.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">bogus</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">next</code><code class="p">().</code><code class="n">unwrap</code><code class="p">()</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u32</code><code class="p">,</code><code class="w"> </code><code class="mh">0x1fffff</code><code class="p">);</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="bugs, unsafe code and" data-type="indexterm" id="idm45251565424472"/><a contenteditable="false" data-primary="contracts" data-secondary="bugs and" data-type="indexterm" id="idm45251565423496"/>This illustrates two critical facts about bugs and unsafe code:</p>

<ul>
	<li><p><em>Bugs that occur before the <code>unsafe</code> block can break contracts.</em> Whether an <code>unsafe</code> block causes undefined behavior can depend not just on the code in the block itself, but also on the code that supplies the values it operates on. Everything that your <code>unsafe</code> code relies on to satisfy contracts is safety-critical. The conversion from <code>Ascii</code> to <code>String</code> based on <code>String::from_utf8_unchecked</code> is well-defined only if the rest of the module properly maintains <code>Ascii</code>’s invariants.</p></li>
	<li><p><em>The consequences of breaking a contract may appear after you leave the <code>unsafe</code> block.</em> The undefined behavior courted by failing to comply with an unsafe feature’s contract often does not occur within the <code>unsafe</code> block itself. Constructing a bogus <code>String</code> as shown before may not cause problems until much later in the program’s execution.</p></li>
</ul>

<p>Essentially, Rust’s type checker, borrow checker, and other static checks are inspecting your program and trying to construct a proof that it cannot exhibit undefined behavior. When Rust compiles your program successfully, that means it succeeded in proving your code sound. An <code>unsafe</code> block is a gap in this proof: “This code,” you are saying to Rust, “is fine, trust me.” Whether your claim is true could depend on any part of the program that influences what happens in the <code>unsafe</code> block, and the consequences of being wrong could appear anywhere influenced by the <code>unsafe</code> block. Writing the <code>unsafe</code> keyword amounts to a reminder that you are not getting the full benefit of the language’s safety checks.</p>

<p>Given the choice, you should naturally prefer to create safe interfaces, without contracts. These are much easier to work with, since users can count on Rust’s safety checks to ensure their code is free of undefined behavior. Even if your implementation uses unsafe features, it’s best to use Rust’s types, lifetimes, and module system to meet their contracts while using only what you can guarantee yourself, rather than passing responsibilities on to your callers.</p>

<p>Unfortunately, it’s not unusual to come across unsafe functions in the wild whose documentation does not bother to explain their contracts. You are expected to infer the rules yourself, based on your experience and knowledge of how the code behaves. If you’ve ever uneasily wondered whether what you’re doing with a C or C++ API is OK, then you know what that’s like.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html9" data-type="indexterm" id="idm45251565294440"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html8" data-type="indexterm" id="idm45251565293064"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html7" data-type="indexterm" id="idm45251565291688"/></p>
</div></section><!--Unsafe Functions-->

<section data-type="sect1" data-pdf-bookmark="Unsafe Block or Unsafe Function?"><div class="sect1" id="unsafe-block-or-unsafe-function">
<h1>Unsafe Block or Unsafe Function?</h1>

<p><a contenteditable="false" data-primary="unsafe blocks" data-secondary="unsafe functions vs." data-type="indexterm" id="idm45251565288408"/><a contenteditable="false" data-primary="unsafe code" data-secondary="unsafe blocks vs. unsafe functions" data-type="indexterm" id="idm45251565287032"/>You may find yourself wondering whether to use an <code>unsafe</code> block or just mark the whole function unsafe. The approach we recommend is to first make a decision about the function:</p>

<ul>
	<li>
	<p>If it’s possible to misuse the function in a way that compiles fine but still causes undefined behavior, you must mark it as unsafe. The rules for using the function correctly are its contract; the existence of a contract is what makes the function unsafe.</p>
	</li>
	<li>
	<p>Otherwise, the function is safe: no well-typed call to it can cause undefined behavior. It should not be marked <code>unsafe</code>.</p>
	</li>
</ul>

<p>Whether the function uses unsafe features in its body is irrelevant; what matters is the presence of a contract. Before, we showed an unsafe function that uses no unsafe features, and a safe function that does use unsafe features.</p>

<p>Don’t mark a safe function <code>unsafe</code> just because you use unsafe features in its body. This makes the function harder to use, and confuses readers who will (correctly) expect to find a contract explained somewhere. Instead, use an <code>unsafe</code> block, even if it’s the function’s entire body.</p>
</div></section><!-- Unsafe Block or Unsafe Function? -->

<section data-type="sect1" data-pdf-bookmark="Undefined Behavior"><div class="sect1" id="undefined-behavior">
<h1>Undefined Behavior</h1>

<p><a contenteditable="false" data-primary="undefined behavior" data-type="indexterm" id="C21-unsafe.html10"/><a contenteditable="false" data-primary="unsafe code" data-secondary="undefined behavior" data-type="indexterm" id="C21-unsafe.html11"/>In the introduction, we said that the term <em>undefined behavior</em> means “behavior that Rust firmly assumes your code could never exhibit.” This is a strange turn of phrase, especially since we know from our experience with other languages that these behaviors <em>do</em> occur by accident with some frequency. Why is this concept helpful in setting out the obligations of unsafe code?</p>

<p>A compiler is a translator from one programming language to another. The Rust compiler takes a Rust program and translates it into an equivalent machine language program. But what does it mean to say that two programs in such completely different languages are equivalent?</p>

<p>Fortunately, this question is easier for programmers than it is for linguists. We usually say that two programs are equivalent if they will always have the same visible behavior when executed: they make the same system calls, interact with foreign libraries in equivalent ways, and so on. It’s a bit like a Turing test for programs: if you can’t tell whether you’re interacting with the original or the translation, then they’re equivalent.</p>

<p>Now consider the following code:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="n">very_trustworthy</code><code class="p">(</code><code class="o">&amp;</code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">100</code><code class="p">);</code><code class="w"/></pre>

<p>Even knowing nothing about the definition of <code>very_trustworthy</code>, we can see that it receives only a shared reference to <code>i</code>, so the call cannot change <code>i</code>’s value. Since the value passed to <code>println!</code> will always be <code>1000</code>, Rust can translate this code into machine language as if we had written:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">very_trustworthy</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">10</code><code class="p">);</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="mi">1000</code><code class="p">);</code><code class="w"/></pre>

<p>This transformed version has the same visible behavior as the original, and it’s probably a bit faster. But it makes sense to consider the performance of this version only if we agree it has the same meaning as the original. What if <code>very_trustworthy</code> were defined as follows?</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">very_trustworthy</code><code class="p">(</code><code class="n">shared</code>: <code class="kp">&amp;</code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Turn the shared reference into a mutable pointer.</code>
<code class="w">        </code><code class="c1">// This is undefined behavior.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">mutable</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">shared</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="kt">i32</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="kt">i32</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="o">*</code><code class="n">mutable</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">20</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This code breaks the rules for shared references: it changes the value of <code>i</code> to <code>20</code>, even though it should be frozen because <code>i</code> is borrowed for sharing. As a result, the transformation we made to the caller now has a very visible effect: if Rust transforms the code, the program prints <code>1000</code>; if it leaves the code alone and uses the new value of <code>i</code>, it prints <code>2000</code>. Breaking the rules for shared references in <code>very_trustworthy</code> means that shared references won’t behave as expected in its callers.</p>

<p>This sort of problem arises with almost every kind of transformation Rust might attempt. Even inlining a function into its call site assumes, among other things, that when the callee finishes, control flow returns to the call site. But we opened the chapter with an example of ill-behaved code that violates even that assumption.</p>

<p>It’s basically impossible for Rust (or any other language) to assess whether a transformation to a program preserves its meaning unless it can trust the fundamental features of the language to behave as designed. And whether they do or not can depend not just on the code at hand, but on other, potentially distant, parts of the program. In order to do anything at all with your code, Rust must assume that the rest of your program is well-behaved.</p>

<p><a contenteditable="false" data-primary="Rust (generally)" data-secondary="rules for well-behaved program" data-type="indexterm" id="idm45251565069624"/><a contenteditable="false" data-primary="well-behaved program" data-type="indexterm" id="idm45251565068280"/>Here, then, are Rust’s rules for well-behaved programs:</p>

<ul>
	<li>
	<p>The program must not read uninitialized memory.</p>
	</li>
	<li>The program must not create invalid primitive values:
	<ul>
		<li>References or boxes that are <code>null</code></li>
		<li><code>bool</code> values that are not either a <code>0</code> or <code>1</code></li>
		<li><code>enum</code> values with invalid discriminant values</li>
		<li><code>char</code> values that are not valid, nonsurrogate Unicode code points</li>
		<li><code>str</code> values that are not well-formed UTF-8</li>
	</ul>
	</li>
	<li>
	<p>The rules for references explained in <a data-type="xref" href="ch05.xhtml#references">Chapter 5</a> must be followed. No reference may outlive its referent; shared access is read-only access; and mutable access is exclusive access.</p>
	</li>
	<li>
	<p>The program must not dereference null, incorrectly aligned, or dangling <span class="keep-together">pointers.</span></p>
	</li>
	<li>
	<p>The program must not use a pointer to access memory outside the allocation with which the pointer is associated. We will explain this rule in detail in <a data-type="xref" href="#dereferencing-raw-pointers-safely">“Dereferencing Raw Pointers Safely”</a>.</p>
	</li>
	<li>
	<p>The program must be free of data races. A data race occurs when two threads access the same memory location without synchronization, and at least one of the accesses is a write.</p>
	</li>
	<li>
	<p>The program must not unwind across a call made from another language, via the foreign function interface, as explained in <a data-type="xref" href="ch07.xhtml#unwinding">“Unwinding”</a>.</p>
	</li>
	<li>
	<p>The program must comply with the contracts of standard library functions.</p>
	</li>
</ul>

<p>These rules are all that Rust assumes in the process of optimizing your program and translating it into machine language. Undefined behavior is, simply, any violation of these rules. This is why we say that Rust assumes your program will not exhibit undefined behavior: this assumption is necessary if we hope to conclude that the compiled program is a faithful translation of the source code.</p>

<p>Rust code that does not use unsafe features is guaranteed to follow all of the preceding rules, once it compiles. Only when you use unsafe features do these rules become your responsibility. In C and C++, the fact that your program compiles without errors or warnings means much less; as we mentioned in the introduction to this book, even the best C and C++ programs written by well-respected projects that hold their code to high standards exhibit undefined behavior in practice.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html11" data-type="indexterm" id="idm45251565049176"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html10" data-type="indexterm" id="idm45251565047800"/></p>
</div></section><!-- Undefined Behavior -->

<section data-type="sect1" data-pdf-bookmark="Unsafe Traits"><div class="sect1" id="unsafe-traits">
<h1>Unsafe Traits</h1>

<p><a contenteditable="false" data-primary="traits" data-secondary="unsafe" data-type="indexterm" id="C21-unsafe.html12"/><a contenteditable="false" data-primary="unsafe code" data-secondary="unsafe traits" data-type="indexterm" id="C21-unsafe.html13"/><a contenteditable="false" data-primary="unsafe traits" data-type="indexterm" id="C21-unsafe.html14"/>An <a contenteditable="false" data-primary="contracts" data-secondary="unsafe traits and" data-type="indexterm" id="idm45251565039592"/><em>unsafe trait</em> is a trait that has a contract Rust cannot check or enforce that implementers must satisfy to avoid undefined behavior. To implement an unsafe trait, you must mark the implementation as unsafe. It is up to you to understand the trait’s contract, and make sure your type satisfies it.</p>

<p>A function that bounds its type variables with an unsafe trait is typically one that uses unsafe features itself, and satisfies their contracts only by depending on the unsafe trait’s contract. An incorrect implementation of the trait could cause such a function to exhibit undefined behavior.</p>

<p>The classic examples of unsafe traits are <code>std::marker::Send</code> and <code>std::marker::Sync</code>. These traits don’t define any methods, so they’re trivial to implement for any type you like. <a contenteditable="false" data-primary="Send type" data-type="indexterm" id="idm45251565035128"/>But they do have contracts: <code>Send</code> requires implementers to be safe to move to another thread, <a contenteditable="false" data-primary="Sync type" data-type="indexterm" id="idm45251565033480"/>and <code>Sync</code> requires them to be safe to share among threads via shared references. Implementing <code>Send</code> for an inappropriate type, for example, would make <code>std::sync::Mutex</code> no longer safe from data races.</p>

<p><a contenteditable="false" data-primary="traits" data-secondary="Zeroable" data-type="indexterm" id="C21-unsafe.html15"/><a contenteditable="false" data-primary="Zeroable trait" data-type="indexterm" id="C21-unsafe.html16"/>As a simple example, the Rust library includes an unsafe trait, <code>core::nonzero::Zeroable</code>, for types that can be safely initialized by setting all their bytes to zero. Clearly, zeroing a <code>usize</code> is fine, but zeroing a <code>&amp;T</code> gives you a null reference, which will cause a crash if dereferenced. For types that are zeroable, some optimizations are possible: you can initialize an array of them quickly with <code>std::mem::write_bytes</code> (Rust’s equivalent of <code>memset</code>), or use operating system calls that allocate zeroed pages. (As of Rust 1.17, <code>Zeroable</code> is experimental, so it may be changed or removed in future versions of Rust, but it’s a good, simple, real-world example.)</p>

<p><code>Zeroable</code> is a typical marker trait, lacking methods or associated types:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">Zeroable</code><code class="w"> </code><code class="p">{}</code><code class="w"/></pre>

<p>The implementations for appropriate types are similarly straightforward:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">unsafe</code><code class="w"> </code><code class="k">impl</code><code class="w"> </code><code class="n">Zeroable</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="kt">u8</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="k">unsafe</code><code class="w"> </code><code class="k">impl</code><code class="w"> </code><code class="n">Zeroable</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="kt">i32</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="k">unsafe</code><code class="w"> </code><code class="k">impl</code><code class="w"> </code><code class="n">Zeroable</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="kt">usize</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="c1">// and so on for all the integer types</code></pre>

<p>With these definitions, we can write a function that quickly allocates a vector of a given length containing a <code>Zeroable</code> type:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="cp">#![feature(nonzero)]</code><code class="w">  </code><code class="c1">// permits `Zeroable`</code>

<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">core</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">core</code>::<code class="n">nonzero</code>::<code class="n">Zeroable</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">zeroed_vector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">len</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nc">Zeroable</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">with_capacity</code><code class="p">(</code><code class="n">len</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">write_bytes</code><code class="p">(</code><code class="n">vec</code><code class="p">.</code><code class="n">as_mut_ptr</code><code class="p">(),</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">len</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">vec</code><code class="p">.</code><code class="n">set_len</code><code class="p">(</code><code class="n">len</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">vec</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function starts by creating an empty <code>Vec</code> with the required capacity, and then calls <code>write_bytes</code> to fill the unoccupied buffer with zeros. (The <code>write_byte</code> function treats <code>len</code> as a number of <code>T</code> elements, not a number of bytes, so this call does fill the entire buffer.) A vector’s <code>set_len</code> method changes its length without doing anything to the buffer; this is unsafe, because you must ensure that the newly enclosed buffer space actually contains properly initialized values of type <code>T</code>. But this is exactly what the <code>T: Zeroable</code> bound establishes: a block of zero bytes represent a valid <code>T</code> value. Our use of <code>set_len</code> is safe.</p>

<p>Here, we put it to use:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">zeroed_vector</code><code class="p">(</code><code class="mi">100_000</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">all</code><code class="p">(</code><code class="o">|&amp;</code><code class="n">u</code><code class="o">|</code><code class="w"> </code><code class="n">u</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">));</code><code class="w"/></pre>

<p>Clearly, <code>Zeroable</code> must be an unsafe trait, since an implementation that doesn’t respect its contract can lead to undefined behavior:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">HoldsRef</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="kt">i32</code><code class="p">);</code><code class="w"/>

<code class="k">unsafe</code><code class="w"> </code><code class="k">impl</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Zeroable</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">HoldsRef</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">HoldsRef</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">zeroed_vector</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="o">*</code><code class="n">v</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="mi">0</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w">   </code><code class="c1">// crashes: dereferences null pointer</code></pre>

<p>Rust compiles this without complaint: it has no idea what <code>Zeroable</code> is meant to signify, so it can’t tell when it’s being implemented for an inappropriate type. As with any other unsafe feature, it’s up to you to understand and adhere to an unsafe trait’s <span class="keep-together">contract.</span></p>

<p>Note that unsafe code must not depend on ordinary, safe traits being implemented correctly. For example, suppose there were an implementation of the <code>std::hash::Hasher</code> trait that simply returned a random hash value, with no relation to the values being hashed. The trait requires that hashing the same bits twice must produce the same hash value, but this implementation doesn’t meet that requirement; it’s simply incorrect. But because <code>Hasher</code> is not an unsafe trait, unsafe code must not exhibit undefined behavior when it uses this hasher. The <code>std::collections::​HashMap</code> type is carefully written to respect the contracts of the unsafe features it uses regardless of how the hasher behaves. Certainly, the table won’t function correctly: lookups will fail, and entries will appear and disappear at random. But the table will not exhibit undefined behavior<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html16" data-type="indexterm" id="idm45251564650968"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html15" data-type="indexterm" id="idm45251564649624"/>.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html14" data-type="indexterm" id="idm45251564648120"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html13" data-type="indexterm" id="idm45251564646712"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html12" data-type="indexterm" id="idm45251564645336"/></p>
</div></section><!-- Unsafe Traits -->

<section data-type="sect1" data-pdf-bookmark="Raw Pointers"><div class="sect1" id="unsafe-code-raw-pointers">
<h1>Raw Pointers</h1>

<p><a contenteditable="false" data-primary="raw pointers" data-type="indexterm" id="C21-unsafe.html17"/><a contenteditable="false" data-primary="unsafe code" data-secondary="raw pointers" data-seealso="raw pointers" data-type="indexterm" id="C21-unsafe.html18"/>A <em>raw pointer</em> in Rust is an unconstrained pointer. You can use raw pointers to form all sorts of structures that Rust’s checked pointer types cannot, like doubly linked lists or arbitrary graphs of objects. But because raw pointers are so flexible, Rust cannot tell whether you are using them safely or not, so you can dereference them only in an <code>unsafe</code> block.</p>

<p>Raw pointers are essentially equivalent to C or C++ pointers, so they’re also useful for interacting with code written in those languages.</p>

<p>There are two kinds of raw pointers:</p>

<ul>
	<li>
	<p>A <code>*mut T</code> is a raw pointer to a <code>T</code> that permits modifying its referent.</p>
	</li>
	<li>
	<p>A <code>*const T</code> is a raw pointer to a <code>T</code> that only permits reading its referent.</p>
	</li>
</ul>

<p>(There is no plain <code>*T</code> type; you must always specify either <code>const</code> or <code>mut</code>.)</p>

<p>You can create a raw pointer by conversion from a reference, and dereference it with the <code>*</code> operator:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">ptr_x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="kt">i32</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="mi">20</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">ptr_y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;*</code><code class="n">y</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="kt">i32</code><code class="p">;</code><code class="w"/>

<code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">*</code><code class="n">ptr_x</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="o">*</code><code class="n">ptr_y</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">);</code><code class="w"/></pre>

<p>Unlike boxes and references, raw pointers can be null, like <code>NULL</code> in C or <code>nullptr</code> in <span class="keep-together">C++:</span></p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">option_to_raw</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">opt</code>: <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">opt</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">null</code><code class="p">(),</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">!</code><code class="n">option_to_raw</code><code class="p">(</code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="p">(</code><code class="s">"pea"</code><code class="p">,</code><code class="w"> </code><code class="s">"pod"</code><code class="p">))).</code><code class="n">is_null</code><code class="p">());</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">option_to_raw</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(</code><code class="nb">None</code><code class="p">),</code><code class="w"> </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">null</code><code class="p">());</code><code class="w"/></pre>

<p>This example has no <code>unsafe</code> blocks: creating raw pointers, passing them around, and comparing them are all safe. Only dereferencing a raw pointer is unsafe.</p>

<p>A raw pointer to an unsized type is a fat pointer, just as the corresponding reference or <code>Box</code> type would be. A <code>*const [u8]</code> pointer includes a length along with the address, and a trait object like <code>*mut std::io::Write</code> pointer carries a vtable.</p>

<p><a contenteditable="false" data-primary="dereferencing" data-secondary="raw pointers" data-type="indexterm" id="unsafe001"/>Although Rust implicitly dereferences safe pointer types in various situations, raw pointer dereferences must be explicit:</p>

<ul>
	<li>
	<p>The <code>.</code> operator will not implicitly dereference a raw pointer; you must write <code>(*raw).field</code> or <code>(*raw).method(...)</code>.</p>
	</li>
	<li>
	<p>Raw pointers do not implement <code>Deref</code>, so deref coercions do not apply to them.</p>
	</li>
	<li>
	<p>Operators like <code>==</code> and <code>&lt;</code> compare raw pointers as addresses: two raw pointers are equal if they point to the same location in memory. Similarly, hashing a raw pointer hashes the address it points to, not the value of its referent.</p>
	</li>
	<li>
	<p>Formatting traits like <code>std::fmt::Display</code> follow references automatically, but don’t handle raw pointers at all. The exceptions are <code>std::fmt::Debug</code> and <code>std::fmt::Pointer</code>, which show raw pointers as hexadecimal addresses, without dereferencing them.</p>
	</li>
</ul>

<p><a contenteditable="false" data-primary="offset method" data-type="indexterm" id="idm45251564373256"/>Unlike the <code>+</code> operator in C and C++, Rust’s <code>+</code> does not handle raw pointers, but you can perform pointer arithmetic via their <code>offset</code> and <code>wrapping_offset</code> methods. There is no standard operation for finding the distance between two pointers, as the <code>-</code> operator does in C and C++, but you can write one yourself:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">distance</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">left</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">right</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">isize</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="n">left</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">right</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="p">)</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">size_of</code>::<code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">trucks</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"garbage truck"</code><code class="p">,</code><code class="w"> </code><code class="s">"dump truck"</code><code class="p">,</code><code class="w"> </code><code class="s">"moonstruck"</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">first</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">trucks</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">last</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">trucks</code><code class="p">[</code><code class="mi">2</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">distance</code><code class="p">(</code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">first</code><code class="p">),</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">distance</code><code class="p">(</code><code class="n">first</code><code class="p">,</code><code class="w"> </code><code class="n">last</code><code class="p">),</code><code class="w"> </code><code class="o">-</code><code class="mi">2</code><code class="p">);</code><code class="w"/></pre>

<p>Even though <code>distance</code>’s parameters are raw pointers, we can pass it references: Rust implicitly coerces references to raw pointers (but not the other way around, of course).</p>

<p><a contenteditable="false" data-primary="as operator" data-type="indexterm" id="idm45251564366296"/>The <code>as</code> operator permits almost every plausible conversion from references to raw pointers or between two raw pointer types. However, you may need to break up a complex conversion into a series of simpler steps. For example:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="o">&amp;</code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">42_</code><code class="k">u8</code><code class="p">]</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="nb">String</code><code class="w">  </code><code class="c1">// error: invalid conversion</code>
<code class="o">&amp;</code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">42_</code><code class="k">u8</code><code class="p">]</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="nb">String</code><code class="p">;</code><code class="w">  </code><code class="c1">// permitted</code></pre>

<p>Note that <code>as</code> will not convert raw pointers to references. Such conversions would be unsafe, and <code>as</code> should remain a safe operation. Instead, you must dereference the raw pointer (in an <code>unsafe</code> block), and then borrow the resulting value.</p>

<p>Be very careful when you do this: a reference produced this way has an unconstrained lifetime: there’s no limit on how long it can live, since the raw pointer gives Rust nothing to base such a decision on. In <a data-type="xref" href="#a-safe-interface-to-libgit2">“A Safe Interface to libgit2”</a> later in this chapter, we show several examples of how to properly constrain lifetimes.</p>

<p>Many types have <code>as_ptr</code> and <code>as_mut_ptr</code> methods that return a raw pointer to their contents. For example, array slices and strings return pointers to their first elements, and some iterators return a pointer to the next element they will produce. Owning pointer types like <code>Box</code>, <code>Rc</code>, and <code>Arc</code> have <code>into_raw</code> and <code>from_raw</code> functions that convert to and from raw pointers. Some of these methods’ contracts impose surprising requirements, so check their documentation before using them.</p>

<p>You can also construct raw pointers by conversion from integers, although the only integers you can trust for this are generally those you got from a pointer in the first place. <a data-type="xref" href="#example-refwithflag">“Example: RefWithFlag”</a> uses raw pointers this way.</p>

<p>Unlike references, raw pointers are neither <code>Send</code> nor <code>Sync</code>. As a result, any type that includes raw pointers does not implement these traits by default. There is nothing inherently unsafe about sending or sharing raw pointers between threads; after all, wherever they go, you still need an <code>unsafe</code> block to dereference them. But given the roles raw pointers typically play, the language designers considered this behavior to be the more helpful default. We already discussed how to implement <code>Send</code> and <code>Sync</code> yourself in <a data-type="xref" href="#unsafe-traits">“Unsafe Traits”</a>.</p>

<section data-type="sect2" data-pdf-bookmark="Dereferencing Raw Pointers Safely"><div class="sect2" id="dereferencing-raw-pointers-safely">
<h2>Dereferencing Raw Pointers Safely</h2>

<p><a contenteditable="false" data-primary="dereferencing" data-secondary="raw pointers" data-startref="unsafe001" data-type="indexterm" id="idm45251564179800"/><a contenteditable="false" data-primary="raw pointers" data-secondary="dereferencing safely" data-type="indexterm" id="idm45251564178152"/>Here are some common-sense guidelines for using raw pointers safely:</p>

<ul>
	<li>
	<p>Dereferencing null pointers or dangling pointers is undefined behavior, as is referring to uninitialized memory, or values that have gone out of scope.</p>
	</li>
	<li>
	<p>Dereferencing pointers that are not properly aligned for their referent type is undefined behavior.</p>
	</li>
	<li>
	<p>You may borrow values out of a dereferenced raw pointer only if doing so obeys the rules for reference safety explained in <a data-type="xref" href="ch05.xhtml#references">Chapter 5</a>: No reference may outlive its referent; shared access is read-only access; and mutable access is exclusive access. (This rule is easy to violate by accident, since raw pointers are often used to create data structures with nonstandard sharing or ownership.)</p>
	</li>
	<li>
	<p>You may use a raw pointer’s referent only if it is a well-formed value of its type. For example, you must ensure that dereferencing a <code>*const char</code> yields a proper, nonsurrogate Unicode code point.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="offset method" data-type="indexterm" id="idm45251564169848"/>You may use the <code>offset</code> and <code>wrapping_offset</code> methods on raw pointers only to point to bytes within the variable or heap-allocated block of memory that the original pointer referred to, or to the first byte beyond such a region.</p>

	<p>If you do pointer arithmetic by converting the pointer to an integer, doing arithmetic on the integer, and then converting it back to a pointer, the result must be a pointer that the rules for the <code>offset</code> method would have allowed you to produce.</p>
	</li>
	<li>
	<p>If you assign to a raw pointer’s referent, you must not violate the invariants of any type of which the referent is a part. For example, if you have a <code>*mut u8</code> pointing to a byte of a <code>String</code>, you may only store values in that <code>u8</code> that leave the <code>String</code> holding well-formed UTF-8.</p>
	</li>
</ul>

<p>The borrowing rule aside, these are essentially the same rules you must follow when using pointers in C or C++.</p>

<p>The reason for not violating types’ invariants should be clear. Many of Rust’s standard types use unsafe code in their implementation, but still provide safe interfaces on the assumption that Rust’s safety checks, module system, and visibility rules will be respected. Using raw pointers to circumvent these protective measures can lead to undefined behavior.</p>

<p>The complete, exact contract for raw pointers is not easily stated, and may change as the language evolves. But the principles outlined here should keep you in safe <span class="keep-together">territory.</span></p>
</div></section><!-- Dereferencing Raw Pointers Safely -->

<section data-type="sect2" data-pdf-bookmark="Example: RefWithFlag"><div class="sect2" id="example-refwithflag">
<h2>Example: RefWithFlag</h2>

<p><a contenteditable="false" data-primary="raw pointers" data-secondary="RefWithFlag" data-type="indexterm" id="C21-unsafe.html19"/><a contenteditable="false" data-primary="RefWithFlag&lt;'a, T&gt;" data-type="indexterm" id="C21-unsafe.html20"/>Here’s an example of how to take a classic<sup><a data-type="noteref" id="idm45251564155464-marker" href="ch21.xhtml#idm45251564155464">1</a></sup> bit-level hack made possible by raw pointers, and wrap it up as a completely safe Rust type. This module defines a type, <code>RefWithFlag&lt;'a, T&gt;</code>, that holds both a <code>&amp;'a T</code> and a <code>bool</code>, like the tuple <code>(&amp;'a T, bool)</code>, and yet still manages to occupy only one machine word instead of two. This sort of technique is used regularly in garbage collectors and virtual machines, where certain types—say, the type representing an object—are so numerous that adding even a single word to each value would drastically increase memory use:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">mod</code> <code class="nn">ref_with_flag</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">marker</code>::<code class="n">PhantomData</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">align_of</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="sd">/// A `&amp;T` and a `bool`, wrapped up in a single word.</code>
<code class="w">    </code><code class="sd">/// The type `T` must require at least two-byte alignment.</code>
<code class="w">    </code><code class="sd">///</code>
<code class="w">    </code><code class="sd">/// If you're the kind of programmer who's never met a pointer whose</code>
<code class="w">    </code><code class="sd">/// 2⁰-bit you didn't want to steal, well, now you can do it safely!</code>
<code class="w">    </code><code class="sd">/// ("But it's not nearly as exciting this way...")</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">RefWithFlag</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">ptr_and_bit</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">behaves_like</code>: <code class="nc">PhantomData</code><code class="o">&lt;&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="c1">// occupies no space</code>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">impl</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="n">RefWithFlag</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">(</code><code class="n">ptr</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">flag</code>: <code class="kt">bool</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">RefWithFlag</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">align_of</code>::<code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">RefWithFlag</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">ptr_and_bit</code>: <code class="nc">ptr</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">usize</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="n">flag</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">usize</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="n">behaves_like</code>: <code class="nc">PhantomData</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">get_ref</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="kd">let</code><code class="w"> </code><code class="n">ptr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">ptr_and_bit</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="o">!</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w"/>
<code class="w">                </code><code class="o">&amp;*</code><code class="n">ptr</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">get_flag</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">ptr_and_bit</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This code takes advantage of the fact that many types must be placed at even addresses in memory: since an even address’s least significant bit is always zero, we can store something else there, and then reliably reconstruct the original address just by masking off the bottom bit. Not all types qualify; for example, the types <code>u8</code> and <code>(bool, [i8; 2])</code> can be placed at any address. But we can check the type’s alignment on construction and refuse types that won’t work.</p>

<p>You can use <code>RefWithFlag</code> like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">ref_with_flag</code>::<code class="n">RefWithFlag</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">flagged</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">RefWithFlag</code>::<code class="n">new</code><code class="p">(</code><code class="o">&amp;</code><code class="n">vec</code><code class="p">,</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">flagged</code><code class="p">.</code><code class="n">get_ref</code><code class="p">()[</code><code class="mi">1</code><code class="p">],</code><code class="w"> </code><code class="mi">20</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">flagged</code><code class="p">.</code><code class="n">get_flag</code><code class="p">(),</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/></pre>

<p>The constructor <code>RefWithFlag::new</code> takes a reference and a <code>bool</code> value, asserts that the reference’s type is suitable, and then converts the reference to a raw pointer, and then a <code>usize</code>. The <code>usize</code> type is defined to be large enough to hold a pointer on whatever processor we’re compiling for, so converting a raw pointer to a <code>usize</code> and back is well-defined. Once we have a <code>usize</code>, we know it must be even, so we can use the <code>|</code> bitwise-or operator to combine it with the <code>bool</code>, which we’ve converted to an integer 0 or 1.</p>

<p>The <code>get_flag</code> method extracts the <code>bool</code> component of a <code>RefWithFlag</code>. It’s simple: just mask off the bottom bit and check if it’s nonzero.</p>
<p>The <code>get_ref</code> method extracts the reference from a <code>RefWithFlag</code>. First, it masks off the <code>usize</code>’s bottom bit and converts it to a raw pointer. The <code>as</code> operator will not convert raw pointers to references, but we can dereference the raw pointer (in an <code>unsafe</code> block, naturally) and borrow that. Borrowing a raw pointer’s referent gives you a reference with an unbounded lifetime: Rust will accord the reference whatever lifetime would make the code around it check, if there is one. Usually, though, there is some specific lifetime which is more accurate, and would thus catch more mistakes. In this case, since <code>get_ref</code>’s return type is <code>&amp;'a T</code>, Rust sees that the reference’s lifetime is the same as <code>RefWithFlag</code>’s lifetime parameter <code>'a</code>, which is just what we want: that’s the lifetime of the reference we started with.</p>
<p>In memory, a <code>RefWithFlag</code> looks just like a <code>usize</code>: since <code>PhantomData</code> is a zero-sized type, the <code>behaves_like</code> field takes up no space in the structure. But the <code>PhantomData</code> is necessary for Rust to know how to treat lifetimes in code that uses <code>RefWithFlag</code>. Imagine what the type would look like without the <code>behaves_like</code> field:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// This won't compile.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">RefWithFlag</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">ptr_and_bit</code>: <code class="kt">usize</code>
<code class="p">}</code><code class="w"/></pre>

<p>In <a data-type="xref" href="ch05.xhtml#references">Chapter 5</a>, we pointed out that any structure containing references must not outlive the values they borrow, lest the references become dangling pointers. The structure must abide by the restrictions that apply to its fields. This certainly applies to <code>RefWithFlag</code>: in the example code we just looked at, <code>flagged</code> must not outlive <code>vec</code>, since <code>flagged.get_ref()</code> returns a reference to it. But our reduced <code>RefWithFlag</code> type contains no references at all, and never uses its lifetime parameter <code>'a</code>. It’s just a <code>usize</code>. How should Rust know that any restrictions apply to <code>ptr_and_bit</code>’s lifetime? Including a <code>PhantomData&lt;&amp;'a T&gt;</code> field tells Rust to treat <code>RefWithFlag&lt;'a, T&gt;</code> <em>as if</em> it contained a <code>&amp;'a T</code>, without actually affecting the struct’s representation.</p>

<p>Although Rust doesn’t really know what’s going on (that’s what makes <code>RefWithFlag</code> unsafe), it will do its best to help you out with this. If you omit the <code>behaves_like</code> field, Rust will complain that the parameters <code>'a</code> and <code>T</code> are unused, and suggest using a <code>PhantomData</code>.</p>

<p><code>RefWithFlag</code> uses the same tactics as the <code>Ascii</code> type we presented earlier to avoid undefined behavior in its <code>unsafe</code> block. The type itself is <code>pub</code>, but its fields are not, meaning that only code within the <code>ref_with_flag</code> module can create or look inside a <code>RefWithFlag</code> value. You don’t have to inspect much code to have confidence that the <code>ptr_and_bit</code> field is well constructed.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html20" data-type="indexterm" id="idm45251563712200"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html19" data-type="indexterm" id="idm45251563737688"/></p>
</div></section><!-- Example: RefWithFlag -->

<section data-type="sect2" data-pdf-bookmark="Nullable Pointers"><div class="sect2" id="nullable-pointers">
<h2>Nullable Pointers</h2>

<p><a contenteditable="false" data-primary="null raw pointers" data-type="indexterm" id="idm45251563734808"/><a contenteditable="false" data-primary="raw pointers" data-secondary="nullable" data-type="indexterm" id="idm45251563733480"/>A null raw pointer in Rust is a zero address, just as in C and C++. For any type <code>T</code>, the <code>std::ptr::null&lt;T&gt;</code> function returns a <code>*const T</code> null pointer, and <code>std::ptr::null_mut&lt;T&gt;</code> returns a <code>*mut T</code> null pointer.</p>

<p>There are a few ways to check whether a raw pointer is null. The simplest is the <code>is_null</code> method, but the <code>as_ref</code> method may be more convenient: it takes a <code>*const T</code> pointer and returns an <code>Option&lt;&amp;'a T&gt;</code>, turning a null pointer into a <code>None</code>. Similarly, the <code>as_mut</code> method converts <code>*mut T</code> pointers into <code>Option&lt;&amp;'a mut T&gt;</code> values.</p>
</div></section><!-- Nullable Pointers -->

<section data-type="sect2" data-pdf-bookmark="Type Sizes and Alignments"><div class="sect2" id="type-sizes-and-alignments">
<h2>Type Sizes and Alignments</h2>

<p><a contenteditable="false" data-primary="alignment, raw pointers" data-type="indexterm" id="idm45251563636792"/><a contenteditable="false" data-primary="raw pointers" data-secondary="type sizes and alignments" data-type="indexterm" id="idm45251563635496"/><a contenteditable="false" data-primary="Sized type" data-type="indexterm" id="idm45251563634152"/><a contenteditable="false" data-primary="type alignment, raw pointers and" data-type="indexterm" id="idm45251563633048"/><a contenteditable="false" data-primary="type size, raw pointers and" data-type="indexterm" id="idm45251563631928"/>A value of any <code>Sized</code> type occupies a constant number of bytes in memory, and must be placed at an address that is a multiple of some <em>alignment</em> value, determined by the machine architecture. For example, an <code>(i32, i32)</code> tuple occupies eight bytes, and most processors prefer it to be placed at an address that is a multiple of four.</p>

<p>The call <code>std::mem::size_of::&lt;T&gt;()</code> returns the size of a value of type <code>T</code>, in bytes, and <code>std::mem::align_of::&lt;T&gt;()</code> returns its required alignment. For example:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">size_of</code>::<code class="o">&lt;</code><code class="kt">i64</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="mi">8</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">align_of</code>::<code class="o">&lt;</code><code class="p">(</code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w"/></pre>

<p>Any type’s alignment is always a power of two.</p>

<p>A type’s size is always rounded up to a multiple of its alignment, even if it technically could fit in less space. For example, even though a tuple like <code>(f32, u8)</code> requires only five bytes, <code>size_of::&lt;(f32, u8)&gt;()</code> is <code>8</code>, because <code>align_of::&lt;(f32, u8)&gt;()</code> is <code>4</code>. This ensures that if you have an array, the size of the element type always reflects the spacing between one element and the next.</p>

<p>For unsized types, the size and alignment depend on the value at hand. Given a reference to an unsized value, the <code>std::mem::size_of_val</code> and <code>std::mem::align_of_val</code> functions return the value’s size and alignment. These functions can operate on references to both <code>Sized</code> and unsized types.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Fat pointers to slices carry their referent's length.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">slice</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">i32</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">27</code><code class="p">,</code><code class="w"> </code><code class="mi">81</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">size_of_val</code><code class="p">(</code><code class="n">slice</code><code class="p">),</code><code class="w"> </code><code class="mi">20</code><code class="p">);</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">text</code>: <code class="kp">&amp;</code><code class="kt">str</code> <code class="o">=</code><code class="w"> </code><code class="s">"alligator"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">size_of_val</code><code class="p">(</code><code class="n">text</code><code class="p">),</code><code class="w"> </code><code class="mi">9</code><code class="p">);</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Display</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">unremarkable</code>: <code class="kp">&amp;</code><code class="nc">Display</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="mi">193_</code><code class="k">u8</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">remarkable</code>: <code class="kp">&amp;</code><code class="nc">Display</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="mf">0.0072973525664</code><code class="p">;</code><code class="w"/>

<code class="c1">// These return the size/alignment of the value the</code>
<code class="c1">// trait object points to, not those of the trait object</code>
<code class="c1">// itself. This information comes from the vtable the</code>
<code class="c1">// trait object refers to.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">size_of_val</code><code class="p">(</code><code class="n">unremarkable</code><code class="p">),</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">align_of_val</code><code class="p">(</code><code class="n">remarkable</code><code class="p">),</code><code class="w"> </code><code class="mi">8</code><code class="p">);</code><code class="w"/></pre>
</div></section><!-- Type Sizes and Alignments -->

<section data-type="sect2" data-pdf-bookmark="Pointer Arithmetic"><div class="sect2" id="pointer-arithmetic">
<h2>Pointer Arithmetic</h2>

<p><a contenteditable="false" data-primary="arrays" data-secondary="raw pointers" data-type="indexterm" id="C21-unsafe.html21"/><a contenteditable="false" data-primary="raw pointers" data-secondary="pointer arithmetic" data-type="indexterm" id="C21-unsafe.html22"/>Rust lays out the elements of an array, slice, or vector as a single contiguous block of memory, as shown in <a data-type="xref" href="#array-figure">Figure 21-1</a>. Elements are regularly spaced, so that if each element occupies <code>size</code> bytes, then the <code>i</code>’th element starts with the <code>i * size</code>’th byte.</p>

<figure><div id="array-figure" class="figure"><img src="Images/rust_2101.png" alt="An array of four `i32` elements, cleverly named `array`.           Each element occupies four bytes.           The start address is the address of the first byte of the first element.           `array[0]` falls at byte offset 0.           `array[3]` falls at byte offset 12."/>
<h6><span class="label">Figure 21-1. </span>An array in memory</h6>
</div></figure>

<p>One nice consequence of this is that if you have two raw pointers to elements of an array, comparing the pointers gives the same results as comparing the elements’ indices: if <code>i &lt; j</code>, then a raw pointer to the <code>i</code>’th element is less than a raw pointer to the <code>j</code>’th element. This makes raw pointers useful as bounds on array traversals. In fact, the standard library’s simple iterator over a slice is defined like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Iter</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">ptr</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">end</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>ptr</code> field points to the next element iteration should produce, and the <code>end</code> field serves as the limit: when <code>ptr == end</code>, the iteration is complete.</p>

<p>Another nice consequence of array layout: if <code>element_ptr</code> is a <code>*const T</code> or <code>*mut T</code> raw pointer to the <code>i</code>’th element of some array, then <code>element_ptr.offset(o)</code> is a raw pointer to the <code>(i + o)</code>’th element. Its definition is equivalent to this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">offset</code><code class="p">(</code><code class="bp">self</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">count</code>: <code class="kt">isize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nb">Sized</code>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">bytes_per_element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">size_of</code>::<code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">byte_offset</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bytes_per_element</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="bp">self</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="p">).</code><code class="n">checked_add</code><code class="p">(</code><code class="n">byte_offset</code><code class="p">).</code><code class="n">unwrap</code><code class="p">()</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>std::mem::size_of::&lt;T&gt;</code> function returns the size of the type <code>T</code> in bytes. Since <code>isize</code> is, by definition, large enough to hold an address, you can convert the base pointer to an <code>isize</code>, do arithmetic on that value, and then convert the result back to a pointer.</p>

<p>It’s fine to produce a pointer to the first byte after the end of an array. You cannot dereference such a pointer, but it can be useful to represent the limit of a loop, or for bounds checks.</p>

<p><a contenteditable="false" data-primary="offset method" data-type="indexterm" id="idm45251563149704"/>However, it is undefined behavior to use <code>offset</code> to produce a pointer beyond that point, or before the start of the array, even if you never dereference it. For the sake of optimization, Rust would like to assume that <code>ptr.offset(i) &gt; ptr</code> when <code>i</code> is positive, and that <code>ptr.offset(i) &lt; ptr</code> when <code>i</code> is negative. This assumption seems safe, but it may not hold if the arithmetic in <code>offset</code> overflows an <code>isize</code> value. If <code>i</code> is constrained to stay within the same array as <code>ptr</code>, no overflow can occur: after all, the array itself does not overflow the bounds of the address space. (To make pointers to the first byte after the end safe, Rust never places values at the upper end of the address space.)</p>

<p>If you do need to offset pointers beyond the limits of the array they are associated with, you can use the <code>wrapping_offset</code> method. This is equivalent to <code>offset</code>, but Rust makes no assumptions about the relative ordering of <code>ptr.wrapping_offset(i)</code> and <code>ptr</code> itself. Of course, you still can’t dereference such pointers unless they fall within the array.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html22" data-type="indexterm" id="idm45251563141400"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html21" data-type="indexterm" id="idm45251563140024"/></p>
</div></section><!-- Pointer Arithmetic -->

<section data-type="sect2" data-pdf-bookmark="Moving into and out of Memory"><div class="sect2" id="moving-into-and-out-of-memory">
<h2>Moving into and out of Memory</h2>

<p><a contenteditable="false" data-primary="memory" data-secondary="raw pointers and" data-type="indexterm" id="C21-unsafe.html23"/><a contenteditable="false" data-primary="raw pointers" data-secondary="moving into/out of memory" data-type="indexterm" id="C21-unsafe.html24"/>If you are implementing a type that manages its own memory, you will need to track which parts of your memory hold live values and which are uninitialized, just as Rust does with local variables. Consider this code:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">pot</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"pasta"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">plate</code><code class="p">;</code><code class="w"/>

<code class="n">plate</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pot</code><code class="p">;</code><code class="w"/></pre>

<p>After this code has run, the situation looks like <a data-type="xref" href="#moving_string_from_one_local">Figure 21-2</a>.</p>

<figure><div id="moving_string_from_one_local" class="figure"><img src="Images/rust_2102.png" alt="Two local string variables, `pot` and `plate`.           `pot` is uninitialized, but still holds its prior pointer, capacity, and length.           `plate` holds the string `&quot;pasta&quot;`."/>
<h6><span class="label">Figure 21-2. </span>Moving a string from one local variable to another</h6>
</div></figure>

<p>After the assignment, <code>pot</code> is uninitialized, and <code>plate</code> is the owner of the string.</p>

<p>At the machine level, it’s not specified what a move does to the source, but in practice it usually does nothing at all. The assignment probably leaves <code>pot</code> still holding a pointer, capacity, and length for the string. Naturally, it would be disastrous to treat this as a live value, and Rust ensures that you don’t.</p>

<p>The same considerations apply to data structures that manage their own memory. Suppose you run this code:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">noodles</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"udon"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">soba</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"soba"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">last</code><code class="p">;</code><code class="w"/></pre>

<p>In memory, the state looks like <a data-type="xref" href="#uninitalized_vector_spare_capacity">Figure 21-3</a>.</p>

<figure><div id="uninitalized_vector_spare_capacity" class="figure"><img src="Images/rust_2103.png" alt="A vector holding one string, with capacity for one more.           A variable `soba`, holding the string &quot;soba&quot;.           A variable `last`, uninitialized."/>
<h6><span class="label">Figure 21-3. </span>A vector with uninitialized, spare capacity</h6>
</div></figure>

<p>The vector has the spare capacity to hold one more element, but its contents are junk, probably whatever that memory held previously. Suppose you then run this code:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">noodles</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">soba</code><code class="p">);</code><code class="w"/></pre>

<p>Pushing the string onto the vector transforms that uninitialized memory into a new element, as illustrated in <a data-type="xref" href="#sobas_value_on_vector">Figure 21-4</a>.</p>

<figure><div id="sobas_value_on_vector" class="figure"><img src="Images/rust_2104.png" alt="A vector holding two strings, with no more capacity.           A variable `soba`, uninitialized,           but still holding the pointer, capacity, and length it held while live.           A variable `last`, uninitialized."/>
<h6><span class="label">Figure 21-4. </span>After pushing soba’s value onto the vector</h6>
</div></figure>

<p>The vector has initialized its empty space to own the string, and incremented its length to mark this as a new, live element. The vector is now the owner of the string; you can refer to its second element, and dropping the vector would free both strings. And <code>soba</code> is now uninitialized.</p>

<p>Finally, consider what happens when we pop a value from the vector:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">last</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">noodles</code><code class="p">.</code><code class="n">pop</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/></pre>

<p>In memory, things now look like <a data-type="xref" href="#after_popping_element_from_vector">Figure 21-5</a>.</p>

<figure><div id="after_popping_element_from_vector" class="figure"><img src="Images/rust_2105.png" alt="A vector holding one strings, with capacity for one more.           The vector's space capacity still holds the pointer, capacity and length it held while live.           A variable `soba`, uninitialized,           but still holding the pointer, capacity, and length it held while live.           A variable `last`, owning a string."/>
<h6><span class="label">Figure 21-5. </span>After popping an element from the vector into last</h6>
</div></figure>

<p>The variable <code>last</code> has taken ownership of the string. The vector has decremented its length to indicate that the space that used to hold the string is now uninitialized.</p>

<p>Just as with <code>pot</code> and <code>pasta</code> earlier, all three of <code>soba</code>, <code>last</code>, and the vector’s free space probably hold identical bit patterns. But only <code>last</code> is considered to own the value. Treating either of the other two locations as live would be a mistake.</p>

<p>The true definition of an initialized value is one that is <em>treated as live</em>. Writing to a value’s bytes is usually a necessary part of initialization, but only because doing so prepares the value to be treated as live.</p>

<p>Rust tracks local variables at compile time. Types like <code>Vec</code>, <code>HashMap</code>, <code>Box</code>, and so on track their buffers dynamically. If you implement a type that manages its own memory, you will need to do the same.</p>

<p>Rust provides two essential operations for implementing such types:</p>

<ul>
	<li>
	<p><strong><code>std::ptr::read(src)</code></strong> moves a value out of the location <code>src</code> points to, transferring ownership to the caller. After calling <code>read</code>, you must treat <code>*src</code> as uninitialized memory. The <code>src</code> argument should be a <code>*const T</code> raw pointer, where <code>T</code> is a sized type.</p>

	<p>This is the operation behind <code>Vec::pop</code>. Popping a value calls <code>read</code> to move the value out of the buffer, and then decrements the length to mark that space as uninitialized capacity.</p>
	</li>
	<li>
	<p><strong><code>std::ptr::write(dest, value)</code></strong> moves <code>value</code> into the location <code>dest</code> points to, which must be uninitialized memory before the call. The referent now owns the value. Here, <code>dest</code> must be a <code>*mut T</code> raw pointer and <code>value</code> a <code>T</code> value, where <code>T</code> is a sized type.</p>

	<p>This is the operation behind <code>Vec::push</code>. Pushing a value calls <code>write</code> to move the value into the next available space, and then increments the length to mark that space as a valid element.</p>
	</li>
</ul>

<p>Both are free functions, not methods on the raw pointer types.</p>

<p>Note that you cannot do these things with any of Rust’s safe pointer types. They all require their referents to be initialized at all times, so transforming uninitialized memory into a value, or vice versa, is outside their reach. Raw pointers fit the bill.</p>

<p>The standard library also provides functions for moving arrays of values from one block of memory to another:</p>

<ul>
	<li>
	<p><strong><code>std::ptr::copy(src, dst, count)</code></strong> moves the array of <code>count</code> values in memory starting at <code>src</code> to the memory at <code>dst</code>, just as if you had written a loop of <code>read</code> and <code>write</code> calls to move them one at a time. The destination memory must be uninitialized before the call, and afterward the source memory is left uninitialized. The <code>src</code> and <code>dest</code> arguments must be <code>*const T</code> and <code>*mut T</code> raw pointers, and <code>count</code> must be a <code>usize</code>.</p>
	</li>
	<li>
	<p><strong><code>std::ptr::copy_nonoverlapping(src, dst, count)</code></strong> is like the corresponding call to <code>copy</code>, except that its contract further requires that the source and destination blocks of memory must not overlap. This may be slightly faster than calling <code>copy</code>.</p>
	</li>
</ul>

<p>There are two other families of <code>read</code> and <code>write</code> functions, also in the <code>std::ptr</code> <span class="keep-together">module:</span></p>

<ul>
	<li>
	<p>The <strong><code>read_unaligned</code></strong> and <strong><code>write_unaligned</code></strong> functions are like <code>read</code> and <code>write</code>, except that the pointer need not be aligned as normally required for the referent type. These functions may be slower than the plain <code>read</code> and <code>write</code> functions.</p>
	</li>
	<li>
	<p>The <strong><code>read_volatile</code></strong> and <strong><code>write_volatile</code></strong> functions are the equivalent of volatile reads and writes in C or C++.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html24" data-type="indexterm" id="idm45251562861752"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html23" data-type="indexterm" id="idm45251562860408"/></p>
	</li>
</ul>
</div></section><!-- Moving into and out of Memory -->

<section data-type="sect2" data-pdf-bookmark="Example: GapBuffer"><div class="sect2" id="example-gapbuffer">
<h2>Example: GapBuffer</h2>

<p><a contenteditable="false" data-primary="GapBuffer" data-type="indexterm" id="C21-unsafe.html25"/><a contenteditable="false" data-primary="raw pointers" data-secondary="GapBuffer example" data-type="indexterm" id="C21-unsafe.html26"/><a contenteditable="false" data-primary="text" data-secondary="GapBuffer" data-type="indexterm" id="C21-unsafe.html27"/>Here’s an example that puts the raw pointer functions just described to use.</p>

<p>Suppose you’re writing a text editor, and you’re looking for a type to represent the text. You could choose <code>String</code>, and use the <code>insert</code> and <code>remove</code> methods to insert and delete characters as the user types. But if they’re editing text at the beginning of a large file, those methods can be expensive: inserting a new character involves shifting the entire rest of the string to the right in memory, and deletion shifts it all back to the left. You’d like such common operations to be cheaper.</p>

<p>The Emacs text editor uses a simple data structure called a <em>gap buffer</em> which can insert and delete characters in constant time. Whereas a <code>String</code> keeps all its spare capacity at the end of the text, which makes <code>push</code> and <code>pop</code> cheap, a gap buffer keeps its spare capacity in the midst of the text, at the point where editing is taking place. This spare capacity is called the <em>gap</em>. Inserting or deleting elements at the gap is cheap: you simply shrink or enlarge the gap as needed. You can move the gap to any location you like by shifting text from one side of the gap to the other. When the gap is empty, you migrate to a larger buffer.</p>

<p>While insertion and deletion in a gap buffer are fast, changing the position at which they take place entails moving the gap to the new position. Shifting the elements requires time proportional to the distance being moved. Fortunately, typical editing activity involves making a bunch of changes in one neighborhood of the buffer before going off and fiddling with text someplace else.</p>

<p>In this section we’ll implement a gap buffer in Rust. To avoid being distracted by UTF-8, we’ll make our buffer store <code>char</code> values directly, but the principles of operation would be the same if we stored the text in some other form.</p>

<p>First, we’ll show a gap buffer in action. This code creates a <code>GapBuffer</code>, inserts some text in it, and then moves the insertion point to sit just before the last word:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">gap</code>::<code class="n">GapBuffer</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">buf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">GapBuffer</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">buf</code><code class="p">.</code><code class="n">insert_iter</code><code class="p">(</code><code class="s">"Lord of the Rings"</code><code class="p">.</code><code class="n">chars</code><code class="p">());</code><code class="w"/>
<code class="n">buf</code><code class="p">.</code><code class="n">set_position</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code><code class="w"/></pre>

<p>After running this code, the buffer looks as shown in <a data-type="xref" href="#unsafe-gap-lotr">Figure 21-6</a>.</p>

<figure><div id="unsafe-gap-lotr" class="figure"><img src="Images/rust_2106.png" alt="A gap buffer containing the text &quot;Lord of the Rings&quot;.          The buffer has capacity for 28 characters, but contains only 17.          The first twelve characters appear at the left,          followed by an eleven-character gap,          followed by the remaining five characters."/>
<h6><span class="label">Figure 21-6. </span>A gap buffer containing some text</h6>
</div></figure>

<p>Insertion is a matter of filling in the gap with new text. This code adds a word and ruins the film:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">buf</code><code class="p">.</code><code class="n">insert_iter</code><code class="p">(</code><code class="s">"Onion "</code><code class="p">.</code><code class="n">chars</code><code class="p">());</code><code class="w"/></pre>

<p>This results in the state shown in <a data-type="xref" href="#unsafe-gap-lotor">Figure 21-7</a>.</p>

<figure><div id="unsafe-gap-lotor" class="figure"><img src="Images/rust_2107.png" alt="A gap buffer containing the text &quot;Lord of the Onion Rings&quot;.          The buffer has capacity for 28 characters, but contains only 23.          The first 18 characters appear at the left,          followed by a five-character gap,          followed by the remaining five characters."/>
<h6><span class="label">Figure 21-7. </span>A gap buffer containing some more text</h6>
</div></figure>

<p>Here’s our <code>GapBuffer</code> type:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">mod</code> <code class="nn">gap</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Range</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">GapBuffer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Storage for elements. This has the capacity we need, but its length</code>
<code class="w">        </code><code class="c1">// always remains zero. GapBuffer puts its elements and the gap in this</code>
<code class="w">        </code><code class="c1">// `Vec`'s "unused" capacity.</code>
<code class="w">        </code><code class="n">storage</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>

<code class="w">        </code><code class="c1">// Range of uninitialized elements in the middle of `storage`.</code>
<code class="w">        </code><code class="c1">// Elements before and after this range are always initialized.</code>
<code class="w">        </code><code class="n">gap</code>: <code class="nc">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><code>GapBuffer</code> uses its <code>storage</code> field in a strange way.<sup><a data-type="noteref" id="idm45251562666632-marker" href="ch21.xhtml#idm45251562666632">2</a></sup> It never actually stores any elements in the vector—or not quite. It simply calls <code>Vec::with_capacity(n)</code> to get a block of memory large enough to hold <code>n</code> values, obtains raw pointers to that memory via the vector’s <code>as_ptr</code> and <code>as_mut_ptr</code> methods, and then uses the buffer directly for its own purposes. The vector’s length always remains zero. When the <code>Vec</code> gets dropped, the <code>Vec</code> doesn’t try to free its elements, because it doesn’t know it has any, but it does free the block of memory. This is what <code>GapBuffer</code> wants; it has its own <code>Drop</code> implementation that knows where the live elements are and drops them correctly.</p>

<p><code>GapBuffer</code>’s simplest methods are what you’d expect:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">GapBuffer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">GapBuffer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">GapBuffer</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">storage</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">(),</code><code class="w"> </code><code class="n">gap</code>: <code class="mi">0</code><code class="p">..</code><code class="mi">0</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Return the number of elements this GapBuffer could hold without</code>
<code class="w">    </code><code class="sd">/// reallocation.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">capacity</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">storage</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Return the number of elements this GapBuffer currently holds.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">len</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Return the current insertion position.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">position</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>It cleans up many of the following functions to have a utility method that returns a raw pointer to the buffer element at a given index. This being Rust, we end up needing one method for <code>mut</code> pointers and one for <code>const</code>. Unlike the preceding methods, these are not public. Continuing this <code>impl</code> block:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Return a pointer to the `index`'th element of the underlying storage,</code>
<code class="sd">/// regardless of the gap.</code>
<code class="sd">///</code>
<code class="sd">/// Safety: `index` must be a valid index into `self.storage`.</code>
<code class="k">unsafe</code><code class="w"> </code><code class="k">fn</code> <code class="nf">space</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">index</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">storage</code><code class="p">.</code><code class="n">as_ptr</code><code class="p">().</code><code class="n">offset</code><code class="p">(</code><code class="n">index</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="sd">/// Return a mutable pointer to the `index`'th element of the underlying</code>
<code class="sd">/// storage, regardless of the gap.</code>
<code class="sd">///</code>
<code class="sd">/// Safety: `index` must be a valid index into `self.storage`.</code>
<code class="k">unsafe</code><code class="w"> </code><code class="k">fn</code> <code class="nf">space_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">index</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">storage</code><code class="p">.</code><code class="n">as_mut_ptr</code><code class="p">().</code><code class="n">offset</code><code class="p">(</code><code class="n">index</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>To find the element at a given index, you must consider whether the index falls before or after the gap, and adjust appropriately:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Return the offset in the buffer of the `index`'th element, taking</code>
<code class="sd">/// the gap into account. This does not check whether index is in range,</code>
<code class="sd">/// but it never returns an index in the gap.</code>
<code class="k">fn</code> <code class="nf">index_to_raw</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">index</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">index</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">index</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="sd">/// Return a reference to the `index`'th element,</code>
<code class="sd">/// or `None` if `index` is out of bounds.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">get</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">index</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">raw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">index_to_raw</code><code class="p">(</code><code class="n">index</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">raw</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// We just checked `raw` against self.capacity(),</code>
<code class="w">            </code><code class="c1">// and index_to_raw skips the gap, so this is safe.</code>
<code class="w">            </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;*</code><code class="bp">self</code><code class="p">.</code><code class="n">space</code><code class="p">(</code><code class="n">raw</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When we start making insertions and deletions in a different part of the buffer, we need to move the gap to the new location. Moving the gap to the right entails shifting elements to the left, and vice versa, just as the bubble in a spirit level moves in one direction when the fluid flows in the other:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Set the current insertion position to `pos`.</code>
<code class="sd">/// If `pos` is out of bounds, panic.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">set_position</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">pos</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">panic</code><code class="o">!</code><code class="p">(</code><code class="s">"index {} out of range for GapBuffer"</code><code class="p">,</code><code class="w"> </code><code class="n">pos</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">gap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">clone</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// `pos` falls after the gap. Move the gap right</code>
<code class="w">            </code><code class="c1">// by shifting elements after the gap to before it.</code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">distance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">copy</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space</code><code class="p">(</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="p">),</code><code class="w"/>
<code class="w">                           </code><code class="bp">self</code><code class="p">.</code><code class="n">space_mut</code><code class="p">(</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="p">),</code><code class="w"/>
<code class="w">                           </code><code class="n">distance</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// `pos` falls before the gap. Move the gap left</code>
<code class="w">            </code><code class="c1">// by shifting elements before the gap to after it.</code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">distance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">pos</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">copy</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space</code><code class="p">(</code><code class="n">pos</code><code class="p">),</code><code class="w"/>
<code class="w">                           </code><code class="bp">self</code><code class="p">.</code><code class="n">space_mut</code><code class="p">(</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">distance</code><code class="p">),</code><code class="w"/>
<code class="w">                           </code><code class="n">distance</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">gap</code><code class="p">.</code><code class="n">len</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function uses the <code>std::ptr::copy</code> method to shift the elements; <code>copy</code> requires that the destination be uninitialized, and leaves the source uninitialized. The source and destination ranges may overlap, but <code>copy</code> handles that case correctly. Since the gap is uninitialized memory before the call, and the function adjusts the gap’s position to cover space vacated by the copy, the <code>copy</code> function’s contract is satisfied.</p>

<p>Element insertion and removal are relatively simple. Insertion takes over one space from the gap for the new element, whereas removal moves one value out, and enlarges the gap to cover the space it used to occupy:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Insert `elt` at the current insertion position,</code>
<code class="sd">/// and leave the insertion position after it.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">insert</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">elt</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">enlarge_gap</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">write</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space_mut</code><code class="p">(</code><code class="n">index</code><code class="p">),</code><code class="w"> </code><code class="n">elt</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="sd">/// Insert the elements produced by `iter` at the current insertion</code>
<code class="sd">/// position, and leave the insertion position after them.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">insert_iter</code><code class="o">&lt;</code><code class="n">I</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">iterable</code>: <code class="nc">I</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">I</code>: <code class="nb">IntoIterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">=</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">iterable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">item</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="sd">/// Remove the element just after the insertion position</code>
<code class="sd">/// and return it, or return `None` if the insertion position</code>
<code class="sd">/// is at the end of the GapBuffer.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">remove</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">None</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">read</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">element</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Similar to the way <code>Vec</code> uses <code>std::ptr::write</code> for push and <code>std::ptr::read</code> for <code>pop</code>, <code>GapBuffer</code> uses <code>write</code> for <code>insert</code>, and <code>read</code> for <code>remove</code>. And just as <code>Vec</code> must adjust its length to maintain the boundary between initialized elements and spare capacity, <code>GapBuffer</code> adjusts its gap.</p>

<p>When the gap has been filled in, the <code>insert</code> method must grow the buffer to acquire more free space. The <code>enlarge_gap</code> method (the last in the <code>impl</code> block) handles this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Double the capacity of `self.storage`.</code>
<code class="k">fn</code> <code class="nf">enlarge_gap</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">new_capacity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">new_capacity</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// The existing vector is empty.</code>
<code class="w">        </code><code class="c1">// Choose a reasonable starting capacity.</code>
<code class="w">        </code><code class="n">new_capacity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">4</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// We have no idea what resizing a Vec does with its "unused"</code>
<code class="w">    </code><code class="c1">// capacity. So just create a new vector and move over the elements.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">new</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">with_capacity</code><code class="p">(</code><code class="n">new_capacity</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">after_gap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">new_gap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">new</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">after_gap</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Move the elements that fall before the gap.</code>
<code class="w">        </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">copy_nonoverlapping</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space</code><code class="p">(</code><code class="mi">0</code><code class="p">),</code><code class="w"/>
<code class="w">                                      </code><code class="n">new</code><code class="p">.</code><code class="n">as_mut_ptr</code><code class="p">(),</code><code class="w"/>
<code class="w">                                      </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="c1">// Move the elements that fall after the gap.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">new_gap_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">new</code><code class="p">.</code><code class="n">as_mut_ptr</code><code class="p">().</code><code class="n">offset</code><code class="p">(</code><code class="n">new_gap</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">isize</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">copy_nonoverlapping</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="p">),</code><code class="w"/>
<code class="w">                                      </code><code class="n">new_gap_end</code><code class="p">,</code><code class="w"/>
<code class="w">                                      </code><code class="n">after_gap</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// This frees the old Vec, but drops no elements,</code>
<code class="w">    </code><code class="c1">// because the Vec's length is zero.</code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">storage</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">new</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">new_gap</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Whereas <code>set_position</code> must use <code>copy</code> to move elements back and forth in the gap, <code>enlarge_gap</code> can use <code>copy_nonoverlapping</code>, since it is moving elements to an entirely new buffer.</p>

<p>Moving the new vector into <code>self.storage</code> drops the old vector. Since its length is zero, the old vector believes it has no elements to drop, and simply frees its buffer. Neatly, <code>copy_nonoverlapping</code> leaves its source uninitialized, so the old vector is correct in this belief: all the elements are now owned by the new vector.</p>

<p>Finally, we need to make sure that dropping a <code>GapBuffer</code> drops all its elements:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">GapBuffer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">start</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">drop_in_place</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space_mut</code><code class="p">(</code><code class="n">i</code><code class="p">));</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">drop_in_place</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space_mut</code><code class="p">(</code><code class="n">i</code><code class="p">));</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The elements lie before and after the gap, so we iterate over each region and use the <code>std::ptr::drop_in_place</code> function to drop each one. The <code>drop_in_place</code> function is a utility that behaves like <code>drop(std::ptr::read(ptr))</code>, but doesn’t bother moving the value to its caller (and hence works on unsized types). And just as in <code>enlarge_gap</code>, by the time the vector <code>self.storage</code> is dropped, its buffer really is uninitialized.</p>

<p>Like the other types we’ve shown in this chapter, <code>GapBuffer</code> ensures that its own invariants are sufficient to ensure that the contract of every unsafe feature it uses is followed, so none of its public methods need be marked unsafe. <code>GapBuffer</code> implements a safe interface for a feature that cannot be written efficiently in safe code.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html27" data-type="indexterm" id="idm45251561233896"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html26" data-type="indexterm" id="idm45251561232520"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html25" data-type="indexterm" id="idm45251561231144"/></p>
</div></section><!-- Example: GapBuffer -->

<section data-type="sect2" data-pdf-bookmark="Panic Safety in Unsafe Code"><div class="sect2" id="panic-safety-in-unsafe-code">
<h2>Panic Safety in Unsafe Code</h2>

<p><a contenteditable="false" data-primary="panic" data-secondary="safety in unsafe code" data-type="indexterm" id="idm45251561228072"/><a contenteditable="false" data-primary="raw pointers" data-secondary="panic safety in unsafe code" data-type="indexterm" id="idm45251561226696"/><a contenteditable="false" data-primary="unsafe code" data-secondary="panic safety in" data-type="indexterm" id="idm45251561225256"/>In Rust, panics can’t usually cause undefined behavior; the <code>panic!</code> macro is not an unsafe feature. But when you decide to work with unsafe code, panic safety becomes part of your job.</p>

<p class="pagebreak-before">Consider the <code>GapBuffer::remove</code> method from the previous section:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">remove</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">capacity</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">None</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">read</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">space</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">gap</code><code class="p">.</code><code class="n">end</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">element</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The call to <code>read</code> moves the element immediately after the gap out of the buffer, leaving behind uninitialized space. Fortunately, the very next statement enlarges the gap to cover that space, so by the time we return, everything is as it should be: all elements outside the gap are initialized, and all elements inside the gap are uninitialized.</p>

<p>But consider what would happen if, after the call to <code>read</code> but before the adjustment to <code>self.gap.end</code>, this code tried to use a feature that might panic—say, indexing a slice. Exiting the method abruptly anywhere between those two actions would leave the <code>GapBuffer</code> with an uninitialized element outside the gap. The next call to <code>remove</code> could try to <code>read</code> it again; and even simply dropping the <code>GapBuffer</code> would try to drop it. Both are undefined behavior, because they access uninitialized memory.</p>

<p>It’s all but unavoidable for a type’s methods to momentarily relax the type’s invariants while they do their job, and then put everything back to rights before they return. A panic mid-method could cut that cleanup process short, leaving the type in an inconsistent state.</p>

<p>If the type uses only safe code, then this inconsistency may make the type misbehave, but it can’t introduce undefined behavior. But code using unsafe features is usually counting on its invariants to meet the contracts of those features. Broken invariants lead to broken contracts, which lead to undefined behavior.</p>

<p>When working with unsafe features, you must take special care to identify these sensitive regions, and ensure that they do nothing that might panic.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html18" data-type="indexterm" id="idm45251560961784"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html17" data-type="indexterm" id="idm45251560960408"/></p>
</div></section><!-- Panic Safety in Unsafe Code -->
</div></section><!-- Raw Pointers -->

<section data-type="sect1" data-pdf-bookmark="Foreign Functions: Calling C and C++ from Rust"><div class="sect1" id="foreign-functions-calling-c-and-c-from-rust">
<h1>Foreign Functions: Calling C and C++ from Rust</h1>

<p><a contenteditable="false" data-primary="foreign functions" data-type="indexterm" id="C21-unsafe.html28"/><a contenteditable="false" data-primary="libgit2" data-type="indexterm" id="C21-unsafe.html29"/><a contenteditable="false" data-primary="unsafe code" data-secondary="foreign functions" data-type="indexterm" id="C21-unsafe.html30"/>Rust’s <em>foreign function interface</em> lets Rust code call functions written in C or C++.</p>

<p>In this section, we’ll write a program that links with <code>libgit2</code>, a C library for working with the Git version control system. First, we’ll show what it’s like to use C functions directly from Rust. Then, we’ll show how to construct a safe interface to <code>libgit2</code>, taking inspiration from the open source <code>git2-rs</code> crate, which does exactly that.</p>

<p>We’ll assume that you’re familiar with C and the mechanics of compiling and linking C programs. Working with C++ is similar. We’ll also assume that you’re somewhat familiar with the Git version control system.</p>

<section data-type="sect2" data-pdf-bookmark="Finding Common Data Representations"><div class="sect2" id="finding-common-data-representations">
<h2>Finding Common Data Representations</h2>

<p><a contenteditable="false" data-primary="foreign functions" data-secondary="finding common data representations" data-type="indexterm" id="C21-unsafe.html31"/>The <a contenteditable="false" data-primary="machine language" data-type="indexterm" id="idm45251560945816"/>common denominator of Rust and C is machine language, so in order to anticipate what Rust values look like to C code, or vice versa, you need to consider their machine-level representations. Throughout the book, we’ve made a point of showing how values are actually represented in memory, so you’ve probably noticed that the data worlds of C and Rust have a lot in common: a Rust <code>usize</code> and a C <code>size_t</code> are identical, for example, and structs are fundamentally the same idea in both languages. To establish a correspondence between Rust and C types, we’ll start with primitives and then work our way up to more complicated types.</p>

<p><a contenteditable="false" data-primary="C" data-secondary="type representation" data-type="indexterm" id="C21-unsafe.html32"/>Given its primary use as a systems programming language, C has always been surprisingly loose about its types’ representations: an <code>int</code> is typically 32 bits long, but could be longer, or as short as 16 bits; a C <code>char</code> may be signed or unsigned; and so on. To cope with this variability, Rust’s <code>std::os::raw</code> module defines a set of Rust types that are guaranteed to have the same representation as certain C types. These cover the primitive integer and character types:</p>

<table>
	<thead>
		<tr class="header">
			<th>C type</th>
			<th>Corresponding std::os::raw type</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td><code>short</code></td>
			<td><code>c_short</code></td>
		</tr>
		<tr class="even">
			<td><code>int</code></td>
			<td><code>c_int</code></td>
		</tr>
		<tr class="odd">
			<td><code>long</code></td>
			<td><code>c_long</code></td>
		</tr>
		<tr class="even">
			<td><code>long long</code></td>
			<td><code>c_longlong</code></td>
		</tr>
		<tr class="odd">
			<td><code>unsigned short</code></td>
			<td><code>c_ushort</code></td>
		</tr>
		<tr class="even">
			<td><code>unsigned</code>, <code>unsigned int</code></td>
			<td><code>c_uint</code></td>
		</tr>
		<tr class="odd">
			<td><code>unsigned long</code></td>
			<td><code>c_ulong</code></td>
		</tr>
		<tr class="even">
			<td><code>unsigned long long</code></td>
			<td><code>c_ulonglong</code></td>
		</tr>
		<tr class="odd">
			<td><code>char</code></td>
			<td><code>c_char</code></td>
		</tr>
		<tr class="even">
			<td><code>signed char</code></td>
			<td><code>c_schar</code></td>
		</tr>
		<tr class="odd">
			<td><code>unsigned char</code></td>
			<td><code>c_uchar</code></td>
		</tr>
		<tr class="even">
			<td><code>float</code></td>
			<td><code>c_float</code></td>
		</tr>
		<tr class="odd">
			<td><code>double</code></td>
			<td><code>c_double</code></td>
		</tr>
		<tr class="even">
			<td><code>void *</code>, <code>const void *</code></td>
			<td><code>*mut c_void</code>, <code>*const c_void</code></td>
		</tr>
	</tbody>
</table>

<p>Some notes about the table:</p>

<ul>
	<li>
	<p>Except for <code>c_void</code>, all the Rust types here are aliases for some primitive Rust type: <code>c_char</code>, for example, is either <code>i8</code> or <code>u8</code>.</p>
	</li>
	<li>
	<p>There is no endorsed Rust type corresponding to C’s <code>bool</code>. At the moment, a Rust <code>bool</code> is always either a zero or a one byte, the same representation used by all major C and C++ implementations. However, the Rust language team has not committed to keep this representation in the future, since doing so may close opportunities for optimization.</p>
	</li>
	<li>
	<p>Rust’s 32-bit <code>char</code> type is not the analogue of <code>wchar_t</code>, whose width and encoding vary from one implementation to another. C’s <code>char32_t</code> type is closer, but its encoding is still not guaranteed to be Unicode.</p>
	</li>
	<li>
	<p>Rust’s primitive <code>usize</code> and <code>isize</code> types have the same representations as C’s <code>size_t</code> and <code>ptrdiff_t</code>.</p>
	</li>
	<li>
	<p>C and C++ pointers and C++ references correspond to Rust’s raw pointer types, <code>*mut T</code> and <code>*const T</code>.</p>
	</li>
	<li>
	<p>Technically, the C standard permits implementations to use representations for which Rust has no corresponding type: 36-bit integers, sign-and-magnitude representations for signed values, and so on. In practice, on every platform Rust has been ported to, every common C integer type has a match in Rust, <code>bool</code> aside.</p>
	</li>
</ul>

<p>For defining Rust struct types compatible with C structs, you can use the <code>#[repr(C)]</code> attribute. Placing <code>#[repr(C)]</code> above a struct definition asks Rust to lay out the struct’s fields in memory the same way a C compiler would lay out the analogous C struct type. For example, <code>libgit2</code>’s <em>git2/errors.h</em> header file defines the following C struct to provide details about a previously reported error:</p>

<pre data-code-language="cpp" data-type="programlisting">
<code class="k">typedef</code> <code class="k">struct</code> <code class="p">{</code>
    <code class="kt">char</code> <code class="o">*</code><code class="n">message</code><code class="p">;</code>
    <code class="kt">int</code> <code class="n">klass</code><code class="p">;</code>
<code class="p">}</code> <code class="n">git_error</code><code class="p">;</code></pre>

<p>You can define a Rust type with an identical representation as follows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="cp">#[repr(C)]</code><code class="w"/>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">git_error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">message</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">klass</code>: <code class="nc">c_int</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>#[repr(C)]</code> attribute affects only the layout of the struct itself, not the representations of its individual fields, so to match the C struct, each field must use the C-like type as well: <code>*const c_char</code> for <code>char *</code>, and <code>c_int</code> for <code>int</code>, and so on.</p>

<p>In this particular case, the <code>#[repr(C)]</code> attribute probably doesn’t change the layout of <code>git_error</code>. There really aren’t too many interesting ways to lay out a pointer and an integer. But whereas C and C++ guarantee that a structure’s members appear in memory in the order they’re declared, each at a distinct address, Rust reorders fields to minimize the overall size of the struct, and zero-sized types take up no space. The <code>#[repr(C)]</code> attribute tells Rust to follow C’s rules for the given type.</p>

<p>You can also use <code>#[repr(C)]</code> to control the representation of C-style enums:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="cp">#[repr(C)]</code><code class="w"/>
<code class="k">enum</code> <code class="nc">git_error_code</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">GIT_OK</code><code class="w">         </code><code class="o">=</code><code class="w">  </code><code class="mi">0</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">GIT_ERROR</code><code class="w">      </code><code class="o">=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">GIT_ENOTFOUND</code><code class="w">  </code><code class="o">=</code><code class="w"> </code><code class="o">-</code><code class="mi">3</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">GIT_EEXISTS</code><code class="w">    </code><code class="o">=</code><code class="w"> </code><code class="o">-</code><code class="mi">4</code><code class="p">,</code><code class="w"/>
<code class="w">     </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Normally, Rust plays all sorts of games when choosing how to represent enums. For example, we mentioned the trick Rust uses to store <code>Option&lt;&amp;T&gt;</code> in a single word (if <code>T</code> is sized). Without <code>#[repr(C)]</code>, Rust would use a single byte to represent the <code>git_error_code</code> enum; with <code>#[repr(C)]</code>, Rust uses a value the size of a C <code>int</code>, just as C would.</p>

<p>You can also ask Rust to give an enum the same representation as some integer type. Starting the preceding definition with <code>#[repr(i16)]</code> would give you a 16-bit type with the same representation as the following C++ enum:</p>

<pre data-code-language="cpp" data-type="programlisting">
<code class="cp">#include &lt;stdint.h&gt;</code>

<code class="k">enum</code> <code class="nl">git_error_code</code><code class="p">:</code> <code class="kt">int16_t</code> <code class="p">{</code>
    <code class="n">GIT_OK</code>         <code class="o">=</code>  <code class="mi">0</code><code class="p">,</code>
    <code class="n">GIT_ERROR</code>      <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="n">GIT_ENOTFOUND</code>  <code class="o">=</code> <code class="o">-</code><code class="mi">3</code><code class="p">,</code>
    <code class="n">GIT_EEXISTS</code>    <code class="o">=</code> <code class="o">-</code><code class="mi">4</code><code class="p">,</code>
    <code class="p">...</code>
<code class="p">};</code></pre>

<p><a contenteditable="false" data-primary="C" data-secondary="passing strings between Rust and" data-type="indexterm" id="idm45251560721784"/><a contenteditable="false" data-primary="strings and text" data-secondary="passing between Rust and C" data-type="indexterm" id="idm45251560641624"/>Passing strings between Rust and C is a little harder. C represents a string as a pointer to an array of characters, terminated by a null character. Rust, on the other hand, stores the length of a string explicitly, either as a field of a <code>String</code>, or as the second word of a fat reference <code>&amp;str</code>. Rust strings are not null-terminated; in fact, they may include null characters in their contents, like any other character.</p>

<p>This means that you can’t borrow a Rust string as a C string: if you pass C code a pointer into a Rust string, it could mistake an embedded null character for the end of the string, or run off the end looking for a terminating null that isn’t there. Going the other direction, you may be able to borrow a C string as a Rust <code>&amp;str</code>, as long as its contents are well-formed UTF-8.</p>

<p>This situation effectively forces Rust to treat C strings as types entirely distinct from <code>String</code> and <code>&amp;str</code>. In the <code>std::ffi</code> module, the <code>CString</code> and <code>CStr</code> types represent owned and borrowed null-terminated arrays of bytes. Compared to <code>String</code> and <code>str</code>, the methods on <code>CString</code> and <code>CStr</code> are quite limited, restricted to construction and conversion to other types.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html32" data-type="indexterm" id="idm45251560632840"/> We’ll show these types in action in the next section.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html31" data-type="indexterm" id="idm45251560631336"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Declaring Foreign Functions and Variables"><div class="sect2" id="declaring-foreign-functions-and-variables">
<h2>Declaring Foreign Functions and Variables</h2>

<p><a contenteditable="false" data-primary="declarations" data-type="indexterm" id="C21-unsafe.html33"/><a contenteditable="false" data-primary="foreign functions" data-secondary="declaring foreign functions and variables" data-type="indexterm" id="C21-unsafe.html34"/><a contenteditable="false" data-primary="functions" data-secondary="declaring, with foreign functions" data-type="indexterm" id="C21-unsafe.html35"/><a contenteditable="false" data-primary="variables" data-secondary="declaring, with foreign functions" data-type="indexterm" id="C21-unsafe.html36"/>An <code>extern</code> block declares functions or variables defined in some other library that the final Rust executable will be linked with. For example, every Rust program is linked against the standard C library, so we can tell Rust about the C library’s <code>strlen</code> function like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_char</code><code class="p">;</code><code class="w"/>

<code class="k">extern</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">strlen</code><code class="p">(</code><code class="n">s</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This gives Rust the function’s name and type, while leaving the definition to be linked in later.</p>

<p><a contenteditable="false" data-primary="extern blocks" data-type="indexterm" id="C21-unsafe.html37"/>Rust assumes that functions declared inside <code>extern</code> blocks use C conventions for passing arguments and accepting return values. They are defined as <code>unsafe</code> functions. These are the right choices for <code>strlen</code>: it is indeed a C function; and its specification in C requires that you pass it a valid pointer to a properly terminated string, which is a contract that Rust cannot enforce. (Almost any function that takes a raw pointer must be <code>unsafe</code>: safe Rust can construct raw pointers from arbitrary integers, and dereferencing such a pointer would be undefined behavior.)</p>

<p>With this <code>extern</code> block, we can call <code>strlen</code> like any other Rust function, although its type gives it away as a tourist:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">CString</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">rust_str</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"I'll be back"</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">null_terminated</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CString</code>::<code class="n">new</code><code class="p">(</code><code class="n">rust_str</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">strlen</code><code class="p">(</code><code class="n">null_terminated</code><code class="p">.</code><code class="n">as_ptr</code><code class="p">()),</code><code class="w"> </code><code class="mi">12</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>CString::new</code> function builds a null-terminated C string. It first checks its argument for embedded null characters, since those cannot be represented in a C string, and returns an error if it finds any (hence the need to <code>unwrap</code> the result). Otherwise, it adds a null byte to the end, and returns a <code>CString</code> owning the resulting characters.</p>

<p>The cost of <code>CString::new</code> depends on what type you pass it. It accepts anything that implements <code>Into&lt;Vec&lt;u8&gt;&gt;</code>. Passing a <code>&amp;str</code> entails an allocation and a copy, as the conversion to <code>Vec&lt;u8&gt;</code> builds a heap-allocated copy of the string for the vector to own. But passing a <code>String</code> by value simply consumes the string and takes over its buffer, so unless appending the null character forces the buffer to be resized, the conversion requires no copying of text or allocation at all.</p>

<p><code>CString</code> dereferences to <code>CStr</code>, whose <code>as_ptr</code> method returns a <code>*const c_char</code> pointing at the start of the string. This is the type that <code>strlen</code> expects. In the example, <code>strlen</code> runs down the string, finds the null character that <code>CString::new</code> placed there, and returns the length, as a byte count.</p>

<p>You can also declare global variables in <code>extern</code> blocks. POSIX systems have a global variable named <code>environ</code> that holds the values of the process’s environment variables. In C, it’s declared:</p>

<pre data-code-language="cpp" data-type="programlisting">
<code class="k">extern</code> <code class="kt">char</code> <code class="o">**</code><code class="n">environ</code><code class="p">;</code></pre>

<p>In Rust, you would say:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">CStr</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_char</code><code class="p">;</code><code class="w"/>

<code class="k">extern</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">static</code><code class="w"> </code><code class="n">environ</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">c_char</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>To print the environment’s first element, you could write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="o">!</code><code class="n">environ</code><code class="p">.</code><code class="n">is_null</code><code class="p">()</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">environ</code><code class="p">).</code><code class="n">is_null</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">var</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CStr</code>::<code class="n">from_ptr</code><code class="p">(</code><code class="o">*</code><code class="n">environ</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"first environment variable: {}"</code><code class="p">,</code><code class="w"/>
<code class="w">                 </code><code class="n">var</code><code class="p">.</code><code class="n">to_string_lossy</code><code class="p">())</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>After making sure <code>environ</code> has a first element, the code calls <code>CStr::from_ptr</code> to build a <code>CStr</code> that borrows it. The <code>to_string_lossy</code> method returns a <code>Cow&lt;str&gt;</code>: if the C string contains well-formed UTF-8, the <code>Cow</code> borrows its content as a <code>&amp;str</code>, not including the terminating null byte. Otherwise, <code>to_string_lossy</code> makes a copy of the text in the heap, replaces the ill-formed UTF-8 sequences with the official Unicode replacement character, <code>'�'</code>, and builds an owning <code>Cow</code> from that. Either way, the result implements <code>Display</code>, so you can print it with the <code>{}</code> format parameter.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html37" data-type="indexterm" id="idm45251560325112"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html36" data-type="indexterm" id="idm45251560323704"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html35" data-type="indexterm" id="idm45251560322328"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html34" data-type="indexterm" id="idm45251560320952"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Using Functions from Libraries"><div class="sect2" id="using-functions-from-libraries">
<h2>Using Functions from Libraries</h2>

<p><a contenteditable="false" data-primary="foreign functions" data-secondary="from libraries" data-type="indexterm" id="C21-unsafe.html38"/><a contenteditable="false" data-primary="libraries" data-secondary="foreign functions from" data-type="indexterm" id="C21-unsafe.html39"/>To use functions provided by a particular library, <a contenteditable="false" data-primary="#[link] attribute" data-type="indexterm" id="idm45251560314168"/>you can place a <code>#[link]</code> attribute atop the <code>extern</code> block that names the library Rust should link the executable with. For example, here’s a program that calls <code>libgit2</code>’s initialization and shutdown methods, but does nothing else:</p>

<pre class="pagebreak-before" data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_int</code><code class="p">;</code><code class="w"/>

<code class="cp">#[link(name = </code><code class="s">"git2"</code><code class="cp">)]</code><code class="w"/>
<code class="k">extern</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_libgit2_init</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_libgit2_shutdown</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">git_libgit2_init</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">git_libgit2_shutdown</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>extern</code> block declares the extern functions as before. The <code>#[link(name = "git2")]</code> attribute leaves a note in the crate to the effect that, when Rust creates the final executable or shared library, it should link against the <code>git2</code> library. Rust uses the system linker to build executables; on Unix, this passes the argument <code>-lgit2</code> on the linker command line; on Windows, it passes <code>git2.LIB</code>.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html39" data-type="indexterm" id="idm45251560209960"/></p>

<p><code>#[link]</code> attributes work in library crates, too. When you build a program that depends on other crates, Cargo gathers together the link notes from the entire dependency graph, and includes them all in the final link.</p>

<p>In this example, if you would like to follow along on your own machine, you’ll need to build <code>libgit2</code> for yourself. We used <code>libgit2</code> version 0.25.1, available from <em>https://libgit2.github.com</em>. To compile <code>libgit2</code>, you will need to install the CMake build tool and the Python language; we used CMake version 3.8.0 and Python version 2.7.13, downloaded from <em>https://cmake.org</em> and <em>https://www.python.org</em>.</p>

<p>The full instructions for building <code>libgit2</code> are available on its website, but they’re simple enough that we’ll show the essentials here. <a contenteditable="false" data-primary="Linux" data-secondary="using functions from libraries" data-type="indexterm" id="idm45251560203432"/>On Linux, assume you’ve already unzipped the library’s source into the directory <em>/home/jimb/libgit2-0.25.1</em>:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> <code class="nb">cd</code> /home/jimb/libgit2-0.25.1
<code class="gp">$</code> mkdir build
<code class="gp">$</code> <code class="nb">cd </code>build
<code class="gp">$</code> cmake ..
<code class="gp">$</code> cmake --build .</pre>

<p>On Linux, this produces a shared library <em>/home/jimb/libgit2-0.25.1/build/libgit2.so.0.25.1</em> with the usual nest of symlinks pointing to it, including one named <em>libgit2.so</em>. <a contenteditable="false" data-primary="macOS" data-secondary="using functions from libraries" data-type="indexterm" id="idm45251560198872"/>On macOS, the results are similar, but the library is named <em>libgit2.dylib</em>.</p>

<p><a contenteditable="false" data-primary="Windows" data-secondary="using functions from libraries" data-type="indexterm" id="idm45251560195112"/>On Windows, things are also straightforward. Assume you’ve unzipped the source into the directory <em>C:\Users\JimB\libgit2-0.25.1</em>. In a Visual Studio command prompt:</p>

<pre data-type="programlisting">
&gt; cd C:\Users\JimB\libgit2-0.25.1
&gt; mkdir build
&gt; cd build
&gt; cmake -A x64 ..
&gt; cmake --build .</pre>

<p>These are the same commands as used on Linux, except that you must request a 64-bit build when you run CMake the first time, to match your Rust compiler. (If you have installed the 32-bit Rust toolchain, then you should omit the <code>-A x64</code> flag to the first <code>cmake</code> command.) This produces an import library <em>git2.LIB</em> and a dynamic-link library <em>git2.DLL</em>, both in the directory <em>C:\Users\JimB\libgit2-0.25.1\build\Debug</em>. (The remaining instructions are shown for Unix, except where Windows is substantially different.)</p>

<p>Create the Rust program in a separate directory:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> <code class="nb">cd</code> /home/jimb
<code class="gp">$</code> cargo new --bin git-toy</pre>

<p>Put the code above in <em>src/main.rs</em>. Naturally, if you try to build this, Rust has no idea where to find the <code>libgit2</code> you built:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> <code class="nb">cd </code>git-toy
<code class="gp">$</code> cargo run
<code class="go">   Compiling git-toy v0.1.0 (file:///home/jimb/git-toy)</code>
<code class="go">error: linking with `cc` failed: exit code: 1</code>
<code class="go">  |</code>
<code class="go">  = note: "cc" ... "-l" "git2" ...</code>
<code class="go">  = note: /usr/bin/ld: cannot find -lgit2</code>
<code class="go">          collect2: error: ld returned 1 exit status</code>


<code class="go">error: aborting due to previous error</code>

<code class="go">error: Could not compile `git-toy`.</code>

<code class="go">To learn more, run the command again with --verbose.</code>
<code class="gp">$</code></pre>

<p><a contenteditable="false" data-primary="build script" data-type="indexterm" id="idm45251560055320"/>You can tell Rust where to search for libraries by writing a <em>build script</em>, Rust code that <a contenteditable="false" data-primary="Cargo" data-secondary="build script" data-type="indexterm" id="idm45251560082584"/>Cargo compiles and runs at build time. Build scripts can do all sorts of things: generate code dynamically, compile C code to be included in the crate, and so on. In this case, all you need is to add a library search path to the executable’s link command. When Cargo runs the build script, it parses the build script’s output for information of this sort, so the build script simply needs to print the right magic to its standard output.</p>

<p>To create your build script, add a file named <em>build.rs</em> in the same directory as the <em>Cargo.toml</em> file, with the following contents:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">r"cargo:rustc-link-search=native=/home/jimb/libgit2-0.25.1/build"</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is the right path for Linux; on Windows, you would change the path following the text <code>native=</code> to <code>C:\Users\JimB\libgit2-0.25.1\build\Debug</code>. (We’re cutting some corners to keep this example simple; in a real application, you should avoid using absolute paths in your build script. We cite documentation that shows how to do it right at the end of this section.)</p>

<p>Next, tell Cargo that this is your build script by adding the line <code>build = "build.rs"</code> to the <code>[package]</code> section of your <em>Cargo.toml</em> file. The entire file should now read:</p>

<pre data-type="programlisting">
[package]
name = "git-toy"
version = "0.1.0"
authors = ["You &lt;you@example.com&gt;"]
build = "build.rs"

[dependencies]</pre>

<p>Now you can almost run the program. On macOS it may work immediately; on a Linux system you will probably see something like the following:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo run
<code class="go">   Compiling git-toy v0.1.0 (file:///home/jimb/git-toy)</code>
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.64 secs</code>
<code class="go">     Running `target/debug/git-toy`</code>
<code class="go">target/debug/git-toy: error while loading shared libraries:</code>
<code class="go">libgit2.so.25: cannot open shared object file: No such file or directory</code>
<code class="gp">$</code></pre>

<p>This means that, although Cargo succeeded in linking the executable against the library, it doesn’t know where to find the shared library at run time. Windows reports this failure by popping up a dialog box. On Linux, you must set the <code>LD_LIBRARY_PATH</code> environment variable:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> <code class="nb">export </code><code class="nv">LD_LIBRARY_PATH</code><code class="o">=</code>/home/jimb/libgit2-0.25.1/build:<code class="nv">$LD_LIBRARY_PATH</code>
<code class="gp">$</code> cargo run
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</code>
<code class="go">     Running `target/debug/git-toy`</code>
<code class="gp">$</code></pre>

<p>On macOS, you may need to set <code>DYLD_LIBRARY_PATH</code> instead.</p>

<p>On Windows, you must set the <code>PATH</code> environment variable:</p>

<pre data-type="programlisting">
&gt; set PATH=C:\Users\JimB\libgit2-0.25.1\build\Debug;%PATH%
&gt; cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/git-toy`
&gt;</pre>

<p>Naturally, in a deployed application you’d want to avoid having to set environment variables just to find your library’s code. One alternative is to statically link the C library into your crate. This copies the library’s object files into the crate’s <em>.rlib</em> file, alongside the object files and metadata for the crate’s Rust code. The entire collection then participates in the final link.</p>

<p>It is a Cargo convention that a crate that provides access to a C library should be named <code>LIB-sys</code>, where <code>LIB</code> is the name of the C library. A <code>-sys</code> crate should contain nothing but the statically linked library and Rust modules containing <code>extern</code> blocks and type definitions. Higher-level interfaces then belong in crates that depend on the <code>-sys</code> crate. This allows multiple upstream crates to depend on the same <code>-sys</code> crate, assuming there is a single version of the <code>-sys</code> crate that meets everyone’s needs.</p>

<p>For the full details on Cargo’s support for build scripts and linking with system libraries, see <a href="http://doc.crates.io/guide.html">the online Cargo documentation</a>. It shows how to avoid absolute paths in build scripts, control compilation flags, use tools like <code>pkg-config</code>, and so on. The <code>git2-rs</code> crate also provides good examples to emulate; its build script handles some complex situations.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html38" data-type="indexterm" id="idm45251559964744"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html33" data-type="indexterm" id="idm45251559963368"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="A Raw Interface to libgit2"><div class="sect2" id="a-raw-interface-to-libgit2">
<h2>A Raw Interface to libgit2</h2>

<p><a contenteditable="false" data-primary="foreign functions" data-secondary="raw interface to libgit2" data-type="indexterm" id="C21-unsafe.html40"/><a contenteditable="false" data-primary="libgit2" data-secondary="raw interface to" data-type="indexterm" id="C21-unsafe.html41"/><a contenteditable="false" data-primary="raw interface" data-type="indexterm" id="C21-unsafe.html42"/>Figuring out how to use <code>libgit2</code> properly breaks down into two questions:</p>

<ul>
	<li>
	<p>What does it take to use <code>libgit2</code> functions in Rust?</p>
	</li>
	<li>
	<p>How can we build a safe Rust interface around them?</p>
	</li>
</ul>

<p>We’ll take these questions one at a time. In this section, we’ll write a program that’s essentially a single giant <code>unsafe</code> block filled with nonidiomatic Rust code, reflecting the clash of type systems and conventions that is inherent in mixing languages. We’ll call this the <em>raw</em> interface. The code will be messy, but it will make plain all the steps that must occur for Rust code to use <code>libgit2</code>.</p>

<p>Then, in the next section, we’ll build a safe interface to <code>libgit2</code> that puts Rust’s types to use enforcing the rules <code>libgit2</code> imposes on its users. Fortunately, <code>libgit2</code> is an exceptionally well-designed C library, so the questions that Rust’s safety requirements force us to ask all have pretty good answers, and we can construct an idiomatic Rust interface with no <code>unsafe</code> functions.</p>

<p>The program we’ll write is very simple: it takes a path as a command-line argument, opens the Git repository there, and prints out the head commit. But this is enough to illustrate the key strategies for building safe and idiomatic Rust interfaces.</p>

<p>For the raw interface, the program will end up needing a somewhat larger collection of functions and types from <code>libgit2</code> than we used before, so it makes sense to move the <code>extern</code> block into its own module. We’ll create a file named <em>raw.rs</em> in <em>git-toy/src</em> whose contents are as follows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="cp">#![allow(non_camel_case_types)]</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="p">{</code><code class="n">c_int</code><code class="p">,</code><code class="w"> </code><code class="n">c_char</code><code class="p">,</code><code class="w"> </code><code class="n">c_uchar</code><code class="p">};</code><code class="w"/>

<code class="cp">#[link(name = </code><code class="s">"git2"</code><code class="cp">)]</code><code class="w"/>
<code class="k">extern</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_libgit2_init</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_libgit2_shutdown</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">giterr_last</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">git_error</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_repository_open</code><code class="p">(</code><code class="n">out</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_repository</code><code class="p">,</code><code class="w"/>
<code class="w">                               </code><code class="n">path</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_repository_free</code><code class="p">(</code><code class="n">repo</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_repository</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_reference_name_to_id</code><code class="p">(</code><code class="n">out</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_oid</code><code class="p">,</code><code class="w"/>
<code class="w">                                    </code><code class="n">repo</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_repository</code><code class="p">,</code><code class="w"/>
<code class="w">                                    </code><code class="n">reference</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_commit_lookup</code><code class="p">(</code><code class="n">out</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_commit</code><code class="p">,</code><code class="w"/>
<code class="w">                             </code><code class="n">repo</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_repository</code><code class="p">,</code><code class="w"/>
<code class="w">                             </code><code class="n">id</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">git_oid</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_commit_author</code><code class="p">(</code><code class="n">commit</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">git_commit</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">git_signature</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_commit_message</code><code class="p">(</code><code class="n">commit</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">git_commit</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_commit_free</code><code class="p">(</code><code class="n">commit</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_commit</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">git_repository</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">git_commit</code><code class="w"> </code><code class="p">{}</code><code class="w"/>

<code class="cp">#[repr(C)]</code><code class="w"/>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">git_error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">message</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">klass</code>: <code class="nc">c_int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cp">#[repr(C)]</code><code class="w"/>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">git_oid</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">id</code>: <code class="p">[</code><code class="n">c_uchar</code><code class="p">;</code><code class="w"> </code><code class="mi">20</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nc">git_time_t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">i64</code><code class="p">;</code><code class="w"/>

<code class="cp">#[repr(C)]</code><code class="w"/>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">git_time</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">time</code>: <code class="nc">git_time_t</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">offset</code>: <code class="nc">c_int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cp">#[repr(C)]</code><code class="w"/>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">git_signature</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">name</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">email</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">when</code>: <code class="nc">git_time</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Each item here is modeled on a declaration from <code>libgit2</code>’s own header files. For example, <em>libgit2-0.25.1/include/git2/repository.h</em> includes this declaration:</p>

<pre data-code-language="cpp" data-type="programlisting">
<code class="k">extern</code> <code class="kt">int</code> <code class="nf">git_repository_open</code><code class="p">(</code><code class="n">git_repository</code> <code class="o">**</code><code class="n">out</code><code class="p">,</code> <code class="k">const</code> <code class="kt">char</code> <code class="o">*</code><code class="n">path</code><code class="p">);</code></pre>

<p>This function tries to open the Git repository at <code>path</code>. If all goes well, it creates a <code>git_repository</code> object and stores a pointer to it in the location pointed to by <code>out</code>. The equivalent Rust declaration is the following:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">git_repository_open</code><code class="p">(</code><code class="n">out</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">git_repository</code><code class="p">,</code><code class="w"/>
<code class="w">                           </code><code class="n">path</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"/></pre>

<p>The <code>libgit2</code> public header files define the <code>git_repository</code> type as a typedef for an incomplete struct type:</p>

<pre data-code-language="cpp" data-type="programlisting">
<code class="k">typedef</code> <code class="k">struct</code> <code class="n">git_repository</code> <code class="n">git_repository</code><code class="p">;</code></pre>

<p>Since the details of this type are private to the library, the public headers never define <code>struct git_repository</code>, ensuring that the library’s users can never build an instance of this type themselves. One possible analogue to an incomplete struct type in Rust is this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">git_repository</code><code class="w"> </code><code class="p">{}</code><code class="w"/></pre>

<p>This is an enum type with no variants. There is no way in Rust to make a value of such a type. This is an oddity, but it’s perfect as the reflection of a C type that only <code>libgit2</code> should ever construct, and which is manipulated solely through raw pointers.</p>

<p>Writing large <code>extern</code> blocks by hand can be a chore. If you are creating a Rust interface to a complex C library, you may want to try using the <code>bindgen</code> crate, which has functions you can use from your build script to parse C header files and generate the corresponding Rust declarations automatically. We don’t have space to show <code>bindgen</code> in action here, but <code>bindgen</code>’s page on <a href="https://crates.io/" class="orm:hideurl">crates.io</a> includes links to its documentation.</p>

<p>Next we’ll rewrite <em>main.rs</em> completely. First, we need to declare the <code>raw</code> module:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">mod</code> <code class="nn">raw</code><code class="p">;</code><code class="w"/></pre>

<p>According to <code>libgit2</code>’s conventions, fallible functions return an integer code that is positive or zero on success, and negative on failure. If an error occurs, the <code>giterr_last</code> function will return a pointer to a <code>git_error</code> structure providing more details about what went wrong. <code>libgit2</code> owns this structure, so we don’t need to free it ourselves, but it could be overwritten by the next library call we make. A proper Rust interface would use <code>Result</code>, but in the raw version, we want to use the <code>libgit2</code> functions just as they are, so we’ll have to roll our own function for handling errors:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">CStr</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_int</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">check</code><code class="p">(</code><code class="n">activity</code>: <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">status</code>: <code class="nc">c_int</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">status</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">error</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;*</code><code class="n">raw</code>::<code class="n">giterr_last</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"error while {}: {} ({})"</code><code class="p">,</code><code class="w"/>
<code class="w">                     </code><code class="n">activity</code><code class="p">,</code><code class="w"/>
<code class="w">                     </code><code class="n">CStr</code>::<code class="n">from_ptr</code><code class="p">(</code><code class="n">error</code><code class="p">.</code><code class="n">message</code><code class="p">).</code><code class="n">to_string_lossy</code><code class="p">(),</code><code class="w"/>
<code class="w">                     </code><code class="n">error</code><code class="p">.</code><code class="n">klass</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">std</code>::<code class="n">process</code>::<code class="n">exit</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="n">status</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We’ll use this function to check the results of <code>libgit2</code> calls like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">check</code><code class="p">(</code><code class="s">"initializing library"</code><code class="p">,</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_libgit2_init</code><code class="p">());</code><code class="w"/></pre>

<p>This uses the same <code>CStr</code> methods used earlier: <code>from_ptr</code> to construct the <code>CStr</code> from a C string, and <code>to_string_lossy</code> to turn that into something Rust can print.</p>

<p>Next, we need a function to print out a commit:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">unsafe</code><code class="w"> </code><code class="k">fn</code> <code class="nf">show_commit</code><code class="p">(</code><code class="n">commit</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_commit</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">author</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_commit_author</code><code class="p">(</code><code class="n">commit</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CStr</code>::<code class="n">from_ptr</code><code class="p">((</code><code class="o">*</code><code class="n">author</code><code class="p">).</code><code class="n">name</code><code class="p">).</code><code class="n">to_string_lossy</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">email</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CStr</code>::<code class="n">from_ptr</code><code class="p">((</code><code class="o">*</code><code class="n">author</code><code class="p">).</code><code class="n">email</code><code class="p">).</code><code class="n">to_string_lossy</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{} &lt;{}&gt;</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">email</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">message</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_commit_message</code><code class="p">(</code><code class="n">commit</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">CStr</code>::<code class="n">from_ptr</code><code class="p">(</code><code class="n">message</code><code class="p">).</code><code class="n">to_string_lossy</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Given a pointer to a <code>git_commit</code>, <code>show_commit</code> calls <code>git_commit_author</code> and <code>git_commit_message</code> to retrieve the information it needs. These two functions follow a convention that the <code>libgit2</code> documentation explains as follows:</p>

<blockquote>
<p>If a function returns an object as a return value, that function is a getter and the object’s lifetime is tied to the parent object.</p>
</blockquote>

<p>In Rust terms, <code>author</code> and <code>message</code> are borrowed from <code>commit</code>: <code>show_commit</code> doesn’t need to free them itself, but it must not hold on to them after <code>commit</code> is freed. Since this API uses raw pointers, Rust won’t check their lifetimes for us: if we do accidentally create dangling pointers, we probably won’t find out about it until the program crashes.</p>

<p>The preceding code assumes these fields hold UTF-8 text, which is not always correct. Git permits other encodings as well. Interpreting these strings properly would probably entail using the <code>encoding</code> crate. For brevity’s sake, we’ll gloss over those issues here.</p>

<p>Our program’s <code>main</code> function reads as follows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">CString</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">mem</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ptr</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_char</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">skip</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="n">next</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"usage: git-toy PATH"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CString</code>::<code class="n">new</code><code class="p">(</code><code class="n">path</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"path contains null characters"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">check</code><code class="p">(</code><code class="s">"initializing library"</code><code class="p">,</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_libgit2_init</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">repo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ptr</code>::<code class="n">null_mut</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">check</code><code class="p">(</code><code class="s">"opening repository"</code><code class="p">,</code><code class="w"/>
<code class="w">              </code><code class="n">raw</code>::<code class="n">git_repository_open</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">repo</code><code class="p">,</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="n">as_ptr</code><code class="p">()));</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">c_name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"HEAD</code><code class="se">\0</code><code class="s">"</code><code class="p">.</code><code class="n">as_ptr</code><code class="p">()</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">oid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">mem</code>::<code class="n">uninitialized</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">check</code><code class="p">(</code><code class="s">"looking up HEAD"</code><code class="p">,</code><code class="w"/>
<code class="w">              </code><code class="n">raw</code>::<code class="n">git_reference_name_to_id</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">oid</code><code class="p">,</code><code class="w"> </code><code class="n">repo</code><code class="p">,</code><code class="w"> </code><code class="n">c_name</code><code class="p">));</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">commit</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ptr</code>::<code class="n">null_mut</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">check</code><code class="p">(</code><code class="s">"looking up commit"</code><code class="p">,</code><code class="w"/>
<code class="w">              </code><code class="n">raw</code>::<code class="n">git_commit_lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">commit</code><code class="p">,</code><code class="w"> </code><code class="n">repo</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">oid</code><code class="p">));</code><code class="w"/>

<code class="w">        </code><code class="n">show_commit</code><code class="p">(</code><code class="n">commit</code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="n">raw</code>::<code class="n">git_commit_free</code><code class="p">(</code><code class="n">commit</code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="n">raw</code>::<code class="n">git_repository_free</code><code class="p">(</code><code class="n">repo</code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="n">check</code><code class="p">(</code><code class="s">"shutting down library"</code><code class="p">,</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_libgit2_shutdown</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This starts with code to handle the path argument and initialize the library, all of which we’ve seen before. The first novel code is this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">repo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ptr</code>::<code class="n">null_mut</code><code class="p">();</code><code class="w"/>
<code class="n">check</code><code class="p">(</code><code class="s">"opening repository"</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="n">raw</code>::<code class="n">git_repository_open</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">repo</code><code class="p">,</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="n">as_ptr</code><code class="p">()));</code><code class="w"/></pre>

<p>The call to <code>git_repository_open</code> tries to open the Git repository at the given path. If it succeeds, it allocates a new <code>git_repository</code> object for it, and sets <code>repo</code> to point to that. Rust implicitly coerces references into raw pointers, so passing <code>&amp;mut repo</code> here provides the <code>*mut *mut git_repository</code> the call expects.</p>

<p>This shows another <code>libgit2</code> convention in use. Again, from the <code>libgit2</code> documentation:</p>

<blockquote>
<p>Objects which are returned via the first argument as a pointer-to-pointer are owned by the caller and it is responsible for freeing them.</p>
</blockquote>

<p>In Rust terms, functions like <code>git_repository_open</code> pass ownership of the new value to the caller.</p>

<p>Next, consider the code that looks up the object hash of the repository’s current head commit:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">oid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">mem</code>::<code class="n">uninitialized</code><code class="p">();</code><code class="w"/>
<code class="n">check</code><code class="p">(</code><code class="s">"looking up HEAD"</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="n">raw</code>::<code class="n">git_reference_name_to_id</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">oid</code><code class="p">,</code><code class="w"> </code><code class="n">repo</code><code class="p">,</code><code class="w"> </code><code class="n">c_name</code><code class="p">));</code><code class="w"/></pre>

<p>The <code>git_oid</code> type stores an object identifier—a 160-bit hash code that Git uses internally (and throughout its delightful user interface) to identify commits, individual versions of files, and so on. This call to <code>git_reference_name_to_id</code> looks up the object identifier of the current <code>"HEAD"</code> commit.</p>

<p>In C it’s perfectly normal to initialize a variable by passing a pointer to it to some function that fills in its value; this is how <code>git_reference_name_to_id</code> expects to treat its first argument. But Rust won’t let us borrow a reference to an uninitialized variable. We could initialize <code>oid</code> with zeros, but this is a waste: any value stored there will simply be overwritten.</p>

<p>Initializing <code>oid</code> to <code>uninitialized()</code> gets around this problem. The <code>std::mem::uninitialized</code> function returns a value of any type you like, except that the value consists entirely of uninitialized bits, and no machine code is actually spent producing the value. Rust, however, considers <code>oid</code> to have been assigned some value, so it lets us borrow the reference to it. As you can imagine, in the general case, this is very unsafe. Reading an uninitialized value is undefined behavior, and if any part of the value implements <code>Drop</code>, even dropping it is undefined behavior as well. There are only a few safe things you can do:</p>

<ul>
	<li>
	<p>You can overwrite it with <code>std::ptr::write</code>, which requires its destination to be uninitialized.</p>
	</li>
	<li>
	<p>You can pass it to <code>std::mem::forget</code>, which takes ownership of its argument and makes it disappear without dropping it (applying this to an initialized value might be a leak).</p>
	</li>
	<li>
	<p>You can pass it to a foreign function designed to initialize it, like <code>git_reference_name_to_id</code>.</p>
	</li>
</ul>

<p>If the call succeeds, then <code>oid</code> becomes truly initialized, and all is well. If the call fails, the function doesn’t use <code>oid</code>, and its type doesn’t need to be dropped, so the code is safe in that case too.</p>

<p>We could use <code>uninitialized</code> for the <code>repo</code> and <code>commit</code> variables as well, but since these are just single words and <code>uninitialized</code> is so dicey to use, we just go ahead and initialize them to null:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">commit</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ptr</code>::<code class="n">null_mut</code><code class="p">();</code><code class="w"/>
<code class="n">check</code><code class="p">(</code><code class="s">"looking up commit"</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="n">raw</code>::<code class="n">git_commit_lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">commit</code><code class="p">,</code><code class="w"> </code><code class="n">repo</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">oid</code><code class="p">));</code><code class="w"/></pre>

<p>This takes the commit’s object identifier and looks up the actual commit, storing a <code>git_commit</code> pointer in <code>commit</code> on success.</p>

<p>The remainder of the <code>main</code> function should be self-explanatory. It calls the <code>show_commit</code> function defined earlier, frees the commit and repository objects, and shuts down the library.</p>

<p>Now we can try out the program on any Git repository ready at hand:<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html42" data-type="indexterm" id="idm45251558490296"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html41" data-type="indexterm" id="idm45251558488920"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html40" data-type="indexterm" id="idm45251558487544"/></p>

<pre data-code-language="rust" data-type="programlisting">
<code class="cp">$</code><code class="w"> </code><code class="n">cargo</code><code class="w"> </code><code class="n">run</code><code class="w"> </code><code class="o">/</code><code class="n">home</code><code class="o">/</code><code class="n">jimb</code><code class="o">/</code><code class="n">rbattle</code><code class="w"/>
<code class="w">    </code><code class="n">Finished</code><code class="w"> </code><code class="n">dev</code><code class="w"> </code><code class="p">[</code><code class="n">unoptimized</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">debuginfo</code><code class="p">]</code><code class="w"> </code><code class="n">target</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mf">0.0</code><code class="w"> </code><code class="n">secs</code><code class="w"/>
<code class="w">     </code><code class="n">Running</code><code class="w"> </code><code class="err">`</code><code class="n">target</code><code class="o">/</code><code class="n">debug</code><code class="o">/</code><code class="n">git</code><code class="o">-</code><code class="n">toy</code><code class="w"> </code><code class="o">/</code><code class="n">home</code><code class="o">/</code><code class="n">jimb</code><code class="o">/</code><code class="n">rbattle</code><code class="err">`</code><code class="w"/>
<code class="n">Jim</code><code class="w"> </code><code class="n">Blandy</code><code class="w"> </code><code class="o">&lt;</code><code class="n">jimb</code><code class="o">@</code><code class="n">red</code><code class="o">-</code><code class="n">bean</code><code class="p">.</code><code class="n">com</code><code class="o">&gt;</code><code class="w"/>

<code class="n">Animate</code><code class="w"> </code><code class="n">goop</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="n">bit</code><code class="p">.</code><code class="w"/>

<code class="cp">$</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="A Safe Interface to libgit2"><div class="sect2" id="a-safe-interface-to-libgit2">
<h2>A Safe Interface to libgit2</h2>

<p><a contenteditable="false" data-primary="foreign functions" data-secondary="safe interface to libgit2" data-type="indexterm" id="C21-unsafe.html43"/><a contenteditable="false" data-primary="libgit2" data-secondary="safe interface to" data-type="indexterm" id="C21-unsafe.html44"/><a contenteditable="false" data-primary="safe interface" data-type="indexterm" id="C21-unsafe.html45"/>The raw interface to <code>libgit2</code> is a perfect example of an unsafe feature: it certainly can be used correctly (as we do here, so far as we know), but Rust can’t enforce the rules you must follow. Designing a safe API for a library like this is a matter of identifying all these rules, and then finding ways to turn any violation of them into a type or borrow-checking error.</p>

<p>Here, then, are <code>libgit2</code>’s rules for the features the program uses:</p>

<ul>
	<li>
	<p>You must call <code>git_libgit2_init</code> before using any other library function. You must not use any library function after calling <code>git_libgit2_shutdown</code>.</p>
	</li>
	<li>
	<p>All values passed to <code>libgit2</code> functions must be fully initialized, except for output parameters.</p>
	</li>
	<li>
	<p>When a call fails, output parameters passed to hold the results of the call are left uninitialized, and you must not use their values.</p>
	</li>
	<li>
	<p>A <code>git_commit</code> object refers to the <code>git_repository</code> object it is derived from, so the former must not outlive the latter. (This isn’t spelled out in the <code>libgit2</code> documentation; we inferred it from the presence of certain functions in the interface, and then verified it by reading the source code.)</p>
	</li>
	<li>
	<p>Similarly, a <code>git_signature</code> is always borrowed from a given <code>git_commit</code>, and the former must not outlive the latter. (The documentation does cover this case.)</p>
	</li>
	<li>
	<p>The message associated with a commit and the name and email address of the author are all borrowed from the commit, and must not be used after the commit is freed.</p>
	</li>
	<li>
	<p>Once a <code>libgit2</code> object has been freed, it must never be used again.</p>
	</li>
</ul>

<p>As it turns out, you can build a Rust interface to <code>libgit2</code> that enforces all of these rules, either through Rust’s type system, or by managing details internally.</p>

<p>Before we get started, let’s restructure the project a little bit. We’d like to have a <code>git</code> module that exports the safe interface, of which the raw interface from the previous program is a private submodule.</p>

<p>The whole source tree will look like this:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="go">git-toy/</code>
<code class="go">├── Cargo.toml</code>
<code class="go">├── build.rs</code>
<code class="go">└── src/</code>
<code class="go">    ├── main.rs</code>
<code class="go">    └── git/</code>
<code class="go">        ├── mod.rs</code>
<code class="go">        └── raw.rs</code></pre>

<p>Following the rules we explained in <a data-type="xref" href="ch08.xhtml#modules-in-separate-files">“Modules in Separate Files”</a>, the source for the <code>git</code> module appears in <em>git/mod.rs</em>, and the source for its <code>git::raw</code> submodule goes in <em>git/raw.rs</em>.</p>

<p>Once again, we’re going to rewrite <em>main.rs</em> completely. It should start with a declaration of the <code>git</code> module:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">mod</code> <code class="nn">git</code><code class="p">;</code><code class="w"/></pre>

<p>Then, we’ll need to create the <em>git</em> subdirectory, and move <em>raw.rs</em> into it:</p>

<pre data-code-language="console" data-type="programlisting">
<code class="gp">$</code> <code class="nb">cd</code> /home/jimb/git-toy
<code class="gp">$</code> mkdir src/git
<code class="gp">$</code> mv src/raw.rs src/git/raw.rs</pre>

<p>The <code>git</code> module needs to declare its <code>raw</code> submodule. The file <em>src/git/mod.rs</em> must say:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">mod</code> <code class="nn">raw</code><code class="p">;</code><code class="w"/></pre>

<p>Since it’s not <code>pub</code>, this submodule is not visible to the main program.</p>

<p>In a bit we’ll need to use some functions from the <code>libc</code> crate, so we must add a dependency in <em>Cargo.toml</em>. The full file now reads:</p>

<pre data-type="programlisting">
[package]
name = "git-toy"
version = "0.1.0"
authors = ["Jim Blandy &lt;jimb@red-bean.com&gt;"]
build = "build.rs"

[dependencies]
libc = "0.2.23"</pre>

<p>The corresponding <code>extern crate</code> item must appear in <em>src/main.rs</em>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">libc</code><code class="p">;</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="error handling" data-secondary="unsafe code and" data-type="indexterm" id="idm45251558196040"/>Now that we’ve restructured our modules, let’s consider error handling. Even <code>libgit2</code>’s initialization function can return an error code, so we’ll need to have this sorted out before we can get started. An idiomatic Rust interface needs its own <code>Error</code> type that captures the <code>libgit2</code> failure code as well as the error message and class from <code>giterr_last</code>. A proper error type must implement the usual <code>Error</code>, <code>Debug</code>, and <code>Display</code> traits. Then, it needs its own <code>Result</code> type that uses this <code>Error</code> type. Here are the necessary definitions in <em>src/git/mod.rs</em>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">error</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">result</code><code class="p">;</code><code class="w"/>

<code class="cp">#[derive(Debug)]</code><code class="w"/>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">code</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">message</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">class</code>: <code class="kt">i32</code>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Formatter</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">result</code>::<code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Displaying an `Error` simply displays the message from libgit2.</code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">message</code><code class="p">.</code><code class="n">fmt</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">error</code>::<code class="n">Error</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">description</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="kt">str</code> <code class="p">{</code><code class="w"> </code><code class="o">&amp;</code><code class="bp">self</code><code class="p">.</code><code class="n">message</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nb">Result</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">result</code>::<code class="nb">Result</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/></pre>

<p>To check the result from raw library calls, the module needs a function that turns a <code>libgit2</code> return code into a <code>Result</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_int</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">CStr</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">check</code><code class="p">(</code><code class="n">code</code>: <code class="nc">c_int</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">c_int</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">code</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">code</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">error</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">raw</code>::<code class="n">giterr_last</code><code class="p">();</code><code class="w"/>

<code class="w">        </code><code class="c1">// libgit2 ensures that (*error).message is always non-null and null</code>
<code class="w">        </code><code class="c1">// terminated, so this call is safe.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">message</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CStr</code>::<code class="n">from_ptr</code><code class="p">((</code><code class="o">*</code><code class="n">error</code><code class="p">).</code><code class="n">message</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">to_string_lossy</code><code class="p">()</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">into_owned</code><code class="p">();</code><code class="w"/>

<code class="w">        </code><code class="nb">Err</code><code class="p">(</code><code class="n">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">code</code>: <code class="nc">code</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">message</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="n">class</code>: <code class="p">(</code><code class="o">*</code><code class="n">error</code><code class="p">).</code><code class="n">klass</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="w"/>
<code class="w">        </code><code class="p">})</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The main difference between this and the <code>check</code> function from the raw version is that this constructs an <code>Error</code> value instead of printing an error message and exiting immediately.</p>

<p>Now we’re ready to tackle <code>libgit2</code> initialization. The safe interface will provide a <code>Repository</code> type that represents an open Git repository, with methods for resolving references, looking up commits, and so on. Continuing in <em>git/mod.rs</em>, here’s the definition of <code>Repository</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// A Git repository.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Repository</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// This must always be a pointer to a live `git_repository` structure.</code>
<code class="w">    </code><code class="c1">// No other `Repository` may point to it.</code>
<code class="w">    </code><code class="n">raw</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_repository</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A <code>Repository</code>’s <code>raw</code> field is not public. Since only code in this module can access the <code>raw::git_repository</code> pointer, getting this module right should ensure the pointer is always used correctly.</p>

<p>If the only way to create a <code>Repository</code> is to successfully open a fresh Git repository, that will ensure that each <code>Repository</code> points to a distinct <code>git_repository</code> object:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">path</code>::<code class="n">Path</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">Repository</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">open</code><code class="o">&lt;</code><code class="n">P</code>: <code class="nb">AsRef</code><code class="o">&lt;</code><code class="n">Path</code><code class="o">&gt;&gt;</code><code class="p">(</code><code class="n">path</code>: <code class="nc">P</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">Repository</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">ensure_initialized</code><code class="p">();</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">path_to_cstring</code><code class="p">(</code><code class="n">path</code><code class="p">.</code><code class="n">as_ref</code><code class="p">())</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">repo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">null_mut</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">check</code><code class="p">(</code><code class="n">raw</code>::<code class="n">git_repository_open</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">repo</code><code class="p">,</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="n">as_ptr</code><code class="p">()))</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">Repository</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">raw</code>: <code class="nc">repo</code><code class="w"> </code><code class="p">})</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Since the only way to do anything with the safe interface is to start with a <code>Repository</code> value, and <code>Repository::open</code> starts with a call to <code>ensure_initialized</code>, we can be confident that <code>ensure_initialized</code> will be called before any <code>libgit2</code> functions. Its definition is as follows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">libc</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">ensure_initialized</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">static</code><code class="w"> </code><code class="n">ONCE</code>: <code class="nc">std</code>::<code class="n">sync</code>::<code class="n">Once</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">sync</code>::<code class="n">ONCE_INIT</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">ONCE</code><code class="p">.</code><code class="n">call_once</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">check</code><code class="p">(</code><code class="n">raw</code>::<code class="n">git_libgit2_init</code><code class="p">())</code><code class="w"/>
<code class="w">                </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"initializing libgit2 failed"</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">libc</code>::<code class="n">atexit</code><code class="p">(</code><code class="n">shutdown</code><code class="p">),</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">});</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Write</code><code class="p">;</code><code class="w"/>

<code class="k">extern</code><code class="w"> </code><code class="k">fn</code> <code class="nf">shutdown</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">check</code><code class="p">(</code><code class="n">raw</code>::<code class="n">git_libgit2_shutdown</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">io</code>::<code class="n">stderr</code><code class="p">(),</code><code class="w"/>
<code class="w">                             </code><code class="s">"shutting down libgit2 failed: {}"</code><code class="p">,</code><code class="w"/>
<code class="w">                             </code><code class="n">e</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">std</code>::<code class="n">process</code>::<code class="n">abort</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>std::sync::Once</code> type helps run initialization code in a thread-safe way. Only the first thread to call <code>ONCE.call_once</code> runs the given closure. Any subsequent calls, by this thread or any other, block until the first has completed and then return immediately, without running the closure again. Once the closure has finished, calling <code>ONCE.call_once</code> is cheap, requiring nothing more than an atomic load of a flag stored in <code>ONCE</code>.</p>

<p>In the preceding code, the initialization closure calls <code>git_libgit2_init</code> and checks the result. It punts a bit and just uses <code>expect</code> to make sure initialization succeeded, instead of trying to propagate errors back to the caller.</p>

<p>To make sure the program calls <code>git_libgit2_shutdown</code>, the initialization closure uses the C library’s <code>atexit</code> function, which takes a pointer to a function to invoke before the process exits. Rust closures cannot serve as C function pointers: a closure is a value of some anonymous type carrying the values of whatever variables it captures, or references to them; a C function pointer is just a pointer. However, Rust <code>fn</code> types work fine, as long as you declare them <code>extern</code> so that Rust knows to use the C calling conventions. The local function <code>shutdown</code> fits the bill, and ensures <code>libgit2</code> gets shut down properly.</p>

<p>In <a data-type="xref" href="ch07.xhtml#unwinding">“Unwinding”</a>, we mentioned that it is undefined behavior for a panic to cross language boundaries. The call from <code>atexit</code> to <code>shutdown</code> is such a boundary, so it is essential that <code>shutdown</code> not panic. This is why <code>shutdown</code> can’t simply use <code>.expect</code> to handle errors reported from <code>raw::git_libgit2_shutdown</code>. Instead, it must report the error and terminate the process itself. POSIX forbids calling <code>exit</code> within an <code>atexit</code> handler, so <code>shutdown</code> calls <code>std::process::abort</code> to terminate the program abruptly.</p>

<p>It might be possible to arrange to call <code>git_libgit2_shutdown</code> sooner—say, when the last <code>Repository</code> value is dropped. But no matter how we arrange things, calling <code>git_libgit2_shutdown</code> must be the safe API’s responsibility. The moment it is called, any extant <code>libgit2</code> objects become unsafe to use, so a safe API must not expose this function directly.</p>

<p>A <code>Repository</code>’s raw pointer must always point to a live <code>git_repository</code> object. This implies that the only way to close a repository is to drop the <code>Repository</code> value that owns it:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Repository</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">raw</code>::<code class="n">git_repository_free</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>By calling <code>git_repository_free</code> only when the sole pointer to the <code>raw::git_repository</code> is about to go away, the <code>Repository</code> type also ensures the pointer will never be used after it’s freed.</p>

<p>The <code>Repository::open</code> method uses a private function called <code>path_to_cstring</code>, which has two definitions—one for Unix-like systems, and one for Windows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">CString</code><code class="p">;</code><code class="w"/>

<code class="cp">#[cfg(unix)]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">path_to_cstring</code><code class="p">(</code><code class="n">path</code>: <code class="kp">&amp;</code><code class="nc">Path</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">CString</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// The `as_bytes` method exists only on Unix-like systems.</code>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">unix</code>::<code class="n">ffi</code>::<code class="n">OsStrExt</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">CString</code>::<code class="n">new</code><code class="p">(</code><code class="n">path</code><code class="p">.</code><code class="n">as_os_str</code><code class="p">().</code><code class="n">as_bytes</code><code class="p">())</code><code class="o">?</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cp">#[cfg(windows)]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">path_to_cstring</code><code class="p">(</code><code class="n">path</code>: <code class="kp">&amp;</code><code class="nc">Path</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">CString</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Try to convert to UTF-8. If this fails, libgit2 can't handle the path</code>
<code class="w">    </code><code class="c1">// anyway.</code>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="n">to_str</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">CString</code>::<code class="n">new</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="o">?</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">message</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"Couldn't convert path '{}' to UTF-8"</code><code class="p">,</code><code class="w"/>
<code class="w">                                  </code><code class="n">path</code><code class="p">.</code><code class="n">display</code><code class="p">());</code><code class="w"/>
<code class="w">            </code><code class="nb">Err</code><code class="p">(</code><code class="n">message</code><code class="p">.</code><code class="n">into</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>libgit2</code> interface makes this code a little tricky. On all platforms, <code>libgit2</code> accepts paths as null-terminated C strings. On Windows, <code>libgit2</code> assumes these C strings hold well-formed UTF-8 and converts them internally to the 16-bit paths Windows actually requires. This usually works, but it’s not ideal. Windows permits filenames that are not well-formed Unicode, and thus cannot be represented in UTF-8. If you have such a file, it’s impossible to pass its name to <code>libgit2</code>.</p>

<p>In Rust, the proper representation of a filesystem path is a <code>std::path::Path</code>, carefully designed to handle any path that can appear on Windows or POSIX. This means that there are <code>Path</code> values on Windows that one cannot pass to <code>libgit2</code>, because they are not well-formed UTF-8. So although <code>path_to_cstring</code>’s behavior is less than ideal, it’s actually the best we can do given <code>libgit2</code>’s interface.</p>

<p>The two <code>path_to_cstring</code> definitions just shown rely on conversions to our <code>Error</code> type: the <code>?</code> operator attempts such conversions, and the Windows version explicitly calls <code>.into()</code>. These conversions are unremarkable:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">message</code>: <code class="nb">String</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Error</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">code</code>: <code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">message</code><code class="p">,</code><code class="w"> </code><code class="n">class</code>: <code class="mi">0</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// NulError is what `CString::new` returns if a string</code>
<code class="c1">// has embedded zero bytes.</code>
<code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">std</code>::<code class="n">ffi</code>::<code class="n">NulError</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">e</code>: <code class="nc">std</code>::<code class="n">ffi</code>::<code class="n">NulError</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Error</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">code</code>: <code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">message</code>: <code class="nc">e</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"> </code><code class="n">class</code>: <code class="mi">0</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Next, let’s figure out how to resolve a Git reference to an object identifier. Since an object identifier is just a 20 byte hash value, it’s perfectly fine to expose it in the safe API:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// The identifier of some sort of object stored in the Git object</code>
<code class="sd">/// database: a commit, tree, blob, tag, etc. This is a wide hash of the</code>
<code class="sd">/// object's contents.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Oid</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">raw</code>: <code class="nc">raw</code>::<code class="n">git_oid</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We’ll add a method to <code>Repository</code> to perform the lookup:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">uninitialized</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_char</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">Repository</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">reference_name_to_id</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">Oid</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CString</code>::<code class="n">new</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">oid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">uninitialized</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="n">check</code><code class="p">(</code><code class="n">raw</code>::<code class="n">git_reference_name_to_id</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">oid</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">,</code><code class="w"/>
<code class="w">                                                </code><code class="n">name</code><code class="p">.</code><code class="n">as_ptr</code><code class="p">()</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">))</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="nb">Ok</code><code class="p">(</code><code class="n">Oid</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">raw</code>: <code class="nc">oid</code><code class="w"> </code><code class="p">})</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Although <code>oid</code> is left uninitialized when the lookup fails, this function guarantees that its caller can never see the uninitialized value simply by following Rust’s <code>Result</code> idiom: either the caller gets an <code>Ok</code> carrying a properly initialized <code>Oid</code> value, or it gets an <code>Err</code>.</p>

<p>Next, the module needs a way to retrieve commits from the repository. We’ll define a <code>Commit</code> type as follows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">marker</code>::<code class="n">PhantomData</code><code class="p">;</code><code class="w"/>

<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Commit</code><code class="o">&lt;</code><code class="na">'repo</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// This must always be a pointer to a usable `git_commit` structure.</code>
<code class="w">    </code><code class="n">raw</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_commit</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">_marker</code>: <code class="nc">PhantomData</code><code class="o">&lt;&amp;</code><code class="na">'repo</code><code class="w"> </code><code class="n">Repository</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>As we mentioned earlier, a <code>git_commit</code> object must never outlive the <code>git_repository</code> object it was retrieved from. Rust’s lifetimes let the code capture this rule precisely.</p>

<p>The <code>RefWithFlag</code> example earlier in this chapter used a <code>PhantomData</code> field to tell Rust to treat a type as if it contained a reference with a given lifetime, even though the type apparently contained no such reference. The <code>Commit</code> type needs to do something similar. In this case, the <code>_marker</code> field’s type is <code>PhantomData&lt;&amp;'repo Repository&gt;</code>, indicating that Rust should treat <code>Commit&lt;'repo&gt;</code> as if it held a reference with lifetime <code>'repo</code> to some <code>Repository</code>.</p>

<p>The method for looking up a commit is as follows:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">null_mut</code><code class="p">;</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">Repository</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_commit</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">oid</code>: <code class="kp">&amp;</code><code class="nc">Oid</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">Commit</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">commit</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">null_mut</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">check</code><code class="p">(</code><code class="n">raw</code>::<code class="n">git_commit_lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">commit</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">oid</code><code class="p">.</code><code class="n">raw</code><code class="p">))</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">Commit</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">raw</code>: <code class="nc">commit</code><code class="p">,</code><code class="w"> </code><code class="n">_marker</code>: <code class="nc">PhantomData</code><code class="w"> </code><code class="p">})</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>How does this relate the <code>Commit</code>’s lifetime to the <code>Repository</code>’s? The signature of <code>find_commit</code> omits the lifetimes of the references involved according to the rules outlined in <a data-type="xref" href="ch05.xhtml#omitting-lifetime-parameters">“Omitting Lifetime Parameters”</a>. If we were to write the lifetimes out, the full signature would read:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">find_commit</code><code class="o">&lt;</code><code class="na">'repo</code><code class="p">,</code><code class="w"> </code><code class="na">'id</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="na">'repo</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">oid</code>: <code class="kp">&amp;</code><code class="na">'id</code><code class="w"> </code><code class="n">Oid</code><code class="p">)</code><code class="w"/>
<code class="w">    </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">Commit</code><code class="o">&lt;</code><code class="na">'repo</code><code class="o">&gt;&gt;</code><code class="w"/></pre>

<p>This is exactly what we want: Rust treats the returned <code>Commit</code> as if it borrows something from <code>self</code>, which is the <code>Repository</code>.</p>

<p>When a <code>Commit</code> is dropped, it must free its <code>raw::git_commit</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="o">&lt;</code><code class="na">'repo</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Commit</code><code class="o">&lt;</code><code class="na">'repo</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">raw</code>::<code class="n">git_commit_free</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>From a <code>Commit</code>, you can borrow a <code>Signature</code> (a name and email address) and the text of the commit message:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="o">&lt;</code><code class="na">'repo</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Commit</code><code class="o">&lt;</code><code class="na">'repo</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">author</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Signature</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">Signature</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">raw</code>: <code class="nc">raw</code>::<code class="n">git_commit_author</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">),</code><code class="w"/>
<code class="w">                </code><code class="n">_marker</code>: <code class="nc">PhantomData</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">message</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">message</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_commit_message</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">char_ptr_to_str</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">message</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Here’s the <code>Signature</code> type:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Signature</code><code class="o">&lt;</code><code class="na">'text</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">raw</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">raw</code>::<code class="n">git_signature</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">_marker</code>: <code class="nc">PhantomData</code><code class="o">&lt;&amp;</code><code class="na">'text</code><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A <code>git_signature</code> object always borrows its text from elsewhere; in particular, signatures returned by <code>git_commit_author</code> borrow their text from the <code>git_commit</code>. So our safe <code>Signature</code> type includes a <code>PhantomData&lt;&amp;'text str&gt;</code> to tell Rust to behave as if it contained a <code>&amp;str</code> with a lifetime of <code>'text</code>. Just as before, <code>Commit::author</code> properly connects this <code>'text</code> lifetime of the <code>Signature</code> it returns to that of the <code>Commit</code> without us needing to write a thing. The <code>Commit::message</code> method does the same with the <code>Option&lt;&amp;str&gt;</code> holding the commit message.</p>

<p>A <code>Signature</code> includes methods for retrieving the author’s name and email address:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="o">&lt;</code><code class="na">'text</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Signature</code><code class="o">&lt;</code><code class="na">'text</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Return the author's name as a `&amp;str`,</code>
<code class="w">    </code><code class="sd">/// or `None` if it is not well-formed UTF-8.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">name</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">char_ptr_to_str</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">).</code><code class="n">name</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Return the author's email as a `&amp;str`,</code>
<code class="w">    </code><code class="sd">/// or `None` if it is not well-formed UTF-8.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">email</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">char_ptr_to_str</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">raw</code><code class="p">).</code><code class="n">email</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p class="pagebreak-before">The preceding methods depend on a private utility function <code>char_ptr_to_str</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Try to borrow a `&amp;str` from `ptr`, given that `ptr` may be null or</code>
<code class="sd">/// refer to ill-formed UTF-8. Give the result a lifetime as if it were</code>
<code class="sd">/// borrowed from `_owner`.</code>
<code class="sd">///</code>
<code class="sd">/// Safety: if `ptr` is non-null, it must point to a null-terminated C</code>
<code class="sd">/// string that is safe to access.</code>
<code class="k">unsafe</code><code class="w"> </code><code class="k">fn</code> <code class="nf">char_ptr_to_str</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">_owner</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">,</code><code class="w"> </code><code class="n">ptr</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">ptr</code><code class="p">.</code><code class="n">is_null</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">None</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">CStr</code>::<code class="n">from_ptr</code><code class="p">(</code><code class="n">ptr</code><code class="p">).</code><code class="n">to_str</code><code class="p">().</code><code class="n">ok</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>_owner</code> parameter’s value is never used, but its lifetime is. Making the lifetimes in this function’s signature explicit gives us:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">char_ptr_to_str</code><code class="o">&lt;</code><code class="na">'o</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="na">'o</code><code class="o">&gt;</code><code class="p">(</code><code class="n">_owner</code>: <code class="kp">&amp;</code><code class="na">'o</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">ptr</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">c_char</code><code class="p">)</code><code class="w"/>
<code class="w">    </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="na">'o</code><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"/></pre>

<p>The <code>CStr::from_ptr</code> function returns a <code>&amp;CStr</code> whose lifetime is completely unbounded, since it was borrowed from a dereferenced raw pointer. Unbounded lifetimes are almost always inaccurate, so it’s good to constrain them as soon as possible. Including the <code>_owner</code> parameter causes Rust to attribute its lifetime to the return value’s type, so callers can receive a more accurately bounded reference.</p>

<p>It is not clear from the <code>libgit2</code> documentation whether a <code>git_signature</code>’s <code>email</code> and <code>author</code> pointers can be null, and this despite the documentation for <code>libgit2</code> being quite good. Your authors dug around in the source code for some time without being able to persuade themselves one way or the other, and finally decided that <code>char_ptr_to_str</code> had better be prepared for null pointers just in case. In Rust, this sort of question is answered immediately by the type: if it’s <code>&amp;str</code>, you can count on the string to be there; if it’s <code>Option&lt;&amp;str&gt;</code>, it’s optional.</p>

<p>Finally, we’ve provided safe interfaces for all the functionality we need. The new <code>main</code> function in <em>src/main.rs</em> is slimmed down quite a bit, and looks like real Rust code:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args_os</code><code class="p">().</code><code class="n">skip</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="n">next</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"usage: git-toy PATH"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">repo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">git</code>::<code class="n">Repository</code>::<code class="n">open</code><code class="p">(</code><code class="o">&amp;</code><code class="n">path</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"opening repository"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">commit_oid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">repo</code><code class="p">.</code><code class="n">reference_name_to_id</code><code class="p">(</code><code class="s">"HEAD"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"looking up 'HEAD' reference"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">commit</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">repo</code><code class="p">.</code><code class="n">find_commit</code><code class="p">(</code><code class="o">&amp;</code><code class="n">commit_oid</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"looking up commit"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">author</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">commit</code><code class="p">.</code><code class="n">author</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{} &lt;{}&gt;</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"/>
<code class="w">             </code><code class="n">author</code><code class="p">.</code><code class="n">name</code><code class="p">().</code><code class="n">unwrap_or</code><code class="p">(</code><code class="s">"(none)"</code><code class="p">),</code><code class="w"/>
<code class="w">             </code><code class="n">author</code><code class="p">.</code><code class="n">email</code><code class="p">().</code><code class="n">unwrap_or</code><code class="p">(</code><code class="s">"none"</code><code class="p">));</code><code class="w"/>

<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">commit</code><code class="p">.</code><code class="n">message</code><code class="p">().</code><code class="n">unwrap_or</code><code class="p">(</code><code class="s">"(none)"</code><code class="p">));</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In this section, we’ve built a safe API on an unsafe API by arranging for any violation of the latter’s contract to be a Rust type error. The result is an interface that Rust can ensure you are using correctly. For the most part, the rules we’ve made Rust enforce are simply the sorts of rules that C and C++ programmers end up imposing on themselves anyway. What makes Rust feel so much stricter than C and C++ is not that the rules are so foreign, but that that enforcement is mechanical and comprehensive<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html45" data-type="indexterm" id="idm45251555799400"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html44" data-type="indexterm" id="idm45251555798296"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html43" data-type="indexterm" id="idm45251555638808"/>.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html30" data-type="indexterm" id="idm45251555637304"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html29" data-type="indexterm" id="idm45251555635896"/><a contenteditable="false" data-primary="" data-startref="C21-unsafe.html28" data-type="indexterm" id="idm45251555634520"/></p>
</div></section><!-- A Safe Interface to libgit2 -->
</div></section><!-- Foreign Functions: Calling C and C++ from Rust -->

<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion21">
<h1>Conclusion</h1>

<p>Rust is not a simple language. Its goal is to span two very different worlds. It’s a modern programming language, safe by design, with conveniences like closures and iterators; yet it aims to put you in control of the raw capabilities of the machine it runs on, with minimal runtime overhead.</p>

<p>The contours of the language are determined by these goals. Rust manages to bridge most of the gap with safe code. Its borrow checker and zero-cost abstractions put you as close to the bare metal as possible without risking undefined behavior. When that’s not enough, or when you want to leverage existing C code, unsafe code stands ready. But again, the language doesn’t just offer you these unsafe features and wish you luck. The goal is always to use unsafe features to build safe APIs. That’s what we did with <code>libgit2</code>. It’s also what the Rust team has done with <code>Box</code>, <code>Vec</code>, the other collections, channels, and more: the standard library is full of safe abstractions, implemented with some unsafe code behind the scenes.<a contenteditable="false" data-primary="" data-startref="C21-unsafe.html0" data-type="indexterm" id="idm45251555629512"/></p>

<p>A language with Rust’s ambitions was, perhaps, not destined to be the simplest of tools. But Rust is safe, fast, concurrent—and effective. Use it to build large, fast, secure, robust systems that take advantage of the full power of the hardware they run on. Use it to make software better.</p>
</div></section><!-- Conclusion -->
<div data-type="footnotes"><p data-type="footnote" id="idm45251564155464"><sup><a href="ch21.xhtml#idm45251564155464-marker">1</a></sup> Well, it’s a classic where we come from.</p><p data-type="footnote" id="idm45251562666632"><sup><a href="ch21.xhtml#idm45251562666632-marker">2</a></sup> There are better ways to handle this using the <code>RawVec</code> type from the <code>alloc</code> crate, but that crate is still unstable.</p></div></div></section></div></body>
</html>