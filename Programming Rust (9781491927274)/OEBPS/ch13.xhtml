<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Utility Traits"><div class="chapter" id="utility-traits">
<h1><span class="label">Chapter 13. </span>Utility Traits</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>
Science is nothing else than the search to discover unity in the wild variety of nature—or, more exactly, in the variety of our experience. Poetry, painting, the arts are the same search, in Coleridge’s phrase, for unity in variety.
</p>
<p data-type="attribution">
Jacob Bronowski
</p>
</blockquote>

<p><a contenteditable="false" data-primary="utility traits" data-type="indexterm" id="C13-utility.html0"/>Apart from operator overloading, which we covered in the previous chapter, several other built-in traits let you hook into parts of the Rust language and standard library:</p>

<ul>
<li><p>You can use the <code>Drop</code> trait to clean up values when they go out of scope, like destructors in C++.</p></li>
<li><p>Smart pointer types, like <code>Box&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code>, can implement the <code>Deref</code> trait to make the pointer reflect the methods of the wrapped value.</p></li>
<li><p>By implementing the <code>From&lt;T&gt;</code> and <code>Into&lt;T&gt;</code> traits, you can tell Rust how to convert a value from one type to another.</p></li>
</ul>

<p>This chapter is a grab bag of useful traits from the Rust standard library. We’ll cover each of the traits shown in <a data-type="xref" href="#utility-traits-table">Table 13-1</a>.</p>

<p>There are other important standard library traits as well. We’ll cover <code>Iterator</code> and <code>IntoIterator</code> in <a data-type="xref" href="ch15.xhtml#iterators">Chapter 15</a>. The <code>Hash</code> trait, for computing hash codes, is covered in <a data-type="xref" href="ch16.xhtml#collections">Chapter 16</a>. And a pair of traits that mark thread-safe types, <code>Send</code> and <code>Sync</code>, are covered in <a data-type="xref" href="ch19.xhtml#concurrency">Chapter 19</a>.</p>

<table id="utility-traits-table" style="border-collapse: collapse" class="pagebreak-before">
<caption><span class="label">Table 13-1. </span>
Summary of utility traits
</caption>
<thead>
<tr>
<th class="w150">
Trait
</th>
<th>
Description
</th>
</tr>
</thead>
<tr>
<td>
<code>Drop</code>
</td>
<td>
Destructors. Cleanup code that Rust runs automatically whenever a value is dropped.
</td>
</tr>
<tr>
<td>
<code>Sized</code>
</td>
<td>
Marker trait for types with a fixed size known at compile time, as opposed to types (such as slices) that are dynamically sized.
</td>
</tr>
<tr>
<td>
<code>Clone</code>
</td>
<td>
Types that support cloning values.
</td>
</tr>
<tr>
<td>
<code>Copy</code>
</td>
<td>
Marker trait for types that can be cloned simply by making a byte-for-byte copy of the memory containing the value.
</td>
</tr>
<tr>
<td>
<code>Deref</code> and <code>DerefMut</code>
</td>
<td>
Traits for smart pointer types.
</td>
</tr>
<tr>
<td>
<code>Default</code>
</td>
<td>
Types that have a sensible “default value.”
</td>
</tr>
<tr>
<td>
<code>AsRef</code> and <code>AsMut</code>
</td>
<td>
Conversion traits for borrowing one type of reference from another.
</td>
</tr>
<tr>
<td>
<code>Borrow</code> and <code>BorrowMut</code>
</td>
<td>
Conversion traits, like <code>AsRef</code>/<code>AsMut</code>, but additionally guaranteeing consistent hashing, ordering, and equality.
</td>
</tr>
<tr>
<td>
<code>From</code> and <code>Into</code>
</td>
<td>
Conversion traits for transforming one type of value into another.
</td>
</tr>
<tr>
<td>
<code>ToOwned</code>
</td>
<td>
Conversion trait for converting a reference to an owned value.
</td>
</tr>
</table>

<section data-type="sect1" data-pdf-bookmark="Drop"><div class="sect1" id="drop">
<h1>Drop</h1>

<p><a contenteditable="false" data-primary="drop trait" data-type="indexterm" id="C13-utility.html1"/><a contenteditable="false" data-primary="utility traits" data-secondary="drop" data-type="indexterm" id="C13-utility.html2"/>When a value’s owner goes away, we say that Rust <em>drops</em> the value. Dropping a value entails freeing whatever other values, heap storage, and system resources the value owns. Drops occur under a variety of circumstances: when a variable goes out of scope; when an expression’s value is discarded by the <code>;</code> operator; when you truncate a vector, removing elements from its end; and so on.</p>
<p>For the most part, Rust handles dropping values for you automatically. For example, suppose you define the following type:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Appellation</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">nicknames</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>An <code>Appellation</code> owns heap storage for the strings’ contents and the vector’s buffer of elements. Rust takes care of cleaning all that up whenever an <code>Appellation</code> is dropped, without any further coding necessary on your part. However, if you want, you can customize how Rust drops values of your type by implementing the <code>std::ops::Drop</code> trait:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>An implementation of <code>Drop</code> is analogous to a destructor in C++, or a finalizer in other languages. When a value is dropped, if it implements <code>std::ops::Drop</code>, Rust calls its <code>drop</code> method, before proceeding to drop whatever values its fields or elements own, as it normally would. This implicit invocation of <code>drop</code> is the only way to call that method; if you try to invoke it explicitly yourself, Rust flags that as an error.</p>
<p>Because Rust calls <code>Drop::drop</code> on a value before dropping its fields or elements, the value the method receives is always still fully initialized. An implementation of <code>Drop</code> for our <code>Appellation</code> type can make full use of its fields:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Appellation</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">print</code><code class="o">!</code><code class="p">(</code><code class="s">"Dropping {}"</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">name</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="o">!</code><code class="bp">self</code><code class="p">.</code><code class="n">nicknames</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">print</code><code class="o">!</code><code class="p">(</code><code class="s">" (AKA {})"</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">nicknames</code><code class="p">.</code><code class="n">join</code><code class="p">(</code><code class="s">", "</code><code class="p">));</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">""</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Given that implementation, we can write the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Appellation</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code>: <code class="s">"Zeus"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                              </code><code class="n">nicknames</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"cloud collector"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                                              </code><code class="s">"king of the gods"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()]</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"before assignment"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Appellation</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code>: <code class="s">"Hera"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"> </code><code class="n">nicknames</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[]</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"at end of block"</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>When we assign the second <code>Appellation</code> to <code>a</code>, the first is dropped, and when we leave the scope of <code>a</code>, the second is dropped. This code prints the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">before</code><code class="w"> </code><code class="n">assignment</code><code class="w"/>
<code class="n">Dropping</code><code class="w"> </code><code class="n">Zeus</code><code class="w"> </code><code class="p">(</code><code class="n">AKA</code><code class="w"> </code><code class="n">cloud</code><code class="w"> </code><code class="n">collector</code><code class="p">,</code><code class="w"> </code><code class="n">king</code><code class="w"> </code><code class="n">of</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">gods</code><code class="p">)</code><code class="w"/>
<code class="n">at</code><code class="w"> </code><code class="n">end</code><code class="w"> </code><code class="n">of</code><code class="w"> </code><code class="n">block</code><code class="w"/>
<code class="n">Dropping</code><code class="w"> </code><code class="n">Hera</code><code class="w"/></pre>
<p>Since our <code>std::ops::Drop</code> implementation for <code>Appellation</code> does nothing but print a message, how, exactly, does its memory get cleaned up? The <code>Vec</code> type implements <code>Drop</code>, dropping each of its elements and then freeing the heap-allocated buffer they occupied. A <code>String</code> uses a <code>Vec&lt;u8&gt;</code> internally to hold its text, so <code>String</code> need not implement <code>Drop</code> itself; it lets its <code>Vec</code> take care of freeing the characters. The same principle extends to <code>Appellation</code> values: when one gets dropped, in the end it is <code>Vec</code>’s implementation of <code>Drop</code> that actually takes care of freeing each of the strings’ contents, and finally freeing the buffer holding the vector’s elements. As for the memory that holds the <code>Appellation</code> value itself, it too has some owner, perhaps a local variable or some data structure, which is responsible for freeing it.</p>
<p>If a variable’s value gets moved elsewhere, so that the variable is uninitialized when it goes out of scope, then Rust will not try to drop that variable: there is no value in it to drop.</p>
<p>This principle holds even when a variable may or may not have had its value moved away, depending on the flow of control. In cases like this, Rust keeps track of the variable’s state with an invisible flag indicating whether the variable’s value needs to be dropped or not:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">p</code><code class="p">;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">q</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Appellation</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code>: <code class="s">"Cardamine hirsuta"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                          </code><code class="n">nicknames</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"shotweed"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                                          </code><code class="s">"bittercress"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()]</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">complicated_condition</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">q</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Sproing! What was that?"</code><code class="p">);</code><code class="w"/></pre>
<p>Depending on whether <code>complicated_condition</code> returns <code>true</code> or <code>false</code>, either <code>p</code> or <code>q</code> will end up owning the <code>Appellation</code>, with the other uninitialized. Where it lands determines whether it is dropped before or after the <code>println!</code>, since <code>q</code> goes out of scope before the <code>println!</code>, and <code>p</code> after. Although a value may be moved from place to place, Rust drops it only once.</p>
<p>You usually won’t need to implement <code>std::ops::Drop</code> unless you’re defining a type that owns resources Rust doesn’t already know about. For example, on Unix systems, Rust’s standard library uses the following type internally to represent an operating system file descriptor:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">FileDesc</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">fd</code>: <code class="nc">c_int</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>fd</code> field of a <code>FileDesc</code> is simply the number of the file descriptor that should be closed when the program is done with it; <code>c_int</code> is an alias for <code>i32</code>. The standard library implements <code>Drop</code> for <code>FileDesc</code> as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">FileDesc</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">libc</code>::<code class="n">close</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">fd</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Here, <code>libc::close</code> is the Rust name for the C library’s <code>close</code> function. Rust code may call C functions only within <code>unsafe</code> blocks, so the library uses one here.</p>
<p>If a type implements <code>Drop</code>, it cannot implement the <code>Copy</code> trait. If a type is <code>Copy</code>, that means that simple byte-for-byte duplication is sufficient to produce an independent copy of the value. But it is typically a mistake to call the same <code>drop</code> method more than once on the same data.</p>
<p>The standard prelude includes a function to drop a value, <code>drop</code>, but its definition is anything but magical:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">drop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">_x</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>In other words, it receives its argument by value, taking ownership from the caller—and then does nothing with it. Rust drops the value of <code>_x</code> when it goes out of scope, as it would for any other variable.<a contenteditable="false" data-primary="" data-startref="C13-utility.html2" data-type="indexterm" id="idm45251609865656"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html1" data-type="indexterm" id="idm45251609857672"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Sized"><div class="sect1" id="sized">
<h1>Sized</h1>

<p><a contenteditable="false" data-primary="sized type" data-type="indexterm" id="C13-utility.html3"/><a contenteditable="false" data-primary="types" data-secondary="sized type" data-type="indexterm" id="C13-utility.html4"/><a contenteditable="false" data-primary="utility traits" data-secondary="sized" data-type="indexterm" id="C13-utility.html5"/>A <em>sized type</em> is one whose values all have the same size in memory. Almost all types in Rust are sized: every <code>u64</code> takes eight bytes, every <code>(f32, f32, f32)</code> tuple twelve. Even enums are sized: no matter which variant is actually present, an enum always occupies enough space to hold its largest variant. And although a <code>Vec&lt;T&gt;</code> owns a heap-allocated buffer whose size can vary, the <code>Vec</code> value itself is a pointer to the buffer, its capacity, and its length, so <code>Vec&lt;T&gt;</code> is a sized type.</p>
<p><a contenteditable="false" data-primary="unsized types" data-type="indexterm" id="C13-utility.html6"/>However, Rust also has a few <em>unsized types</em> whose values are not all the same size. For example, the string slice type <code>str</code> (note, without an <code>&amp;</code>) is unsized. The string literals <code>"diminutive"</code> and <code>"big"</code> are references to <code>str</code> slices that occupy ten and three bytes. Both are shown in <a data-type="xref" href="#fat-pointer-figure">Figure 13-1</a>. Array slice types like <code>[T]</code> (again, without an <code>&amp;</code>) are unsized, too: a shared reference like <code>&amp;[u8]</code> can point to a <code>[u8]</code> slice of any size. Because the <code>str</code> and <code>[T]</code> types denote sets of values of varying sizes, they are unsized types.</p>
<figure><div id="fat-pointer-figure" class="figure">
<img src="Images/rust_1301.png" alt="Two &amp;str references, comprising a pointer and length, point to str values. A Box&lt;Write&gt;, comprising a data pointer and a vtable pointer, points to some value that implements `std::io::Write`. In all cases, the references are sized types, whereas their referents are unsized." width="1412" height="528"/>
<h6><span class="label">Figure 13-1. </span>
References to unsized values
</h6>
</div></figure>

<p><a contenteditable="false" data-primary="trait objects" data-secondary="unsized types and" data-type="indexterm" id="idm45251609836104"/>The other common kind of unsized type in Rust is the referent of a trait object. As we explained in <a data-type="xref" href="ch11.xhtml#trait-objects">“Trait Objects”</a>, a trait object is a pointer to some value that implements a given trait. For example, the types <code>&amp;std::io::Write</code> and <code>Box&lt;std::io::Write&gt;</code> are pointers to some value that implements the <code>Write</code> trait. The referent might be a file, or a network socket, or some type of your own for which you have implemented <code>Write</code>. Since the set of types that implement <code>Write</code> is open-ended, <code>Write</code> considered as a type is unsized: its values have various sizes.</p>

<p>Rust can’t store unsized values in variables or pass them as arguments. You can only deal with them through pointers like <code>&amp;str</code> or <code>Box&lt;Write&gt;</code>, which themselves are sized. As shown in <a data-type="xref" href="#fat-pointer-figure">Figure 13-1</a>, a pointer to an unsized value is always a <em>fat pointer</em>, two words wide: a pointer to a slice also carries the slice’s length, and a trait object also carries a pointer to a vtable of method implementations.</p>

<p>Trait objects and pointers to slices are nicely symmetrical. In both cases, the type lacks information necessary to use it: you can’t index a <code>[u8]</code> without knowing its length, nor can you invoke a method on a <code>Box&lt;Write&gt;</code> without knowing the implementation of <code>Write</code> appropriate to the specific value it refers to. And in both cases, the fat pointer fills in the information missing from the type, carrying a length or a vtable pointer. The omitted static information is replaced with dynamic information.</p>

<p>All sized types implement the <code>std::marker::Sized</code> trait, which has no methods or associated types. Rust implements it automatically for all types to which it applies; you can’t implement it yourself. The only use for <code>Sized</code> is as a bound for type variables: a bound like <code>T: Sized</code> requires <code>T</code> to be a type whose size is known at compile time. Traits of this sort are called <em>marker traits</em>, because the Rust language itself uses them to mark certain types as having characteristics of interest.</p>

<p>Since unsized types are so limited, most generic type variables should be restricted to <code>Sized</code> types. In fact, this is necessary so often that it is the implicit default in Rust: if you write <code>struct S&lt;T&gt; { ... }</code>, Rust understands you to mean <code>struct S&lt;T: Sized&gt; { ... }</code>. If you do not want to constrain <code>T</code> this way, you must explicitly opt out, writing <code>struct S&lt;T: ?Sized&gt; { ... }</code>. The <code>?Sized</code> syntax is specific to this case, and means “not necessarily <code>Sized</code>.” For example, if you write <code>struct S&lt;T: ?Sized&gt; { b: Box&lt;T&gt; }</code>, then Rust will allow you to write <code>S&lt;str&gt;</code> and <code>S&lt;Write&gt;</code>, where the box becomes a fat pointer, as well as <code>S&lt;i32&gt;</code> and <code>S&lt;String&gt;</code>, where the box is an ordinary pointer.</p>
<p>Despite their restrictions, unsized types make Rust’s type system work more smoothly. Reading the standard library documentation, you will occasionally come across a <code>?Sized</code> bound on a type variable; this almost always means that the given type is only pointed to, and allows the associated code to work with slices and trait objects as well as ordinary values. When a type variable has the <code>?Sized</code> bound, people often say it is <em>questionably sized</em>: it might be <code>Sized</code>, or it might not.</p>
<p>Aside from slices and trait objects, there is one more kind of unsized type. A struct type’s last field (but only its last) may be unsized, and such a struct is itself unsized. For example, an <code>Rc&lt;T&gt;</code> reference-counted pointer is implemented internally as a pointer to the private type <code>RcBox&lt;T&gt;</code>, which stores the reference count alongside the <code>T</code>. Here’s a simplified definition of <code>RcBox</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">RcBox</code><code class="o">&lt;</code><code class="n">T</code>: <code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">ref_count</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">value</code>: <code class="nc">T</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>value</code> field is the <code>T</code> to which <code>Rc&lt;T&gt;</code> is counting references; <code>Rc&lt;T&gt;</code> dereferences to a pointer to this field. The <code>ref_count</code> field holds the reference count.</p>
<p>You can use <code>RcBox</code> with sized types, like <code>RcBox&lt;String&gt;</code>; the result is a sized struct type. Or you can use it with unsized types, like <code>RcBox&lt;std::fmt::Display&gt;</code> (where <code>Display</code> is the trait for types that can be formatted by <code>println!</code> and similar macros); <code>RcBox&lt;Display&gt;</code> is an unsized struct type.</p>
<p>You can’t build an <code>RcBox&lt;Display&gt;</code> value directly. Instead, you must first create an ordinary, sized <code>RcBox</code> whose <code>value</code> type implements <code>Display</code>, like <code>RcBox&lt;String&gt;</code>. Rust then lets you convert a reference <code>&amp;RcBox&lt;String&gt;</code> to a fat reference <code>&amp;RcBox&lt;Display&gt;</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">boxed_lunch</code>: <code class="nc">RcBox</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">RcBox</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">ref_count</code>: <code class="mi">1</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">value</code>: <code class="s">"lunch"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Display</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">boxed_displayable</code>: <code class="kp">&amp;</code><code class="nc">RcBox</code><code class="o">&lt;</code><code class="n">Display</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">boxed_lunch</code><code class="p">;</code><code class="w"/></pre>
<p>This conversion happens implicitly when passing values to functions, so you can pass a <code>&amp;RcBox&lt;String&gt;</code> to a function that expects an <code>&amp;RcBox&lt;Display&gt;</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">display</code><code class="p">(</code><code class="n">boxed</code>: <code class="kp">&amp;</code><code class="nc">RcBox</code><code class="o">&lt;</code><code class="n">Display</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"For your enjoyment: {}"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">boxed</code><code class="p">.</code><code class="n">value</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">display</code><code class="p">(</code><code class="o">&amp;</code><code class="n">boxed_lunch</code><code class="p">);</code><code class="w"/></pre>
<p>This produces the following output<a contenteditable="false" data-primary="" data-startref="C13-utility.html6" data-type="indexterm" id="idm45251609631352"/>:<a contenteditable="false" data-primary="" data-startref="C13-utility.html5" data-type="indexterm" id="idm45251609630008"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html4" data-type="indexterm" id="idm45251609628600"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html3" data-type="indexterm" id="idm45251609627224"/></p>
<pre data-type="programlisting" data-code-language="console"><code class="go">For your enjoyment: lunch</code></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Clone"><div class="sect1" id="clone">
<h1>Clone</h1>

<p><a contenteditable="false" data-primary="Clone trait" data-type="indexterm" id="idm45251609567576"/><a contenteditable="false" data-primary="utility traits" data-secondary="Clone" data-type="indexterm" id="idm45251609566472"/>The <code>std::clone::Clone</code> trait is for types that can make copies of themselves. <code>Clone</code> is defined as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Clone</code>: <code class="nb">Sized</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">clone</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">clone_from</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">source</code>: <code class="kp">&amp;</code><code class="nc">Self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="o">*</code><code class="bp">self</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">source</code><code class="p">.</code><code class="n">clone</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>clone</code> method should construct an independent copy of <code>self</code> and return it. Since this method’s return type is <code>Self</code>, and functions may not return unsized values, the <code>Clone</code> trait itself extends the <code>Sized</code> trait: this has the effect of bounding implementations’ <code>Self</code> types to be <code>Sized</code>.</p>
<p>Cloning a value usually entails allocating copies of anything it owns, as well, so a <code>clone</code> can be expensive, in both time and memory. For example, cloning a <code>Vec&lt;String&gt;</code> not only copies the vector, but also copies each of its <code>String</code> elements. This is why Rust doesn’t just clone values automatically, but instead requires you to make an explicit method call. The reference-counted pointer types like <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> are exceptions: cloning one of these simply increments the reference count and hands you a new pointer.</p>
<p>The <code>clone_from</code> method modifies <code>self</code> into a copy of <code>source</code>. The default definition of <code>clone_from</code> simply clones <code>source</code>, and then moves that into <code>*self</code>. This always works, but for some types, there is a faster way to get the same effect. For example, suppose <code>s</code> and <code>t</code> are <code>String</code>s. The statement <code>s = t.clone();</code> must clone <code>t</code>, drop the old value of <code>s</code>, and then move the cloned value into <code>s</code>; that’s one heap allocation, and one heap deallocation. But if the heap buffer belonging to the original <code>s</code> has enough capacity to hold <code>t</code>’s contents, no allocation or deallocation is necessary: you can simply copy <code>t</code>’s text into <code>s</code>’s buffer, and adjust the length. In generic code, you should use <code>clone_from</code> whenever possible, to permit this optimization when it is available.</p>
<p>If your <code>Clone</code> implementation simply applies <code>clone</code> to each field or element of your type, and then constructs a new value from those clones, and the default definition of <code>clone_from</code> is good enough, then Rust will implement that for you: simply put <code>#[derive(Clone)]</code> above your type definition.</p>
<p>Pretty much every type in the standard library that makes sense to copy implements <code>Clone</code>. Primitive types like <code>bool</code> and <code>i32</code> do. Container types like <code>String</code>, <code>Vec&lt;T&gt;</code>, and <code>HashMap</code> do, too. Some types don’t make sense to copy, like <code>std::sync::Mutex</code>; those don’t implement <code>Clone</code>. Some types like <code>std::fs::File</code> can be copied, but the copy might fail if the operating system doesn’t have the necessary resources; these types don’t implement <code>Clone</code>, since <code>clone</code> must be infallible. Instead, <code>std::fs::File</code> provides a <code>try_clone</code> method, which returns a <code>std::io::Result&lt;File&gt;</code>, which can report a failure.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Copy"><div class="sect1" id="copy">
<h1>Copy</h1>

<p><a contenteditable="false" data-primary="Copy types" data-type="indexterm" id="idm45251609460296"/><a contenteditable="false" data-primary="utility traits" data-secondary="Copy" data-type="indexterm" id="idm45251609459192"/>In <a data-type="xref" href="ch04.xhtml#ownership">Chapter 4</a>, we explained that, for most types, assignment moves values, rather than copying them. Moving values makes it much simpler to track the resources they own. But in <a data-type="xref" href="ch04.xhtml#copy-types-the-exception-to-moves">“Copy Types: The Exception to Moves”</a>, we pointed out the exception: simple types that don’t own any resources can be <code>Copy</code> types, where assignment makes a copy of the source, rather than moving the value and leaving the source uninitialized.</p>
<p>At that time, we left it vague exactly what <code>Copy</code> was, but now we can tell you: a type is <code>Copy</code> if it implements the <code>std::marker::Copy</code> marker trait, which is defined as <span class="keep-together">follows:</span></p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Copy</code>: <code class="nb">Clone</code> <code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>This is certainly easy to implement for your own types:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="nb">Copy</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyType</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>But because <code>Copy</code> is a marker trait with special meaning to the language, Rust permits a type to implement <code>Copy</code> only if a shallow byte-for-byte copy is all it needs. Types that own any other resources, like heap buffers or operating system handles, cannot implement <code>Copy</code>.</p>
<p>Any type that implements the <code>Drop</code> trait cannot be <code>Copy</code>. Rust presumes that if a type needs special clean-up code, it must also require special copying code, and thus can’t be <code>Copy</code>.</p>
<p>As with <code>Clone</code>, you can ask Rust to derive <code>Copy</code> for you, using <code>#[derive(Copy)]</code>. You will often see both derived at once, with <code>#[derive(Copy, Clone)]</code>.</p>
<p>Think carefully before making a type <code>Copy</code>. Although doing so makes the type easier to use, it places heavy restrictions on its implementation. Implicit copies can also be expensive. We explain these factors in detail in <a data-type="xref" href="ch04.xhtml#copy-types-the-exception-to-moves">“Copy Types: The Exception to Moves”</a>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Deref and DerefMut"><div class="sect1" id="deref-and-derefmut">
<h1>Deref and DerefMut</h1>

<p><a contenteditable="false" data-primary="Deref trait" data-type="indexterm" id="C13-utility.html7"/><a contenteditable="false" data-primary="DerefMut trait" data-type="indexterm" id="C13-utility.html8"/><a contenteditable="false" data-primary="utility traits" data-secondary="Deref and DerefMut" data-type="indexterm" id="C13-utility.html9"/>You can specify how dereferencing operators like <code>*</code> and <code>.</code> behave on your types by implementing the <code>std::ops::Deref</code> and <code>std::ops::DerefMut</code> traits. Pointer types like <code>Box&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> implement these traits so that they can behave as Rust’s built-in pointer types do. For example, if you have a <code>Box&lt;Complex&gt;</code> value <code>b</code>, then <code>*b</code> refers to the <code>Complex</code> value that <code>b</code> points to, and <code>b.re</code> refers to its real component. If the context assigns or borrows a mutable reference to the referent, Rust uses the <code>DerefMut</code> (“dereference mutably”) trait; otherwise, read-only access is enough, and it uses <code>Deref</code>.</p>
<p>The traits are defined like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">Deref</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Target</code>: <code class="o">?</code><code class="nb">Sized</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">deref</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">Self</code>::<code class="n">Target</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">trait</code><code class="w"> </code><code class="n">DerefMut</code>: <code class="nc">Deref</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">deref_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Self</code>::<code class="n">Target</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>deref</code> and <code>deref_mut</code> methods take a <code>&amp;Self</code> reference and return a <code>&amp;Self::Target</code> reference. <code>Target</code> should be something that <code>Self</code> contains, owns, or refers to: for <code>Box&lt;Complex&gt;</code> the <code>Target</code> type is <code>Complex</code>. Note that <code>DerefMut</code> extends <code>Deref</code>: if you can dereference something and modify it, certainly you should be able to borrow a shared reference to it as well. Since the methods return a reference with the same lifetime as <code>&amp;self</code>, <code>self</code> remains borrowed for as long as the returned reference lives.</p>
<p>The <code>Deref</code> and <code>DerefMut</code> traits play another role as well. Since <code>deref</code> takes a <code>&amp;Self</code> reference and returns a <code>&amp;Self::Target</code> reference, Rust uses this to automatically convert references of the former type into the latter. In other words, if inserting a <code>deref</code> call would prevent a type mismatch, Rust inserts one for you. Implementing <code>DerefMut</code> enables the corresponding conversion for mutable references. These are called the <em>deref coercions</em>: one type is being “coerced” into behaving as another.</p>
<p>Although the deref coercions aren’t anything you couldn’t write out explicitly yourself, they’re convenient:</p>
<ul>
<li><p>If you have some <code>Rc&lt;String&gt;</code> value <code>r</code>, and want to apply <code>String::find</code> to it, you can simply write <code>r.find('?')</code>, instead of <code>(*r).find('?')</code>: the method call implicitly borrows <code>r</code>, and <code>&amp;Rc&lt;String&gt;</code> coerces to <code>&amp;String</code>, because <code>Rc&lt;T&gt;</code> implements <code>Deref&lt;Target=T&gt;</code>.</p></li>
<li><p>You can use methods like <code>split_at</code> on <code>String</code> values, even though <code>split_at</code> is a method of the <code>str</code> slice type, because <code>String</code> implements <code>Deref&lt;Target=str&gt;</code>. There’s no need for <code>String</code> to reimplement all of <code>str</code>’s methods, since you can coerce a <code>&amp;str</code> from a <code>&amp;String</code>.</p></li>
<li><p>If you have a vector of bytes <code>v</code>, and you want to pass it to a function that expects a byte slice <code>&amp;[u8]</code>, you can simply pass <code>&amp;v</code> as the argument, since <code>Vec&lt;T&gt;</code> implements <code>Deref&lt;Target=[T]&gt;</code>.</p></li>
</ul>

<p>Rust will apply several deref coercions in succession if necessary. For example, using the coercions mentioned before, you can apply <code>split_at</code> directly to an <code>Rc&lt;String&gt;</code>, since <code>&amp;Rc&lt;String&gt;</code> dereferences to <code>&amp;String</code>, which dereferences to <code>&amp;str</code>, which has the <code>split_at</code> method.</p>
<p>For example, suppose you have the following type:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Selector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Elements available in this `Selector`.</code>
<code class="w">    </code><code class="n">elements</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>

<code class="w">    </code><code class="sd">/// The index of the "current" element in `elements`. A `Selector`</code>
<code class="w">    </code><code class="sd">/// behaves like a pointer to the current element.</code>
<code class="w">    </code><code class="n">current</code>: <code class="kt">usize</code>
<code class="p">}</code><code class="w"/></pre>
<p>To make the <code>Selector</code> behave as the doc comment claims, you must implement <code>Deref</code> and <code>DerefMut</code> for the type:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">ops</code>::<code class="p">{</code><code class="n">Deref</code><code class="p">,</code><code class="w"> </code><code class="n">DerefMut</code><code class="p">};</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Deref</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Selector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Target</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">deref</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="o">&amp;</code><code class="bp">self</code><code class="p">.</code><code class="n">elements</code><code class="p">[</code><code class="bp">self</code><code class="p">.</code><code class="n">current</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">DerefMut</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Selector</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">deref_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">elements</code><code class="p">[</code><code class="bp">self</code><code class="p">.</code><code class="n">current</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Given those implementations, you can use a <code>Selector</code> like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Selector</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">elements</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[</code><code class="sc">'x'</code><code class="p">,</code><code class="w"> </code><code class="sc">'y'</code><code class="p">,</code><code class="w"> </code><code class="sc">'z'</code><code class="p">],</code><code class="w"/>
<code class="w">                       </code><code class="n">current</code>: <code class="mi">2</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="c1">// Because `Selector` implements `Deref`, we can use the `*` operator to</code>
<code class="c1">// refer to its current element.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="sc">'z'</code><code class="p">);</code><code class="w"/>

<code class="c1">// Assert that 'z' is alphabetic, using a method of `char` directly on a</code>
<code class="c1">// `Selector`, via deref coercion.</code>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">s</code><code class="p">.</code><code class="n">is_alphabetic</code><code class="p">());</code><code class="w"/>

<code class="c1">// Change the 'z' to a 'w', by assigning to the `Selector`'s referent.</code>
<code class="o">*</code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'w'</code><code class="p">;</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">s</code><code class="p">.</code><code class="n">elements</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="sc">'x'</code><code class="p">,</code><code class="w"> </code><code class="sc">'y'</code><code class="p">,</code><code class="w"> </code><code class="sc">'w'</code><code class="p">]);</code><code class="w"/></pre>

<p>The <code>Deref</code> and <code>DerefMut</code> traits are designed for implementing smart pointer types, like <code>Box</code>, <code>Rc</code>, and <code>Arc</code>, and types that serve as owning versions of something you would also frequently use by reference, the way <code>Vec&lt;T&gt;</code> and <code>String</code> serve as owning versions of <code>[T]</code> and <code>str</code>. You should not implement <code>Deref</code> and <code>DerefMut</code> for a type just to make the <code>Target</code> type’s methods appear on it automatically, the way a C++ base class’s methods are visible on a subclass. This will not always work as you expect, and can be confusing when it goes awry.</p>
<p>The deref coercions come with a caveat that can cause some confusion: Rust applies them to resolve type conflicts, but not to satisfy bounds on type variables. For example, the following code works fine:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Selector</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">elements</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"good"</code><code class="p">,</code><code class="w"> </code><code class="s">"bad"</code><code class="p">,</code><code class="w"> </code><code class="s">"ugly"</code><code class="p">],</code><code class="w"/>
<code class="w">                   </code><code class="n">current</code>: <code class="mi">2</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="k">fn</code> <code class="nf">show_it</code><code class="p">(</code><code class="n">thing</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">thing</code><code class="p">);</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="n">show_it</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">);</code><code class="w"/></pre>
<p>In the call <code>show_it(&amp;s)</code>, Rust sees an argument of type <code>&amp;Selector&lt;&amp;str&gt;</code> and a parameter of type <code>&amp;str</code>, finds the <code>Deref&lt;Target=str&gt;</code> implementation, and rewrites the call to <code>show_it(s.deref())</code>, just as needed.</p>
<p>However, if you change <code>show_it</code> into a generic function, Rust is suddenly no longer cooperative:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Display</code><code class="p">;</code><code class="w"/>
<code class="k">fn</code> <code class="nf">show_it_generic</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nc">Display</code><code class="o">&gt;</code><code class="p">(</code><code class="n">thing</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">thing</code><code class="p">);</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="n">show_it_generic</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">);</code><code class="w"/></pre>
<p>Rust complains:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">error</code><code class="p">[</code><code class="n">E0277</code><code class="p">]</code>: <code class="nc">the</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">bound</code><code class="w"> </code><code class="err">`</code><code class="n">Selector</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code>: <code class="nc">Display</code><code class="err">`</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">satisfied</code><code class="w"/>
<code class="w">    </code><code class="o">|</code><code class="w"/>
<code class="mi">542</code><code class="w"> </code><code class="o">|</code><code class="w">         </code><code class="n">show_it_generic</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="o">|</code><code class="w">         </code><code class="o">^^^^^^^^^^^^^^^</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="err">`</code><code class="n">Selector</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code>: <code class="nc">Display</code><code class="err">`</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">satisfied</code><code class="w"/>
<code class="w">    </code><code class="o">|</code><code class="w"/></pre>
<p>This can be bewildering: How could making a function generic introduce an error? True, <code>Selector&lt;&amp;str&gt;</code> does not implement <code>Display</code> itself, but it dereferences to <code>&amp;str</code>, which certainly does.</p>
<p>Since you’re passing an argument of type <code>&amp;Selector&lt;&amp;str&gt;</code>, and the function’s parameter type is <code>&amp;T</code>, the type variable <code>T</code> must be <code>Selector&lt;&amp;str&gt;</code>. Then, Rust checks whether the bound <code>T: Display</code> is satisfied: since it does not apply deref coercions to satisfy bounds on type variables, this check fails.</p>
<p>To work around this problem, you can spell out the coercion using the <code>as</code> operator:<a contenteditable="false" data-primary="" data-startref="C13-utility.html9" data-type="indexterm" id="idm45251608701640"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html8" data-type="indexterm" id="idm45251608700232"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html7" data-type="indexterm" id="idm45251608698856"/></p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">show_it_generic</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">&amp;</code><code class="kt">str</code><code class="p">);</code><code class="w"/></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Default"><div class="sect1" id="default">
<h1>Default</h1>

<p><a contenteditable="false" data-primary="Default trait" data-type="indexterm" id="C13-utility.html10"/><a contenteditable="false" data-primary="utility traits" data-secondary="Default" data-type="indexterm" id="C13-utility.html11"/>Some types have a reasonably obvious default value: the default vector or string is empty, the default number is zero, the default <code>Option</code> is <code>None</code>, and so on. Types like this can implement the <code>std::default::Default</code> trait:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Default</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">default</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>default</code> method simply returns a fresh value of type <code>Self</code>. <code>String</code>’s implementation of <code>Default</code> is straightforward:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="nb">Default</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="nb">String</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">default</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">String</code>::<code class="n">new</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>All of Rust’s collection types—<code>Vec</code>, <code>HashMap</code>, <code>BinaryHeap</code>, and so on—implement <code>Default</code>, with <code>default</code> methods that return an empty collection. This is helpful when you need to build a collection of values, but want to let your caller decide exactly what sort of collection to build. For example, the <code>Iterator</code> trait’s <code>partition</code> method splits the values the iterator produces into two collections, using a closure to decide where each value goes:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">HashSet</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">16</code><code class="p">,</code><code class="w"> </code><code class="mi">25</code><code class="p">,</code><code class="w"> </code><code class="mi">36</code><code class="p">,</code><code class="w"> </code><code class="mi">49</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">powers_of_two</code><code class="p">,</code><code class="w"> </code><code class="n">impure</code><code class="p">)</code>: <code class="p">(</code><code class="n">HashSet</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">HashSet</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="o">=</code><code class="w"> </code><code class="n">squares</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">partition</code><code class="p">(</code><code class="o">|&amp;</code><code class="n">n</code><code class="o">|</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="p">(</code><code class="n">n</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">powers_of_two</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">impure</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w"/></pre>
<p>The closure <code>|&amp;n| n &amp; (n-1) == 0</code> uses some bit-fiddling to recognize numbers that are powers of two, and <code>partition</code> uses that to produce two <code>HashSet</code>s. But of course, <code>partition</code> isn’t specific to <code>HashSet</code>s; you can use it to produce any sort of collection you like, as long as the collection type implements <code>Default</code>, to produce an empty collection to start with, and <code>Extend&lt;T&gt;</code>, to add a <code>T</code> to the collection. <code>String</code> implements <code>Default</code> and <code>Extend&lt;char&gt;</code>, so you can write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">upper</code><code class="p">,</code><code class="w"> </code><code class="n">lower</code><code class="p">)</code>: <code class="p">(</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="o">=</code><code class="w"> </code><code class="s">"Great Teacher Onizuka"</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">partition</code><code class="p">(</code><code class="o">|&amp;</code><code class="n">c</code><code class="o">|</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="n">is_uppercase</code><code class="p">());</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">upper</code><code class="p">,</code><code class="w"> </code><code class="s">"GTO"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">lower</code><code class="p">,</code><code class="w"> </code><code class="s">"reat eacher nizuka"</code><code class="p">);</code><code class="w"/></pre>
<p>Another common use of <code>Default</code> is to produce default values for structs that represent a large collection of parameters, most of which you won’t usually need to change. For example, the <code>glium</code> crate provides Rust bindings for the powerful and complex OpenGL graphics library. The <code>glium::DrawParameters</code> struct includes 22 fields, each controlling a different detail of how OpenGL should render some bit of graphics. The <code>glium</code> <code>draw</code> function expects a <code>DrawParameters</code> struct as an argument. Since <code>DrawParameters</code> implements <code>Default</code>, you can create one to pass to <code>draw</code>, mentioning only those fields you want to change:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">params</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">glium</code>::<code class="n">DrawParameters</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">line_width</code>: <code class="nb">Some</code><code class="p">(</code><code class="mf">0.02</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">point_size</code>: <code class="nb">Some</code><code class="p">(</code><code class="mf">0.02</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="p">..</code><code class="w"> </code><code class="nb">Default</code>::<code class="n">default</code><code class="p">()</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">target</code><code class="p">.</code><code class="n">draw</code><code class="p">(...,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">params</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/></pre>
<p>This calls <code>Default::default()</code> to create a <code>DrawParameters</code> value initialized with the default values for all its fields, and then uses the <code>..</code> syntax for structs to create a new one with the <code>line_width</code> and <code>point_size</code> fields changed, ready for you to pass it to <code>target.draw</code>.</p>
<p>If a type <code>T</code> implements <code>Default</code>, then the standard library implements <code>Default</code> automatically for <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>, <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, <code>Cow&lt;T&gt;</code>, <code>Mutex&lt;T&gt;</code>, and <code>RwLock&lt;T&gt;</code>. The default value for the type <code>Rc&lt;T&gt;</code>, for example, is an <code>Rc</code> pointing to the default value for type <code>T</code>.</p>
<p>If all the element types of a tuple type implement <code>Default</code>, then the tuple type does too, defaulting to a tuple holding each element’s default value.</p>
<p>Rust does not implicitly implement <code>Default</code> for struct types, but if all of a struct’s fields implement <code>Default</code>, you can implement <code>Default</code> for the struct automatically using <code>#[derive(Default)]</code>.</p>
<p>The default value of any <code>Option&lt;T&gt;</code> is <code>None</code>.<a contenteditable="false" data-primary="" data-startref="C13-utility.html11" data-type="indexterm" id="idm45251608232344"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html10" data-type="indexterm" id="idm45251608230936"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="AsRef and AsMut"><div class="sect1" id="asref-and-asmut">
<h1>AsRef and AsMut</h1>

<p><a contenteditable="false" data-primary="AsMut trait" data-type="indexterm" id="idm45251608227720"/><a contenteditable="false" data-primary="AsRef trait" data-type="indexterm" id="idm45251608226616"/><a contenteditable="false" data-primary="utility traits" data-secondary="AsRef and AsMut" data-type="indexterm" id="idm45251608225512"/>When a type implements <code>AsRef&lt;T&gt;</code>, that means you can borrow a <code>&amp;T</code> from it efficiently. <code>AsMut</code> is the analogue for mutable references. Their definitions are as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">AsRef</code><code class="o">&lt;</code><code class="n">T</code>: <code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">as_ref</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">T</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">trait</code><code class="w"> </code><code class="nb">AsMut</code><code class="o">&lt;</code><code class="n">T</code>: <code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">as_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">T</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>So, for example, <code>Vec&lt;T&gt;</code> implements <code>AsRef&lt;[T]&gt;</code>, and <code>String</code> implements <code>AsRef&lt;str&gt;</code>. You can also borrow a <code>String</code>’s contents as an array of bytes, so <code>String</code> implements <code>AsRef&lt;[u8]&gt;</code> as well.</p>
<p><code>AsRef</code> is typically used to make functions more flexible in the argument types they accept. For example, the <code>std::fs::File::open</code> function is declared like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">open</code><code class="o">&lt;</code><code class="n">P</code>: <code class="nb">AsRef</code><code class="o">&lt;</code><code class="n">Path</code><code class="o">&gt;&gt;</code><code class="p">(</code><code class="n">path</code>: <code class="nc">P</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">File</code><code class="o">&gt;</code><code class="w"/></pre>
<p>What <code>open</code> really wants is a <code>&amp;Path</code>, the type representing a filesystem path. But with this signature, <code>open</code> accepts anything it can borrow a <code>&amp;Path</code> from—that is, anything that implements <code>AsRef&lt;Path&gt;</code>. Such types include <code>String</code> and <code>str</code>, the operating system interface string types <code>OsString</code> and <code>OsStr</code>, and of course <code>PathBuf</code> and <code>Path</code>; see the library documentation for the full list. This is what allows you to pass string literals to <code>open</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">dot_emacs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/home/jimb/.emacs"</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/></pre>
<p>All of the standard library’s filesystem access functions accept path arguments this way. For callers, the effect resembles that of an overloaded function in C++, although Rust takes a different approach toward establishing which argument types are acceptable.</p>
<p>But this can’t be the whole story. A string literal is a <code>&amp;str</code>, but the type that implements <code>AsRef&lt;Path&gt;</code> is <code>str</code>, without an <code>&amp;</code>. And as we explained in <a data-type="xref" href="#deref-and-derefmut">“Deref and DerefMut”</a>, Rust doesn’t try deref coercions to satisfy type variable bounds, so they won’t help here either.</p>
<p>Fortunately, the standard library includes the blanket implementation:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">U</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">AsRef</code><code class="o">&lt;</code><code class="n">U</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">T</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">T</code>: <code class="nb">AsRef</code><code class="o">&lt;</code><code class="n">U</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="n">T</code>: <code class="o">?</code><code class="nb">Sized</code><code class="p">,</code><code class="w"> </code><code class="n">U</code>: <code class="o">?</code><code class="nb">Sized</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">as_ref</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">U</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="o">*</code><code class="bp">self</code><code class="p">).</code><code class="n">as_ref</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In other words, for any types <code>T</code> and <code>U</code>, if <code>T: AsRef&lt;U&gt;</code>, then <code>&amp;T: AsRef&lt;U&gt;</code> as well: simply follow the reference and proceed as before. In particular, since <code>str: AsRef&lt;Path&gt;</code>, then <code>&amp;str: AsRef&lt;Path&gt;</code> as well. In a sense, this is a way to get a limited form of deref coercion in checking <code>AsRef</code> bounds on type variables.</p>
<p>You might assume that, if a type implements <code>AsRef&lt;T&gt;</code>, it should also implement <code>AsMut&lt;T&gt;</code>. However, there are cases where this isn’t appropriate. For example, we’ve mentioned that <code>String</code> implements <code>AsRef&lt;[u8]&gt;</code>; this makes sense, as each <code>String</code> certainly has a buffer of bytes that can be useful to access as binary data. However, <code>String</code> further guarantees that those bytes are a well-formed UTF-8 encoding of Unicode text; if <code>String</code> implemented <code>AsMut&lt;[u8]&gt;</code>, that would let callers change the <code>String</code>’s bytes to anything they wanted, and you could no longer trust a <code>String</code> to be well-formed UTF-8. It only makes sense for a type to implement <code>AsMut&lt;T&gt;</code> if modifying the given <code>T</code> cannot violate the type’s invariants.</p>
<p>Although <code>AsRef</code> and <code>AsMut</code> are pretty simple, providing standard, generic traits for reference conversion avoids the proliferation of more specific conversion traits. You should avoid defining your own <code>AsFoo</code> traits when you could just implement <code>AsRef&lt;Foo&gt;</code>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Borrow and BorrowMut"><div class="sect1" id="borrow-and-borrowmut">
<h1>Borrow and BorrowMut</h1>

<p><a contenteditable="false" data-primary="Borrow trait" data-type="indexterm" id="C13-utility.html12"/><a contenteditable="false" data-primary="utility traits" data-secondary="Borrow and BorrowMut" data-type="indexterm" id="C13-utility.html13"/>The <code>std::borrow::Borrow</code> trait is similar to <code>AsRef</code>: if a type implements <code>Borrow&lt;T&gt;</code>, then its <code>borrow</code> method efficiently borrows a <code>&amp;T</code> from it. But <code>Borrow</code> imposes more restrictions: a type should implement <code>Borrow&lt;T&gt;</code> only when a <code>&amp;T</code> hashes and compares the same way as the value it’s borrowed from. (Rust doesn’t enforce this; it’s just the documented intent of the trait.) This makes <code>Borrow</code> valuable in dealing with keys in hash tables and trees, or when dealing with values that will be hashed or compared for some other reason.</p>
<p>This distinction matters when borrowing from <code>String</code>s, for example: <code>String</code> implements <code>AsRef&lt;str&gt;</code>, <code>AsRef&lt;[u8]&gt;</code>, and <code>AsRef&lt;Path&gt;</code>, but those three target types will generally have different hash values. Only the <code>&amp;str</code> slice is guaranteed to hash like the equivalent <code>String</code>, so <code>String</code> implements only <code>Borrow&lt;str&gt;</code>.</p>
<p><code>Borrow</code>’s definition is identical to that of <code>AsRef</code>; only the names have been changed:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">Borrow</code><code class="o">&lt;</code><code class="n">Borrowed</code>: <code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">borrow</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">Borrowed</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><code>Borrow</code> is designed to address a specific situation with generic hash tables and other associative collection types. For example, suppose you have a <code>std::collections​::HashMap&lt;String, i32&gt;</code>, mapping strings to numbers. This table’s keys are <code>String</code>s; each entry owns one. What should the signature of the method that looks up an entry in this table be? Here’s a first attempt:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">K</code>: <code class="nb">Eq</code> <code class="o">+</code><code class="w"> </code><code class="n">Hash</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">get</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">key</code>: <code class="nc">K</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This makes sense: to look up an entry, you must provide a key of the appropriate type for the table. But in this case, <code>K</code> is <code>String</code>; this signature would force you to pass a <code>String</code> by value to every call to <code>get</code>, which is clearly wasteful. You really just need a reference to the key:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">K</code>: <code class="nb">Eq</code> <code class="o">+</code><code class="w"> </code><code class="n">Hash</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">get</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">key</code>: <code class="kp">&amp;</code><code class="nc">K</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This is slightly better, but now you have to pass the key as a <code>&amp;String</code>, so if you wanted to look up a constant string, you’d have to write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">hashtable</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="o">&amp;</code><code class="s">"twenty-two"</code><code class="p">.</code><code class="n">to_string</code><code class="p">())</code><code class="w"/></pre>
<p>This is ridiculous: it allocates a <code>String</code> buffer on the heap and copies the text into it, just so it can borrow it as a <code>&amp;String</code>, pass it to <code>get</code>, and then drop it.</p>
<p>It should be good enough to pass anything that can be hashed and compared with our key type; a <code>&amp;str</code> should be perfectly adequate, for example. So here’s the final iteration, which is what you’ll find in the standard library:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">K</code>: <code class="nb">Eq</code> <code class="o">+</code><code class="w"> </code><code class="n">Hash</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">get</code><code class="o">&lt;</code><code class="n">Q</code>: <code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">key</code>: <code class="kp">&amp;</code><code class="nc">Q</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">V</code><code class="o">&gt;</code><code class="w"/>
<code class="w">        </code><code class="k">where</code><code class="w"> </code><code class="n">K</code>: <code class="nc">Borrow</code><code class="o">&lt;</code><code class="n">Q</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">              </code><code class="n">Q</code>: <code class="nb">Eq</code> <code class="o">+</code><code class="w"> </code><code class="n">Hash</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In other words, if you can borrow an entry’s key as a <code>&amp;Q</code>, and the resulting reference hashes and compares just the way the key itself would, then clearly <code>&amp;Q</code> ought to be an acceptable key type. Since <code>String</code> implements <code>Borrow&lt;str&gt;</code> and <code>Borrow&lt;String&gt;</code>, this final version of <code>get</code> allows you to pass either <code>&amp;String</code> or <code>&amp;str</code> as a key, as needed.</p>
<p><code>Vec&lt;T&gt;</code> and <code>[T: N]</code> implement <code>Borrow&lt;[T]&gt;</code>. Every string-like type allows borrowing its corresponding slice type: <code>String</code> implements <code>Borrow&lt;str&gt;</code>, <code>PathBuf</code> implements <code>Borrow&lt;Path&gt;</code>, and so on. And all the standard library’s associative collection types use <code>Borrow</code> to decide which types can be passed to their lookup functions.</p>
<p>The standard library includes a blanket implementation so that every type <code>T</code> can be borrowed from itself: <code>T: Borrow&lt;T&gt;</code>. This ensures that <code>&amp;K</code> is always an acceptable type for looking up entries in a <code>HashMap&lt;K, V&gt;</code>.</p>
<p>As a convenience, every <code>&amp;mut T</code> type also implements <code>Borrow&lt;T&gt;</code>, returning a shared reference <code>&amp;T</code> as usual. This allows you to pass mutable references to collection lookup functions without having to reborrow a shared reference, emulating Rust’s usual implicit coercion from mutable references to shared references.</p>
<p><a contenteditable="false" data-primary="BorrowMut trait" data-type="indexterm" id="idm45251607566552"/>The <code>BorrowMut</code> trait is the analogue of <code>Borrow</code> for mutable references:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="n">BorrowMut</code><code class="o">&lt;</code><code class="n">Borrowed</code>: <code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code>: <code class="nc">Borrow</code><code class="o">&lt;</code><code class="n">Borrowed</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">borrow_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Borrowed</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The same expectations described for <code>Borrow</code> apply to <code>BorrowMut</code> as well.<a contenteditable="false" data-primary="" data-startref="C13-utility.html13" data-type="indexterm" id="idm45251607487608"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html12" data-type="indexterm" id="idm45251607486264"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="From and Into"><div class="sect1" id="from-and-into">
<h1>From and Into</h1>

<p><a contenteditable="false" data-primary="From trait" data-type="indexterm" id="C13-utility.html14"/><a contenteditable="false" data-primary="Into trait" data-type="indexterm" id="C13-utility.html15"/><a contenteditable="false" data-primary="utility traits" data-secondary="From and Into" data-type="indexterm" id="C13-utility.html16"/>The <code>std::convert::From</code> and <code>std::convert::Into</code> traits represent conversions that consume a value of one type, and return a value of another. Whereas the <code>AsRef</code> and <code>AsMut</code> traits borrow a reference of one type from another, <code>From</code> and <code>Into</code> take ownership of their argument, transform it, and then return ownership of the result back to the caller.</p>
<p>Their definitions are nicely symmetrical:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">Into</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code>: <code class="nb">Sized</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">into</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">T</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">trait</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code>: <code class="nb">Sized</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The standard library automatically implements the trivial conversion from each type to itself: every type <code>T</code> implements <code>From&lt;T&gt;</code> and <code>Into&lt;T&gt;</code>.</p>
<p>Although the traits simply provide two ways to do the same thing, they lend themselves to different uses.</p>
<p>You generally use <code>Into</code> to make your functions more flexible in the arguments they accept. For example, if you write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">net</code>::<code class="n">Ipv4Addr</code><code class="p">;</code><code class="w"/>
<code class="k">fn</code> <code class="nf">ping</code><code class="o">&lt;</code><code class="n">A</code><code class="o">&gt;</code><code class="p">(</code><code class="n">address</code>: <code class="nc">A</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">std</code>::<code class="n">io</code>::<code class="nb">Result</code><code class="o">&lt;</code><code class="kt">bool</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">A</code>: <code class="nb">Into</code><code class="o">&lt;</code><code class="n">Ipv4Addr</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">ipv4_address</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">address</code><code class="p">.</code><code class="n">into</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>then <code>ping</code> can accept not just an <code>Ipv4Addr</code> as an argument, but also a <code>u32</code> or a <code>[u8; 4]</code> array, since those types both conveniently happen to implement <code>Into&lt;Ipv4Addr&gt;</code>. (It’s sometimes useful to treat an IPv4 address as a single 32-bit value, or an array of four bytes.) Because the only thing <code>ping</code> knows about <code>address</code> is that it implements <code>Into&lt;Ipv4Addr&gt;</code>, there’s no need to specify which type you want when you call <code>into</code>; there’s only one that could possibly work, so type inference fills it in for you.</p>
<p>As with <code>AsRef</code> in the previous section, the effect is much like that of overloading a function in C++. With the definition of <code>ping</code> from before, we can make any of these calls:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">ping</code><code class="p">(</code><code class="n">Ipv4Addr</code>::<code class="n">new</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code><code class="w"> </code><code class="mi">21</code><code class="p">,</code><code class="w"> </code><code class="mi">68</code><code class="p">,</code><code class="w"> </code><code class="mi">141</code><code class="p">)));</code><code class="w"> </code><code class="c1">// pass an Ipv4Addr</code>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">ping</code><code class="p">([</code><code class="mi">66</code><code class="p">,</code><code class="w"> </code><code class="mi">146</code><code class="p">,</code><code class="w"> </code><code class="mi">219</code><code class="p">,</code><code class="w"> </code><code class="mi">98</code><code class="p">]));</code><code class="w">             </code><code class="c1">// pass a [u8; 4]</code>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">ping</code><code class="p">(</code><code class="mh">0xd076eb94_</code><code class="k">u32</code><code class="p">));</code><code class="w">                 </code><code class="c1">// pass a u32</code></pre>
<p>The <code>From</code> trait, however, plays a different role. The <code>from</code> method serves as a generic constructor for producing an instance of a type from some other single value. For example, rather than <code>Ipv4Addr</code> having two methods named <code>from_array</code> and <code>from_u32</code>, it simply implements <code>From&lt;[u8;4]&gt;</code> and <code>From&lt;u32&gt;</code>, allowing us to write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">addr1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Ipv4Addr</code>::<code class="n">from</code><code class="p">([</code><code class="mi">66</code><code class="p">,</code><code class="w"> </code><code class="mi">146</code><code class="p">,</code><code class="w"> </code><code class="mi">219</code><code class="p">,</code><code class="w"> </code><code class="mi">98</code><code class="p">]);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">addr2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Ipv4Addr</code>::<code class="n">from</code><code class="p">(</code><code class="mh">0xd076eb94_</code><code class="k">u32</code><code class="p">);</code><code class="w"/></pre>
<p>We can let type inference sort out which implementation applies.</p>
<p>Given an appropriate <code>From</code> implementation, the standard library automatically implements the corresponding <code>Into</code> trait. When you define your own type, if it has single-argument constructors, you should write them as implementations of <code>From&lt;T&gt;</code> for the appropriate types; you’ll get the corresponding <code>Into</code> implementations for free.</p>
<p>Because the <code>from</code> and <code>into</code> conversion methods take ownership of their arguments, a conversion can reuse the original value’s resources to construct the converted value. For example, suppose you write:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Beautiful Soup"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">bytes</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="n">into</code><code class="p">();</code><code class="w"/></pre>
<p>The implementation of <code>Into&lt;Vec&lt;u8&gt;&gt;</code> for <code>String</code> simply takes the <code>String</code>’s heap buffer and repurposes it, unchanged, as the returned vector’s element buffer. The conversion has no need to allocate or copy the text. This is another case where moves enable efficient implementations.</p>

<p>These conversions also provide a nice way to relax a value of a constrained type into something more flexible, without weakening the constrained type’s guarantees. For example, a <code>String</code> guarantees that its contents are always valid UTF-8; its mutating methods are carefully restricted to ensure that nothing you can do will ever introduce bad UTF-8. But this example efficiently “demotes” a <code>String</code> to a block of plain bytes that you can do anything you like with: perhaps you’re going to compress it, or combine it with other binary data that isn’t UTF-8. Because <code>into</code> takes its argument by value, <code>text</code> is no longer initialized after the conversion, meaning that we can freely access the former <code>String</code>’s buffer without being able to corrupt any extant <code>String</code>.</p>

<p>However, cheap conversions are not part of <code>Into</code> and <code>From</code>’s contract. Whereas <code>AsRef</code> and <code>AsMut</code> conversions are expected to be cheap, <code>From</code> and <code>Into</code> conversions may allocate, copy, or otherwise process the value’s contents. For example, <code>String</code> implements <code>From&lt;&amp;str&gt;</code>, which copies the string slice into a new heap-allocated buffer for the <code>String</code>. And <code>std::collections::BinaryHeap&lt;T&gt;</code> implements <code>From&lt;Vec&lt;T&gt;&gt;</code>, which compares and reorders the elements according to its algorithm’s requirements.</p>
<p>Note that <code>From</code> and <code>Into</code> are restricted to conversions that never fail. The methods’ type signatures don’t provide any way to indicate that a given conversion didn’t work out. To provide fallible conversions into or out of your types, it’s best to have a function or method that returns a <code>Result</code> type.</p>
<p>Before <code>From</code> and <code>Into</code> were added to the standard library, Rust code was full of ad hoc conversion traits and construction methods, each specific to a single type. <code>From</code> and <code>Into</code> codify conventions that you can follow to make your types easier to use, since your users are already familiar with them.<a contenteditable="false" data-primary="" data-startref="C13-utility.html16" data-type="indexterm" id="idm45251607119512"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html15" data-type="indexterm" id="idm45251607118136"/><a contenteditable="false" data-primary="" data-startref="C13-utility.html14" data-type="indexterm" id="idm45251607116760"/></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="ToOwned"><div class="sect1" id="toowned">
<h1>ToOwned</h1>
<p><a contenteditable="false" data-primary="ToOwned trait" data-type="indexterm" id="idm45251607114184"/><a contenteditable="false" data-primary="utility traits" data-secondary="ToOwned" data-type="indexterm" id="idm45251607112680"/>Given a reference, the usual way to produce an owned copy of its referent is to call <code>clone</code>, assuming the type implements <code>std::clone::Clone</code>. But what if you want to clone a <code>&amp;str</code> or a <code>&amp;[i32]</code>? What you probably want is a <code>String</code> or a <code>Vec&lt;i32&gt;</code>, but <code>Clone</code>’s definition doesn’t permit that: by definition, cloning a <code>&amp;T</code> must always return a value of type <code>T</code>, and <code>str</code> and <code>[u8]</code> are unsized; they aren’t even types that a function could return.</p>
<p>The <code>std::borrow::ToOwned</code> trait provides a slightly looser way to convert a reference to an owned value:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">trait</code><code class="w"> </code><code class="nb">ToOwned</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">type</code> <code class="nc">Owned</code>: <code class="nc">Borrow</code><code class="o">&lt;</code><code class="n">Self</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">to_owned</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code>::<code class="n">Owned</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Unlike <code>clone</code>, which must return exactly <code>Self</code>, <code>to_owned</code> can return anything you could borrow a <code>&amp;Self</code> from: the <code>Owned</code> type must implement <code>Borrow&lt;Self&gt;</code>. You can borrow a <code>&amp;[T]</code> from a <code>Vec&lt;T&gt;</code>, so <code>[T]</code> can implement <code>ToOwned&lt;Owned=Vec&lt;T&gt;&gt;</code>, as long as <code>T</code> implements <code>Clone</code>, so that we can copy the slice’s elements into the vector. Similarly, <code>str</code> implements <code>ToOwned&lt;Owned=String&gt;</code>, <code>Path</code> implements <code>ToOwned&lt;Owned=PathBuf&gt;</code>, and so on.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Borrow and ToOwned at Work: The Humble Cow"><div class="sect1" id="borrow-and-toowned-at-work-the-humble-cow">
<h1>Borrow and ToOwned at Work: The Humble Cow</h1>
<p><a contenteditable="false" data-primary="Cow (clone on write) type" data-type="indexterm" id="idm45251607040424"/><a contenteditable="false" data-primary="ownership" data-secondary="Cow" data-type="indexterm" id="idm45251607039352"/><a contenteditable="false" data-primary="utility traits" data-secondary="Cow" data-type="indexterm" id="idm45251607037976"/>Making good use of Rust involves thinking through questions of ownership, like whether a function should receive a parameter by reference or by value. Usually you can settle on one approach or the other, and the parameter’s type reflects your decision. But in some cases you cannot decide whether to borrow or own until the program is running; the <code>std::borrow::Cow</code> type (for “clone on write”) provides one way to do this.</p>
<p>Its definition is shown here:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">enum</code> <code class="nc">Cow</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">B</code>: <code class="o">?</code><code class="nb">Sized</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="na">'a</code><code class="o">&gt;</code><code class="w"/>
<code class="w">    </code><code class="k">where</code><code class="w"> </code><code class="n">B</code>: <code class="nb">ToOwned</code>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Borrowed</code><code class="p">(</code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="n">B</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">Owned</code><code class="p">(</code><code class="o">&lt;</code><code class="n">B</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="nb">ToOwned</code><code class="o">&gt;</code>::<code class="n">Owned</code><code class="p">),</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>A <code>Cow&lt;B&gt;</code> either borrows a shared reference to a <code>B</code>, or owns a value from which we could borrow such a reference. Since <code>Cow</code> implements <code>Deref</code>, you can call methods on it as if it were a shared reference to a <code>B</code>: if it’s <code>Owned</code>, it borrows a shared reference to the owned value; and if it’s <code>Borrowed</code>, it just hands out the reference it’s holding.</p>
<p>You can also get a mutable reference to a <code>Cow</code>’s value by calling its <code>to_mut</code> method, which returns a <code>&amp;mut B</code>. If the <code>Cow</code> happens to be <code>Cow::Borrowed</code>, <code>to_mut</code> simply calls the reference’s <code>to_owned</code> method to get its own copy of the referent, changes the <code>Cow</code> into a <code>Cow::Owned</code>, and borrows a mutable reference to the newly owned value. This is the “clone on write” behavior the type’s name refers to.</p>
<p>Similarly, <code>Cow</code> has an <code>into_owned</code> method that promotes the reference to an owned value if necessary, and then returns it, moving ownership to the caller and consuming the <code>Cow</code> in the process.</p>
<p>One common use for <code>Cow</code> is to return either a statically allocated string constant or a computed string. For example, suppose you need to convert an error enum to a message. Most of the variants can be handled with fixed strings, but some of them have additional data that should be included in the message. You can return a <code>Cow&lt;'static, str&gt;</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">path</code>::<code class="n">PathBuf</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">borrow</code>::<code class="n">Cow</code><code class="p">;</code><code class="w"/>
<code class="k">fn</code> <code class="nf">describe</code><code class="p">(</code><code class="n">error</code>: <code class="kp">&amp;</code><code class="nc">Error</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Cow</code><code class="o">&lt;</code><code class="nb">'static</code><code class="p">,</code><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="o">*</code><code class="n">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Error</code>::<code class="n">OutOfMemory</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"out of memory"</code><code class="p">.</code><code class="n">into</code><code class="p">(),</code><code class="w"/>
<code class="w">        </code><code class="n">Error</code>::<code class="n">StackOverflow</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"stack overflow"</code><code class="p">.</code><code class="n">into</code><code class="p">(),</code><code class="w"/>
<code class="w">        </code><code class="n">Error</code>::<code class="n">MachineOnFire</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"machine on fire"</code><code class="p">.</code><code class="n">into</code><code class="p">(),</code><code class="w"/>
<code class="w">        </code><code class="n">Error</code>::<code class="n">Unfathomable</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"machine bewildered"</code><code class="p">.</code><code class="n">into</code><code class="p">(),</code><code class="w"/>
<code class="w">        </code><code class="n">Error</code>::<code class="n">FileNotFound</code><code class="p">(</code><code class="k">ref</code><code class="w"> </code><code class="n">path</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"file not found: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="n">display</code><code class="p">()).</code><code class="n">into</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This code uses <code>Cow</code>’s implementation of <code>Into</code> to construct the values. Most arms of this <code>match</code> statement return a <code>Cow::Borrowed</code> referring to a statically allocated string. But when we get a <code>FileNotFound</code> variant, we use <code>format!</code> to construct a message incorporating the given filename. This arm of the <code>match</code> statement produces a <code>Cow::Owned</code> value.</p>
<p>Callers of <code>describe</code> that don’t need to change the value can simply treat the <code>Cow</code> as a <code>&amp;str</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Disaster has struck: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">describe</code><code class="p">(</code><code class="o">&amp;</code><code class="n">error</code><code class="p">));</code><code class="w"/></pre>
<p>Callers who do need an owned value can readily produce one:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">log</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="p">...</code><code class="w"/>
<code class="n">log</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">describe</code><code class="p">(</code><code class="o">&amp;</code><code class="n">error</code><code class="p">).</code><code class="n">into_owned</code><code class="p">());</code><code class="w"/></pre>
<p>Using <code>Cow</code> helps <code>describe</code> and its callers put off allocation until the moment it becomes necessary.<a contenteditable="false" data-primary="" data-startref="C13-utility.html0" data-type="indexterm" id="idm45251606719704"/></p>
</div></section>
</div></section></div></body>
</html>