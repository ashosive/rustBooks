<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. A Tour of Rust"><div class="chapter" id="a-tour-of-rust">
<h1><span class="label">Chapter 2. </span>A Tour of Rust</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>Toute l’expérience d’un individu est construit sur le plan de son langage. <br/>(An individual’s experience is built entirely in terms of his language.)</p>

<p data-type="attribution">Henri Delacroix</p>
</blockquote>

<p><a contenteditable="false" data-primary="Rust (generally)" data-secondary="basics" data-type="indexterm" id="C02-tour.html0"/>In this chapter we’ll look at several short programs to see how Rust’s syntax, types, and semantics fit together to support safe, concurrent, and efficient code. We’ll walk through the process of downloading and installing Rust, show some simple mathematical code, try out a web server based on a third-party library, and use multiple threads to speed up the process of plotting the Mandelbrot set.</p>

<section data-type="sect1" data-pdf-bookmark="Downloading and Installing Rust"><div class="sect1" id="downloading-and-installing-rust">
<h1>Downloading and Installing Rust</h1>

<p><a contenteditable="false" data-primary="installation, Rust" data-type="indexterm" id="C02-tour.html1"/><a contenteditable="false" data-primary="Rust (generally)" data-secondary="installation" data-type="indexterm" id="C02-tour.html2"/>The <a contenteditable="false" data-primary="rustup" data-type="indexterm" id="idm45251663667176"/>best way to install Rust is to use <code>rustup</code>, the Rust installer. Go to <a class="uri" href="https://rustup.rs"><em>https://rustup.rs</em></a> and follow the instructions there.</p>

<p><a contenteditable="false" data-primary="Linux" data-secondary="Rust package for" data-type="indexterm" id="idm45251663664024"/><a contenteditable="false" data-primary="macOS" data-secondary="Rust package for" data-type="indexterm" id="idm45251663662648"/><a contenteditable="false" data-primary="Windows" data-secondary="Rust package for" data-type="indexterm" id="idm45251663661272"/>You can, alternatively, go to <a class="uri" href="https://www.rust-lang.org"><em>https://www.rust-lang.org</em></a>, click Downloads, and get pre-built packages for Linux, macOS, and Windows. Rust is also included in some operating system distributions. We prefer <code>rustup</code> because it’s a tool for managing Rust installations, like RVM for Ruby or NVM for Node. For example, when a new version of Rust is released, you’ll be able to upgrade with zero clicks by typing <code>rustup update</code>.</p>

<p>In any case, once you’ve completed the installation, you should have three new commands available at your command line:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo --version
<code class="go">cargo 0.18.0 (fe7b0cdcf 2017-04-24)</code>
<code class="gp">$</code> rustc --version
<code class="go">rustc 1.17.0 (56124baa9 2017-04-24)</code>
<code class="gp">$</code> rustdoc --version
<code class="go">rustdoc 1.17.0 (56124baa9 2017-04-24)</code>
<code class="gp">$</code></pre>

<p><a contenteditable="false" data-primary="$ (command prompt)" data-type="indexterm" id="idm45251663653432"/><a contenteditable="false" data-primary="command prompt ($)" data-type="indexterm" id="idm45251663650872"/>Here, the <code>$</code> is the command prompt; on Windows, this would be <code>C:\&gt;</code> or something similar. In this transcript we run the three commands we installed, asking each to report which version it is. Taking each command in turn:</p>

<ul>
    <li>
    <p><a contenteditable="false" data-primary="Cargo" data-type="indexterm" id="idm45251663647736"/><code>cargo</code> is Rust’s compilation manager, package manager, and general-purpose tool. You can use Cargo to start a new project, build and run your program, and manage any external libraries your code depends on.</p>
    </li>
    <li>
    <p><a contenteditable="false" data-primary="compiler" data-type="indexterm" id="idm45251663645256"/><a contenteditable="false" data-primary="rustc" data-type="indexterm" id="idm45251663635624"/><code>rustc</code> is the Rust compiler. Usually we let Cargo invoke the compiler for us, but sometimes it’s useful to run it directly.</p>
    </li>
    <li>
    <p><a contenteditable="false" data-primary="documentation" data-type="indexterm" id="idm45251663633240"/><a contenteditable="false" data-primary="rustdoc" data-type="indexterm" id="idm45251663632136"/><code>rustdoc</code> is the Rust documentation tool. If you write documentation in comments of the appropriate form in your program’s source code, <code>rustdoc</code> can build nicely formatted HTML from them. Like <code>rustc</code>, we usually let Cargo run <code>rustdoc</code> for us.</p>
    </li>
</ul>

<p><a contenteditable="false" data-primary="Cargo" data-secondary="creating new Rust package with" data-type="indexterm" id="idm45251663628600"/>As a convenience, Cargo can create a new Rust package for us, with some standard metadata arranged appropriately:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo new --bin hello
<code class="go">     Created binary (application) `hello` project</code></pre>

<p>This command creates a new package directory named <em>hello</em>, and the <code>--bin</code> flag directs Cargo to prepare this as an executable, not a library. Looking inside the package’s top-level directory:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> <code class="nb">cd </code>hello
<code class="gp">$</code> ls -la
<code class="go">total 24</code>
<code class="go">drwxrwxr-x.  4 jimb jimb 4096 Sep 22 21:09 .</code>
<code class="go">drwx------. 62 jimb jimb 4096 Sep 22 21:09 ..</code>
<code class="go">drwxrwxr-x.  6 jimb jimb 4096 Sep 22 21:09 .git</code>
<code class="go">-rw-rw-r--.  1 jimb jimb    7 Sep 22 21:09 .gitignore</code>
<code class="go">-rw-rw-r--.  1 jimb jimb   88 Sep 22 21:09 Cargo.toml</code>
<code class="go">drwxrwxr-x.  2 jimb jimb 4096 Sep 22 21:09 src</code>
<code class="gp">$</code></pre>

<p>We can see that Cargo has created a file <em>Cargo.toml</em> to hold metadata for the package. At the moment this file doesn’t contain much:</p>

<pre data-testing="match-whole-file Cargo.toml" data-type="programlisting">
[package]
name = "hello"
version = "0.1.0"
authors = ["You &lt;you@example.com&gt;"]

[dependencies]</pre>

<p>If our program ever acquires dependencies on other libraries, we can record them in this file, and Cargo will take care of downloading, building, and updating those libraries for us. We’ll cover the <em>Cargo.toml</em> file in detail in <a data-type="xref" href="ch08.xhtml#crates-and-modules">Chapter 8</a>.</p>

<p>Cargo has set up our package for use with the <code>git</code> version control system, creating a <em>.git</em> metadata subdirectory, and a <em>.gitignore</em> file. You can tell Cargo to skip this step by specifying <code>--vcs none</code> on the command line.</p>

<p>The <em>src</em> subdirectory contains the actual Rust code:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> <code class="nb">cd </code>src
<code class="gp">$</code> ls -l
<code class="go">total 4</code>
<code class="go">-rw-rw-r--. 1 jimb jimb 45 Sep 22 21:09 main.rs</code></pre>

<p>It seems that Cargo has begun writing the program on our behalf. The <em>main.rs</em> file contains the text:</p>

<pre data-code-language="rust" data-testing="match-whole-file src/main.rs" data-type="programlisting">
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Hello, world!"</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In Rust, you don’t even need to write your own “Hello, World!” program. And this is the extent of the boilerplate for a new Rust program: two files, totaling nine lines.</p>

<p>We can invoke the <code>cargo run</code> command from any directory in the package to build and run our program:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo run
<code class="go">   Compiling hello v0.1.0 (file:///home/jimb/rust/hello)</code>
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs</code>
<code class="go">     Running `/home/jimb/rust/hello/target/debug/hello`</code>
<code class="go">Hello, world!</code>
<code class="gp">$</code></pre>

<p>Here, Cargo has invoked the Rust compiler, <code>rustc</code>, and then run the executable it produced. Cargo places the executable in the <em>target</em> subdirectory at the top of the package:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> ls -l ../target/debug
<code class="go">total 580</code>
<code class="go">drwxrwxr-x. 2 jimb jimb   4096 Sep 22 21:37 build</code>
<code class="go">drwxrwxr-x. 2 jimb jimb   4096 Sep 22 21:37 deps</code>
<code class="go">drwxrwxr-x. 2 jimb jimb   4096 Sep 22 21:37 examples</code>
<code class="go">-rwxrwxr-x. 1 jimb jimb 576632 Sep 22 21:37 hello</code>
<code class="go">-rw-rw-r--. 1 jimb jimb    198 Sep 22 21:37 hello.d</code>
<code class="go">drwxrwxr-x. 2 jimb jimb     68 Sep 22 21:37 incremental</code>
<code class="go">drwxrwxr-x. 2 jimb jimb   4096 Sep 22 21:37 native</code>
<code class="gp">$</code> ../target/debug/hello
<code class="go">Hello, world!</code>
<code class="gp">$</code></pre>

<p class="pagebreak-before">When we’re through, Cargo can clean up the generated files for us:<a contenteditable="false" data-primary="" data-startref="C02-tour.html2" data-type="indexterm" id="idm45251663472392"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html1" data-type="indexterm" id="idm45251663471112"/></p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo clean
<code class="gp">$</code> ../target/debug/hello
<code class="go">bash: ../target/debug/hello: No such file or directory</code>
<code class="gp">$</code></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="A Simple Function"><div class="sect1" id="a-simple-function">
<h1>A Simple Function</h1>

<p><a contenteditable="false" data-primary="functions" data-secondary="syntax for" data-type="indexterm" id="idm45251663411736"/><a contenteditable="false" data-primary="Rust (generally)" data-secondary="simple function in" data-type="indexterm" id="idm45251663410360"/>Rust’s syntax is deliberately unoriginal. If you are familiar with C, C++, Java, or JavaScript, you can probably find your way through the general structure of a Rust program. Here is a function that computes the greatest common divisor of two integers, using <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid’s algorithm</a>:</p>

<pre data-code-language="rust" data-testing="copy-code" data-type="programlisting">
<code class="k">fn</code> <code class="nf">gcd</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="n">n</code>: <code class="kt">u64</code><code class="p">,</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">m</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">n</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">m</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">n</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">t</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="n">n</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">n</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="fn keyword" data-type="indexterm" id="idm45251663405640"/>The <code>fn</code> keyword (pronounced “fun”) introduces a function. Here, we’re defining a function named <code>gcd</code>, which takes two parameters <code>n</code> and <code>m</code>, each of which is of type <code>u64</code>, an unsigned 64-bit integer. The <code>-&gt;</code> token precedes the return type: our function returns a <code>u64</code> value. Four-space indentation is standard Rust style.</p>

<p>Rust’s machine integer type names reflect their size and signedness: <code>i32</code> is a signed 32-bit integer; <code>u8</code> is an unsigned eight-bit integer (used for “byte” values), and so on. The <code>isize</code> and <code>usize</code> types hold pointer-sized signed and unsigned integers, 32 bits long on 32-bit platforms, and 64 bits long on 64-bit platforms. Rust also has two floating-point types, <code>f32</code> and <code>f64</code>, which are the IEEE single- and double-precision floating-point types, like <code>float</code> and <code>double</code> in C and C++.</p>

<p><a contenteditable="false" data-primary="mut (exclusive access)" data-type="indexterm" id="idm45251663265368"/>By default, once a variable is initialized, its value can’t be changed, but placing the <code>mut</code> keyword (pronounced “mute”, short for <em>mutable</em>) before the parameters <code>n</code> and <code>m</code> allows our function body to assign to them. In practice, most variables don’t get assigned to; the <code>mut</code> keyword on those that do can be a helpful hint when reading code.</p>

<p><a contenteditable="false" data-primary="assert! macro" data-type="indexterm" id="idm45251663261448"/>The function’s body starts with a call to the <code>assert!</code> macro, verifying that neither argument is zero. The <code>!</code> character marks this as a macro invocation, not a function call. Like the <code>assert</code> macro in C and C++, Rust’s <code>assert!</code> checks that its argument is true, and if it is not, terminates the program with a helpful message including the source location of the failing check; this kind of abrupt termination is called a <em>panic</em>. Unlike C and C++, in which assertions can be skipped, Rust always checks assertions regardless of how the program was compiled. There is also a <code>debug_assert!</code> macro, whose assertions are skipped when the program is compiled for speed.</p>

<p>The heart of our function is a <code>while</code> loop containing an <code>if</code> statement and an assignment. Unlike C and C++, Rust does not require parentheses around the conditional expressions, but it does require curly braces around the statements they control.</p>

<p>A <code>let</code> statement declares a local variable, like <code>t</code> in our function. We don’t need to write out <code>t</code>’s type, as long as Rust can infer it from how the variable is used. In our function, the only type that works for <code>t</code> is <code>u64</code>, matching <code>m</code> and <code>n</code>. Rust only infers types within function bodies: you must write out the types of function parameters and return values, as we did before. If we wanted to spell out <code>t</code>’s type, we could write:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">t</code>: <code class="kt">u64</code> <code class="o">=</code><code class="w"> </code><code class="n">m</code><code class="p">;</code><code class="w"/></pre>

<p>Rust has a <code>return</code> statement, but the <code>gcd</code> function doesn’t need one. If a function body ends with an expression that is <em>not</em> followed by a semicolon, that’s the function’s return value. In fact, any block surrounded by curly braces can function as an expression. For example, this is an expression that prints a message and then yields <code>x.cos()</code> as its value:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"evaluating cos x"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">x</code><code class="p">.</code><code class="n">cos</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>It’s typical in Rust to use this form to establish the function’s value when control “falls off the end” of the function, and use <code>return</code> statements only for explicit early returns from the midst of a function.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Writing and Running Unit Tests"><div class="sect1" id="writing-and-running-unit-tests">
<h1>Writing and Running Unit Tests</h1>

<p><a contenteditable="false" data-primary="Rust (generally)" data-secondary="unit testing in" data-type="indexterm" id="idm45251663198712"/><a contenteditable="false" data-primary="unit testing" data-type="indexterm" id="idm45251663197336"/>Rust has simple support for testing built into the language. To test our <code>gcd</code> function, we can write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="cp">#[test]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">test_gcd</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">gcd</code><code class="p">(</code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">15</code><code class="p">),</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">gcd</code><code class="p">(</code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">3</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">11</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">17</code><code class="p">,</code><code class="w"/>
<code class="w">                   </code><code class="mi">3</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">7</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">11</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">13</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">19</code><code class="p">),</code><code class="w"/>
<code class="w">               </code><code class="mi">3</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">11</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Here we define a function named <code>test_gcd</code>, which calls <code>gcd</code> and checks that it returns correct values. The <code>#[test]</code> atop the definition marks <code>test_gcd</code> as a test function, to be skipped in normal compilations, but included and called automatically if we run our program with the <code>cargo test</code> command. Let’s assume we’ve edited our <code>gcd</code> and <code>test_gcd</code> definitions into the <em>hello</em> package we created at the beginning of the chapter. If our current directory is somewhere within the package’s subtree, we can run the tests as follows:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo <code class="nb">test</code>
<code class="go">   Compiling hello v0.1.0 (file:///home/jimb/rust/hello)</code>
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs</code>
<code class="go">     Running /home/jimb/rust/hello/target/debug/deps/hello-2375a82d9e9673d7</code>

<code class="go">running 1 test</code>
<code class="go">test test_gcd ... ok</code>

<code class="go">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code>

<code class="gp">$</code></pre>

<p>We can have test functions scattered throughout our source tree, placed next to the code they exercise, and <code>cargo test</code> will automatically gather them up and run <span class="keep-together">them all.</span></p>

<p><a contenteditable="false" data-primary="attributes" data-type="indexterm" id="idm45251662837224"/>The <code>#[test]</code> marker is an example of an <em>attribute</em>. Attributes are an open-ended system for marking functions and other declarations with extra information, like attributes in C++ and C#, or annotations in Java. They’re used to control compiler warnings and code style checks, include code conditionally (like <code>#ifdef</code> in C and <span class="keep-together">C++</span>), tell Rust how to interact with code written in other languages, and so on. We’ll see more examples of attributes as we go.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Handling Command-Line Arguments"><div class="sect1" id="handling-command-line-arguments">
<h1>Handling Command-Line Arguments</h1>

<p><a contenteditable="false" data-primary="command-line arguments" data-type="indexterm" id="C02-tour.html3"/><a contenteditable="false" data-primary="Rust (generally)" data-secondary="command-line arguments" data-type="indexterm" id="C02-tour.html4"/>If we want our program to take a series of numbers as command-line arguments and print their greatest common divisor, we can replace the <code>main</code> function with the following:</p>

<pre data-code-language="rust" data-testing="replace-fn-in-current-file main" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Write</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="kt">str</code>::<code class="n">FromStr</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">arg</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">skip</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">numbers</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="kt">u64</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">arg</code><code class="p">)</code><code class="w"/>
<code class="w">                     </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error parsing argument"</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">numbers</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">io</code>::<code class="n">stderr</code><code class="p">(),</code><code class="w"> </code><code class="s">"Usage: gcd NUMBER ..."</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">process</code>::<code class="n">exit</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">numbers</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">numbers</code><code class="p">[</code><code class="mi">1</code><code class="p">..]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">gcd</code><code class="p">(</code><code class="n">d</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">m</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"The greatest common divisor of {:?} is {}"</code><code class="p">,</code><code class="w"/>
<code class="w">             </code><code class="n">numbers</code><code class="p">,</code><code class="w"> </code><code class="n">d</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is a large block of code, so let’s take it piece by piece:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Write</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="kt">str</code>::<code class="n">FromStr</code><code class="p">;</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="traits" data-secondary="defined" data-type="indexterm" id="idm45251673682680"/>The <code>use</code> declarations bring the two <em>traits</em> <code>Write</code> and <code>FromStr</code> into scope. We’ll cover traits in detail in <a data-type="xref" href="ch11.xhtml#traits-and-generics">Chapter 11</a>, but for now we’ll simply say that a trait is a collection of methods that types can implement. Although we never use the names <code>Write</code> or <code>FromStr</code> elsewhere in the program, a trait must be in scope in order to use its methods. In the present case:</p>

<ul>
    <li>
    <p>Any type that implements the <code>Write</code> trait has a <code>write_fmt</code> method that writes formatted text to a stream. The <code>std::io::Stderr</code> type implements <code>Write</code>, and we’ll use the <code>writeln!</code> macro to print error messages; that macro expands to code that uses the <code>write_fmt</code> method.</p>
    </li>
    <li>
    <p>Any type that implements the <code>FromStr</code> trait has a <code>from_str</code> method that tries to parse a value of that type from a string. The <code>u64</code> type implements <code>FromStr</code>, and we’ll call <code>u64::from_str</code> to parse our command-line arguments.</p>
    </li>
</ul>

<p>Moving on to the program’s <code>main</code> function:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/></pre>

<p>Our <code>main</code> function doesn’t return a value, so we can simply omit the <code>-&gt;</code> and type that would normally follow the parameter list.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/></pre>

<p>We declare a mutable local variable <code>numbers</code>, and initialize it to an empty vector. <code>Vec</code> is Rust’s growable vector type, analogous to C++’s <code>std::vector</code>, a Python list, or a JavaScript array. Even though vectors are designed to be grown and shrunk dynamically, we must still mark the variable <code>mut</code> for Rust to let us push numbers onto the end of it.</p>

<p>The type of <code>numbers</code> is <code>Vec&lt;u64&gt;</code>, a vector of <code>u64</code> values, but as before, we don’t need to write that out. Rust will infer it for us, in part because what we push onto the vector are <code>u64</code> values, but also because we pass the vector’s elements to <code>gcd</code>, which accepts only <code>u64</code> values.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">arg</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">skip</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/></pre>

<p>Here we use a <code>for</code> loop to process our command-line arguments, setting the variable <code>arg</code> to each argument in turn, and evaluating the loop body.</p>

<p><a contenteditable="false" data-primary="iterators" data-secondary="defined" data-type="indexterm" id="idm45251673554408"/>The <code>std::env::args</code> function returns an <em>iterator</em>, a value that produces each argument on demand, and indicates when we’re done. Iterators are ubiquitous in Rust; the standard library includes other iterators that produce the elements of a vector, the lines of a file, messages received on a communications channel, and almost anything else that makes sense to loop over. Rust’s iterators are very efficient: the compiler is usually able to translate them into the same code as a handwritten loop. We’ll show how this works and give examples in <a data-type="xref" href="ch15.xhtml#iterators">Chapter 15</a>.</p>

<p>Beyond their use with <code>for</code> loops, iterators include a broad selection of methods you can use directly. For example, the first value produced by the iterator returned by <code>std::env::args</code> is always the name of the program being run. We want to skip that, so we call the iterator’s <code>skip</code> method to produce a new iterator that omits that first value.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">numbers</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="kt">u64</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">arg</code><code class="p">)</code><code class="w"/>
<code class="w">             </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error parsing argument"</code><code class="p">));</code><code class="w"/></pre>

<p>Here we call <code>u64::from_str</code> to attempt to parse our command-line argument <code>arg</code> as an unsigned 64-bit integer. Rather than a method we’re invoking on some <code>u64</code> value we have at hand, <code>u64::from_str</code> is a function associated with the <code>u64</code> type, akin to a static method in C++ or Java. <a contenteditable="false" data-primary="Result value" data-type="indexterm" id="idm45251673455912"/>The <code>from_str</code> function doesn’t return a <code>u64</code> directly, but rather a <code>Result</code> value that indicates whether the parse succeeded or failed. A <code>Result</code> value is one of two variants:</p>

<ul>
    <li>
    <p>A value written <code>Ok(v)</code>, indicating that the parse succeeded and <code>v</code> is the value produced</p>
    </li>
    <li>
    <p>A value written <code>Err(e)</code>, indicating that the parse failed and <code>e</code> is an error value explaining why</p>
    </li>
</ul>

<p>Functions that perform input or output or otherwise interact with the operating system all return <code>Result</code> types whose <code>Ok</code> variants carry successful results—the count of bytes transferred, the file opened, and so on—and whose <code>Err</code> variants carry an error code from the system. Unlike most modern languages, Rust does not have exceptions: all errors are handled using either <code>Result</code> or panic, as outlined in <a data-type="xref" href="ch07.xhtml#error-handling">Chapter 7</a>.</p>

<p>We check the success of our parse by using <code>Result</code>’s <code>expect</code> method. If the result is some <code>Err(e)</code>, <code>expect</code> prints a message that includes a description of <code>e</code>, and exits the program immediately. However, if the result is <code>Ok(v)</code>, <code>expect</code> simply returns <code>v</code> itself, which we are finally able to push onto the end of our vector of numbers.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">if</code><code class="w"> </code><code class="n">numbers</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">io</code>::<code class="n">stderr</code><code class="p">(),</code><code class="w"> </code><code class="s">"Usage: gcd NUMBER ..."</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">std</code>::<code class="n">process</code>::<code class="n">exit</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>There’s no greatest common divisor of an empty set of numbers, so we check that our vector has at least one element, and exit the program with an error if it doesn’t. We use the <code>writeln!</code> macro to write our error message to the standard error output stream, provided by <code>std::io::stderr()</code>. The <code>.unwrap()</code> call is a terse way to check that the attempt to print the error message did not itself fail; an <code>expect</code> call would work too, but that’s probably not worth it.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">numbers</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">numbers</code><code class="p">[</code><code class="mi">1</code><code class="p">..]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">gcd</code><code class="p">(</code><code class="n">d</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">m</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This loop uses <code>d</code> as its running value, updating it to stay the greatest common divisor of all the numbers we’ve processed so far. As before, we must mark <code>d</code> as mutable, so that we can assign to it in the loop.</p>

<p>The <code>for</code> loop has two surprising bits to it. First, we wrote <code>for m in &amp;numbers[1..]</code>; what is the <code>&amp;</code> operator for? Second, we wrote <code>gcd(d, *m)</code>; what is the <code>*</code> in <code>*m</code> for? These two details are complementary to each other.</p>

<p>Up to this point, our code has operated only on simple values like integers that fit in fixed-size blocks of memory. But now we’re about to iterate over a vector, which could be of any size whatsoever—possibly very large. Rust is cautious when handling such values: it wants to leave the programmer in control over memory consumption, making it clear how long each value lives, while still ensuring memory is freed promptly when no longer needed.</p>

<p><a contenteditable="false" data-primary="borrowing" data-secondary="and iteration" data-type="indexterm" id="idm45251673305144"/><a contenteditable="false" data-primary="ownership" data-secondary="and iteration" data-type="indexterm" id="idm45251673303112"/>So when we iterate, we want to tell Rust that <em>ownership</em> of the vector should remain with <code>numbers</code>; we are merely <em>borrowing</em> its elements for the loop. <a contenteditable="false" data-primary="&amp; operator" data-type="indexterm" id="idm45251673300264"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="and iteration" data-type="indexterm" id="idm45251673299160"/>The <code>&amp;</code> operator in <code>&amp;numbers[1..]</code> borrows a <em>reference</em> to the vector’s elements from the second onward. The <code>for</code> loop iterates over the referenced elements, letting <code>m</code> borrow each element in succession. <a contenteditable="false" data-primary="* operator" data-type="indexterm" id="idm45251673295448"/><a contenteditable="false" data-primary="dereferencing" data-type="indexterm" id="idm45251673294344"/>The <code>*</code> operator in <code>*m</code> <em>dereferences</em> <code>m</code>, yielding the value it refers to; this is the next <code>u64</code> we want to pass to <code>gcd</code>. Finally, since <code>numbers</code> owns the vector, Rust automatically frees it when <code>numbers</code> goes out of scope at the end of <code>main</code>.</p>

<p>Rust’s rules for ownership and references are key to Rust’s memory management and safe concurrency; we discuss them in detail in <a data-type="xref" href="ch04.xhtml#ownership">Chapter 4</a> and its companion, <a data-type="xref" href="ch05.xhtml#references">Chapter 5</a>. You’ll need to be comfortable with those rules to be comfortable in Rust, but for this introductory tour, all you need to know is that <code>&amp;x</code> borrows a reference to <code>x</code>, and that <code>*r</code> is the value that the reference <code>r</code> refers to.</p>

<p>Continuing our walk through the program:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"The greatest common divisor of {:?} is {}"</code><code class="p">,</code><code class="w"/>
<code class="w">         </code><code class="n">numbers</code><code class="p">,</code><code class="w"> </code><code class="n">d</code><code class="p">);</code><code class="w"/></pre>

<p>Having iterated over the elements of <code>numbers</code>, the program prints the results to the standard output stream. The <code>println!</code> macro takes a template string, substitutes formatted versions of the remaining arguments for the <code>{...}</code> forms as they appear in the template string, and writes the result to the standard output stream.</p>

<p>Unlike C and C++, which require <code>main</code> to return zero if the program finished successfully, or a nonzero exit status if something went wrong, Rust assumes that if <code>main</code> returns at all, the program finished successfully. Only by explicitly calling functions like <code>expect</code> or <code>std::process::exit</code> can we cause the program to terminate with an error status code.</p>

<p>The <code>cargo run</code> command allows us to pass arguments to our program, so we can try out our command-line handling:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo run <code class="m">42</code> 56
<code class="go">   Compiling hello v0.1.0 (file:///home/jimb/rust/hello)</code>
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs</code>
<code class="go">     Running `/home/jimb/rust/hello/target/debug/hello 42 56`</code>
<code class="go">The greatest common divisor of [42, 56] is 14</code>
<code class="gp">$</code> cargo run <code class="m">799459</code> <code class="m">28823</code> 27347
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</code>
<code class="go">     Running `/home/jimb/rust/hello/target/debug/hello 799459 28823 27347`</code>
<code class="go">The greatest common divisor of [799459, 28823, 27347] is 41</code>
<code class="gp">$</code> cargo run 83
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</code>
<code class="go">     Running `/home/jimb/rust/hello/target/debug/hello 83`</code>
<code class="go">The greatest common divisor of [83] is 83</code>
<code class="gp">$</code> cargo run
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</code>
<code class="go">     Running `/home/jimb/rust/hello/target/debug/hello`</code>
<code class="go">Usage: gcd NUMBER ...</code>
<code class="gp">$</code></pre>

<p>We’ve used a few features from Rust’s standard library in this section. If you’re curious about what else is available, we strongly encourage you to try out Rust’s online documentation. It has a live search feature that makes exploration easy, and even includes links to the source code. The <code>rustup</code> command automatically installs a copy on your computer when you install Rust itself. You can view the standard library documentation in your browser with the command:</p>

<pre class="console" data-code-language="console" data-testing="ignore" data-type="programlisting">
<code class="gp">$</code> rustup doc --std</pre>

<p>You can also view it on the web at <a href="https://doc.rust-lang.org/"><em>https://doc.rust-lang.org/</em></a>.<a contenteditable="false" data-primary="" data-startref="C02-tour.html4" data-type="indexterm" id="idm45251673178824"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html3" data-type="indexterm" id="idm45251673177576"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="A Simple Web Server"><div class="sect1" id="a-simple-web-server">
<h1>A Simple Web Server</h1>

<p><a contenteditable="false" data-primary="Rust (generally)" data-secondary="simple web server" data-type="indexterm" id="C02-tour.html5"/><a contenteditable="false" data-primary="web server, creating with Rust" data-type="indexterm" id="C02-tour.html6"/>One of Rust’s strengths is the freely available collection of library packages published on the website <a href="https://crates.io" class="orm:hideurl">crates.io</a>. The <code>cargo</code> command makes it easy for our own code to use a crates.io package: it will download the right version of the package, build it, and update it as requested. A Rust package, whether a library or an executable, is called a <em>crate</em>; Cargo and crates.io both derive their names from this term.</p>

<p>To show how this works, we’ll put together a simple web server using the <code>iron</code> web framework, the <code>hyper</code> HTTP server, and various other crates on which they depend. As shown in <a data-type="xref" href="#fig0201">Figure 2-1</a>, our website will prompt the user for two numbers, and compute their greatest common divisor.</p>

<figure class="bordernone"><div id="fig0201" class="figure"><img alt="Web page offering to compute GCD" src="Images/rust_0201.png" title="Web page offering to compute GCD"/>
<h6><span class="label">Figure 2-1. </span>Web page offering to compute GCD</h6>
</div></figure>

<p>First, we’ll have Cargo create a new package for us, named <code>iron-gcd</code>:</p>

<pre class="console" data-code-language="console" data-testing="reset-shell-before" data-type="programlisting">
<code class="gp">$</code> cargo new --bin iron-gcd
<code class="go">     Created binary (application) `iron-gcd` project</code>
<code class="gp">$</code> <code class="nb">cd </code>iron-gcd
<code class="gp">$</code></pre>

<p>Then, we’ll edit our new project’s <em>Cargo.toml</em> file to list the packages we want to use; its contents should be as follows:</p>

<pre data-testing="replace-whole-file Cargo.toml" data-type="programlisting">
[package]
name = "iron-gcd"
version = "0.1.0"
authors = ["You &lt;you@example.com&gt;"]

[dependencies]
iron = "0.5.1"
mime = "0.2.3"
router = "0.5.1"
urlencoded = "0.5.0"</pre>

<p>Each line in the <code>[dependencies]</code> section of <em>Cargo.toml</em> gives the name of a crate on crates.io, and the version of that crate we would like to use. There may well be versions of these crates on crates.io newer than those shown here, but by naming the specific versions we tested this code against, we can ensure the code will continue to compile even as new versions of the packages are published. We’ll discuss version management in more detail in <a data-type="xref" href="ch08.xhtml#crates-and-modules">Chapter 8</a>.</p>

<p>Note that we need only name those packages we’ll use directly; <code>cargo</code> takes care of bringing in whatever other packages those need in turn.</p>

<p>For our first iteration, we’ll keep the web server simple: it will serve only the page that prompts the user for numbers to compute with. In <em>iron-gcd/src/main.rs</em>, we’ll place the following text:</p>

<pre data-code-language="rust" data-testing="replace-whole-file src/main.rs" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">iron</code><code class="p">;</code><code class="w"/>
<code class="cp">#[macro_use]</code><code class="w"> </code><code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">mime</code><code class="p">;</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">iron</code>::<code class="n">prelude</code>::<code class="o">*</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">iron</code>::<code class="n">status</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Serving on http://localhost:3000..."</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">Iron</code>::<code class="n">new</code><code class="p">(</code><code class="n">get_form</code><code class="p">).</code><code class="n">http</code><code class="p">(</code><code class="s">"localhost:3000"</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">get_form</code><code class="p">(</code><code class="n">_request</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">IronResult</code><code class="o">&lt;</code><code class="n">Response</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">response</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Response</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">status</code>::<code class="nb">Ok</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">mime</code><code class="o">!</code><code class="p">(</code><code class="n">Text</code><code class="o">/</code><code class="n">Html</code><code class="p">;</code><code class="w"> </code><code class="n">Charset</code><code class="o">=</code><code class="n">Utf8</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">r</code><code class="err">#</code><code class="s">"</code>
<code class="s">        &lt;title&gt;GCD Calculator&lt;/title&gt;</code>
<code class="s">        &lt;form action="</code><code class="o">/</code><code class="n">gcd</code><code class="s">" method="</code><code class="n">post</code><code class="s">"&gt;</code>
<code class="s">          &lt;input type="</code><code class="n">text</code><code class="s">" name="</code><code class="n">n</code><code class="s">"/&gt;</code>
<code class="s">          &lt;input type="</code><code class="n">text</code><code class="s">" name="</code><code class="n">n</code><code class="s">"/&gt;</code>
<code class="s">          &lt;button type="</code><code class="n">submit</code><code class="s">"&gt;Compute GCD&lt;/button&gt;</code>
<code class="s">        &lt;/form&gt;</code>
<code class="s">    "</code><code class="err">#</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">response</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We start with two <code>extern crate</code> directives, which make the <code>iron</code> and <code>mime</code> crates that we cited in our <em>Cargo.toml</em> file available to our program. The <code>#[macro_use]</code> attribute before the <code>extern crate mime</code> item alerts Rust that we plan to use macros exported by this crate.</p>

<p>Next, we have <code>use</code> declarations to bring in some of those crates’ public features. The declaration <code>use iron::prelude::*</code> makes all the public names of the <code>iron::prelude</code> module directly visible in our own code. Generally, it’s preferable to spell out the name you wish to use, as we did for <code>iron::status</code>; but by convention, when a module is named <code>prelude</code>, that means that its exports are intended to provide the sort of general facilities that any user of the crate will probably need. So in this case, a wildcard <code>use</code> directive makes a bit more sense.</p>

<p>Our <code>main</code> function is simple: it prints a message reminding us how to connect to our server, calls <code>Iron::new</code> to create a server, and then sets it listening on TCP port 3000 on the local machine. We pass the <code>get_form</code> function to <code>Iron::new</code>, indicating that the server should use that function to handle all requests; we’ll refine this shortly.</p>

<p>The <code>get_form</code> function itself takes a mutable reference, written <code>&amp;mut</code>, to a <code>Request</code> value representing the HTTP request we’ve been called to handle. While this particular handler function never uses its <code>_request</code> parameter, we’ll see one later that does. For the time being, giving the parameter a name beginning with <code>_</code> tells Rust that we expect the variable to be unused, so it shouldn’t warn us about it.</p>

<p>In the body of the function, we build a <code>Response</code> value. The <code>set_mut</code> method uses its argument’s type to decide which part of the response to set, so each call to <code>set_mut</code> is actually setting a different part of <code>response</code>: passing <code>status::Ok</code> sets the HTTP status; passing the media type of the content (using the handy <code>mime!</code> macro that we imported from the <code>mime</code> crate) sets the <code>Content-Type</code> header; and passing a string sets the response body.</p>

<p>Since the response text contains a lot of double quotes, we write it using the Rust “raw string” syntax: the letter <code>r</code>, zero or more hash marks (that is, the <code>#</code> character), a double quote, and then the contents of the string, terminated by another double quote followed by the same number of hash marks. Any character may occur within a raw string without being escaped, including double quotes; in fact, no escape sequences like <code>\"</code> are recognized. We can always ensure the string ends where we intend by using more hash marks around the quotes than ever appear in the text.</p>

<p>Our function’s return type, <code>IronResult&lt;Response&gt;</code>, is another variant of the <code>Result</code> type we encountered earlier: this is either <code>Ok(r)</code> for some successful <code>Response</code> value <code>r</code>, or <code>Err(e)</code> for some error value <code>e</code>. We construct our return value <code>Ok(response)</code> at the bottom of the function body, using the “last expression” syntax to implicitly specify the function’s return value.</p>

<p>Having written <em>main.rs</em>, we can use the <code>cargo run</code> command to do everything needed to set it running: fetching the needed crates, compiling them, building our own program, linking everything together, and starting it up:</p>

<pre class="console" data-code-language="console" data-testing="cargo-build-instead" data-type="programlisting">
<code class="gp">$</code> cargo run
<code class="go">    Updating registry `https://github.com/rust-lang/crates.io-index`</code>
<code class="go"> Downloading iron v0.5.1</code>
<code class="go"> Downloading urlencoded v0.5.0</code>
<code class="go"> Downloading router v0.5.1</code>
<code class="go"> Downloading hyper v0.10.8</code>
<code class="go"> Downloading lazy_static v0.2.8</code>
<code class="go"> Downloading bodyparser v0.5.0</code>
<code class="go">...</code>
<code class="go">   Compiling conduit-mime-types v0.7.3</code>
<code class="go">   Compiling iron v0.5.1</code>
<code class="go">   Compiling router v0.5.1</code>
<code class="go">   Compiling persistent v0.3.0</code>
<code class="go">   Compiling bodyparser v0.5.0</code>
<code class="go">   Compiling urlencoded v0.5.0</code>
<code class="go">   Compiling iron-gcd v0.1.0 (file:///home/jimb/rust/iron-gcd)</code>
<code class="go">     Running `target/debug/iron-gcd`</code>
<code class="go">Serving on http://localhost:3000...</code></pre>

<p>At this point, we can visit the given URL in our browser and see the page shown earlier in <a data-type="xref" href="#fig0201">Figure 2-1</a>.</p>

<p>Unfortunately, clicking Compute GCD doesn’t do anything, other than navigate our browser to the URL <em>http://localhost:3000/gcd</em>, which then shows the same page; in fact, every URL on our server does this. Let’s fix that next, using the <code>Router</code> type to associate different handlers with different paths.</p>

<p>First, let’s arrange to be able to use <code>Router</code> without qualification, by adding the following declarations to <em>iron-gcd/src/main.rs</em>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">router</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">router</code>::<code class="n">Router</code><code class="p">;</code><code class="w"/></pre>

<p>Rust programmers typically gather all their <code>extern crate</code> and <code>use</code> declarations together toward the top of the file, but this isn’t strictly necessary: Rust allows declarations to occur in any order, as long as they appear at the appropriate level of nesting. (Macro definitions and <code>extern crate</code> items with <code>#[macro_use]</code> attributes are exceptions to this rule: they must appear before they are used.)</p>

<p>We can then modify our <code>main</code> function to read as follows:</p>

<pre data-code-language="rust" data-testing="replace-fn-in-current-file main" data-type="programlisting">
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">router</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Router</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="n">router</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code><code class="w"> </code><code class="n">get_form</code><code class="p">,</code><code class="w"> </code><code class="s">"root"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">router</code><code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="s">"/gcd"</code><code class="p">,</code><code class="w"> </code><code class="n">post_gcd</code><code class="p">,</code><code class="w"> </code><code class="s">"gcd"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Serving on http://localhost:3000..."</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">Iron</code>::<code class="n">new</code><code class="p">(</code><code class="n">router</code><code class="p">).</code><code class="n">http</code><code class="p">(</code><code class="s">"localhost:3000"</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We create a <code>Router</code>, establish handler functions for two specific paths, and then pass this <code>Router</code> as the request handler to <code>Iron::new</code>, yielding a web server that consults the URL path to decide which handler function to call.</p>

<p>Now we are ready to write our <code>post_gcd</code> function:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">urlencoded</code><code class="p">;</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="kt">str</code>::<code class="n">FromStr</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">urlencoded</code>::<code class="n">UrlEncodedBody</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">post_gcd</code><code class="p">(</code><code class="n">request</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">IronResult</code><code class="o">&lt;</code><code class="n">Response</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">response</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Response</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">form_data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">request</code><code class="p">.</code><code class="n">get_ref</code>::<code class="o">&lt;</code><code class="n">UrlEncodedBody</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">status</code>::<code class="n">BadRequest</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"Error parsing form data: {:?}</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">));</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">response</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">map</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">map</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">unparsed_numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">form_data</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="s">"n"</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">status</code>::<code class="n">BadRequest</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"form data has no 'n' parameter</code><code class="se">\n</code><code class="s">"</code><code class="p">));</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">response</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">nums</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">nums</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">unparsed</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">unparsed_numbers</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="kt">u64</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">unparsed</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nb">Err</code><code class="p">(</code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">status</code>::<code class="n">BadRequest</code><code class="p">);</code><code class="w"/>
<code class="w">                </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="w"/>
<code class="w">                    </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"Value for 'n' parameter not a number: {:?}</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"/>
<code class="w">                            </code><code class="n">unparsed</code><code class="p">));</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">response</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="nb">Ok</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">numbers</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">n</code><code class="p">);</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">numbers</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">numbers</code><code class="p">[</code><code class="mi">1</code><code class="p">..]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">gcd</code><code class="p">(</code><code class="n">d</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">m</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">status</code>::<code class="nb">Ok</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="n">mime</code><code class="o">!</code><code class="p">(</code><code class="n">Text</code><code class="o">/</code><code class="n">Html</code><code class="p">;</code><code class="w"> </code><code class="n">Charset</code><code class="o">=</code><code class="n">Utf8</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="n">response</code><code class="p">.</code><code class="n">set_mut</code><code class="p">(</code><code class="w"/>
<code class="w">        </code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"The greatest common divisor of the numbers {:?} is &lt;b&gt;{}&lt;/b&gt;</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="n">numbers</code><code class="p">,</code><code class="w"> </code><code class="n">d</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">response</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="match expressions" data-type="indexterm" id="idm45251672685432"/>The bulk of this function is a series of <code>match</code> expressions, which will be unfamiliar to C, C++, Java, and JavaScript programmers, but a welcome sight to those who work with Haskell and OCaml. We’ve mentioned that a <code>Result</code> is either a value <code>Ok(s)</code> for some success value <code>s</code>, or <code>Err(e)</code> for some error value <code>e</code>. Given some <code>Result</code> <code>res</code>, we can check which variant it is and access whichever value it holds with a <code>match</code> expression of the form:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="k">match</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">success</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="nb">Err</code><code class="p">(</code><code class="n">error</code><code class="p">)</code><code class="w">  </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is a conditional, like an <code>if</code> statement or a <code>switch</code> statement in C: if <code>res</code> is <code>Ok(v)</code>, then it runs the first branch, with the variable <code>success</code> set to <code>v</code>. Similarly, if <code>res</code> is <code>Err(e)</code>, it runs the second branch with <code>error</code> set to <code>e</code>. The <code>success</code> and <code>error</code> variables are each local to their branch. The value of the entire match expression is the value of the branch that runs.</p>

<p>The beauty of a <code>match</code> expression is that the program can only access the value of a <code>Result</code> by first checking which variant it is; one can never misinterpret a failure value as a successful completion. Whereas in C and C++ it’s a common error to forget to check for an error code or a null pointer, in Rust, these mistakes are caught at compile time. This simple measure is a significant advance in usability.</p>

<p>Rust allows you to define your own types like <code>Result</code> with value-carrying variants, and use match expressions to analyze them. Rust calls these types <em>enums</em>; you may know them from other languages as <em>algebraic data types</em>. We describe enumerations in detail in <a data-type="xref" href="ch10.xhtml#enums-and-patterns">Chapter 10</a>.</p>

<p>Now that you can read <code>match</code> expressions, the structure of <code>post_gcd</code> should be clear:</p>

<ul>
    <li>
    <p>It calls <code>request.get_ref::&lt;UrlEncodedBody&gt;()</code> to parse the request’s body as a table mapping query parameter names to arrays of values; if this parse fails, it reports the error back to the client. The <code>::&lt;UrlEncodedBody&gt;</code> part of the method call is a <em>type parameter</em> indicating which part of the <code>Request</code> <code>get_ref</code> should retrieve. In this case, the <code>UrlEncodedBody</code> type refers to the body, parsed as a URL-encoded query string. We’ll talk more about type parameters in the next section.</p>
    </li>
    <li>
    <p>Within that table, it finds the value of the parameter named <code>"n"</code>, which is where the HTML form places the numbers entered into the web page. This value will be not a single string but a vector of strings, as query parameter names can be repeated.</p>
    </li>
    <li>
    <p>It walks the vector of strings, parsing each one as an unsigned 64-bit number, and returning an appropriate failure page if any of the strings fail to parse.</p>
    </li>
    <li>
    <p>Finally, it computes the numbers’ greatest common divisor as before, and constructs a response describing the results. The <code>format!</code> macro uses the same kind of string template as the <code>writeln!</code> and <code>println!</code> macros, but returns a string value, rather than writing the text to a stream.</p>
    </li>
</ul>

<p>The last remaining piece is the <code>gcd</code> function we wrote earlier. With that in place, you can interrupt any servers you might have left running, and rebuild and restart the program:</p>

<pre class="console" data-code-language="console" data-testing="paste-code cargo-build-instead" data-type="programlisting">
<code class="gp">$</code> cargo run
<code class="go">   Compiling iron-gcd v0.1.0 (file:///home/jimb/rust/iron-gcd)</code>
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</code>
<code class="go">     Running `target/debug/iron-gcd`</code>
<code class="go">Serving on http://localhost:3000...</code></pre>

<p>This time, by visiting <em>http://localhost:3000</em>, entering some numbers, and clicking the Compute GCD button, you should actually see some results (<a data-type="xref" href="#fig0202">Figure 2-2</a>).<a contenteditable="false" data-primary="" data-startref="C02-tour.html6" data-type="indexterm" id="idm45251668942040"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html5" data-type="indexterm" id="idm45251668887528"/></p>

<figure class="bordernone"><div id="fig0202" class="figure"><img alt="Web page showing results of computing GCD" src="Images/rust_0202.png" title="Web page showing results of computing GCD"/>
<h6><span class="label">Figure 2-2. </span>Web page showing results of computing GCD</h6>
</div></figure>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Concurrency"><div class="sect1" id="tour-concurrency">
<h1>Concurrency</h1>

<p><a contenteditable="false" data-primary="concurrency/concurrent programming" data-secondary="Rust's support for" data-type="indexterm" id="C02-tour.html7"/><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="concurrent implementation" data-type="indexterm" id="C02-tour.html8"/><a contenteditable="false" data-primary="Rust (generally)" data-secondary="concurrency" data-type="indexterm" id="C02-tour.html9"/>One of Rust’s great strengths is its support for concurrent programming. The same rules that ensure <a contenteditable="false" data-primary="data races" data-secondary="Rust's mechanisms for avoiding" data-type="indexterm" id="idm45251668933032"/>Rust programs are free of memory errors also ensure threads can share memory only in ways that avoid data races. For example:</p>

<ul>
    <li>
    <p>If you use a mutex to coordinate threads making changes to a shared data structure, Rust ensures that you can’t access the data except when you’re holding the lock, and releases the lock automatically when you’re done. In C and C++, the relationship between a mutex and the data it protects is left to the comments.</p>
    </li>
    <li>
    <p>If you want to share read-only data among several threads, Rust ensures that you cannot modify the data accidentally. In C and C++, the type system can help with this, but it’s easy to get it wrong.</p>
    </li>
    <li>
    <p>If you transfer ownership of a data structure from one thread to another, Rust makes sure you have indeed relinquished all access to it. In C and C++, it’s up to you to check that nothing on the sending thread will ever touch the data again. If you don’t get it right, the effects can depend on what happens to be in the processor’s cache and how many writes to memory you’ve done recently. Not that we’re bitter.</p>
    </li>
</ul>

<p>In this section, we’ll walk you through the process of writing your second multi-threaded program.</p>

<p>Although you probably weren’t aware of it, you’ve already written your first: the Iron web framework you used to implement the Greatest Common Divisor server uses a pool of threads to run request handler functions. If the server receives simultaneous requests, it may run the <code>get_form</code> and <code>post_gcd</code> functions in several threads at once. That may come as a bit of a shock, since we certainly didn’t have concurrency in mind when we wrote those functions. But Rust guarantees this is safe to do, no matter how elaborate your server gets: if your program compiles, it is free of data races. All Rust functions are thread-safe.</p>

<p>This section’s program plots the Mandelbrot set, a fractal produced by iterating a simple function on complex numbers. Plotting the Mandelbrot set is often called an <em>embarrassingly parallel</em> algorithm, because the pattern of communication between the threads is so simple; we’ll cover more complex patterns in <a data-type="xref" href="ch19.xhtml#concurrency">Chapter 19</a>, but this task demonstrates some of the essentials.</p>

<p>To get started, we’ll create a fresh Rust project:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo new --bin mandelbrot
<code class="go">     Created binary (application) `mandelbrot` project</code></pre>

<p>All the code will go in <em>mandelbrot/src/main.rs</em>, and we’ll add some dependencies to <em>mandelbrot/Cargo.toml</em>.</p>

<p>Before we get into the concurrent Mandelbrot implementation, we need to describe the computation we’re going to perform.</p>

<section data-type="sect2" data-pdf-bookmark="What the Mandelbrot Set Actually Is"><div class="sect2" id="what-the-mandelbrot-set-actually-is">
<h2>What the Mandelbrot Set Actually Is</h2>

<p><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="basics of calculation" data-type="indexterm" id="C02-tour.html10"/>When reading code, it’s helpful to have a concrete idea of what it’s trying to do, so let’s take a short excursion into some pure mathematics. We’ll start with a simple case, and then add complicating details until we arrive at the calculation at the heart of the Mandelbrot set.</p>

<p>Here’s an infinite loop, written using Rust’s dedicated syntax for that, a <code>loop</code> <span class="keep-together">statement:</span></p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="k">fn</code> <code class="nf">square_loop</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="n">x</code>: <code class="kt">f64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In real life, Rust can see that <code>x</code> is never used for anything, and so might not bother computing its value. But for the time being, assume the code runs as written. What happens to the value of <code>x</code>? Squaring any number smaller than 1 makes it smaller, so it approaches zero; squaring 1 yields 1; squaring a number larger than 1 makes it larger, so it approaches infinity; and squaring a negative number makes it positive, after which it behaves as one of the prior cases (<a data-type="xref" href="#fig0203">Figure 2-3</a>).</p>

<figure><div id="fig0203" class="figure"><img alt="real number line, showing effect of repeated squaring on various numbers" src="Images/rust_02in01.png"/>
<h6><span class="label">Figure 2-3. </span>Effects of repeatedly squaring a number</h6>
</div></figure>

<p>So depending on the value you pass to <code>square_loop</code>, <code>x</code> either approaches zero, stays at 1, or approaches infinity.</p>

<p>Now consider a slightly different loop:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="k">fn</code> <code class="nf">square_add_loop</code><code class="p">(</code><code class="n">c</code>: <code class="kt">f64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0.</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">c</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This time, <code>x</code> starts at zero, and we tweak its progress in each iteration by adding in <code>c</code> after squaring it. This makes it harder to see how <code>x</code> fares, but some experimentation shows that if <code>c</code> is greater than 0.25, or less than –2.0, then <code>x</code> eventually becomes infinitely large; otherwise, it stays somewhere in the neighborhood of zero.</p>

<p>The next wrinkle: instead of using <code>f64</code> values, consider the same loop using complex numbers. The <code>num</code> crate on crates.io provides a complex number type we can use, so we must add a line for <code>num</code> to the <code>[dependencies]</code> section in our program’s <em>Cargo.toml</em> file. Here’s the entire file, up to this point (we’ll be adding more later):</p>

<pre data-testing="reset-shell-before cargo-new-bin mandelbrot replace-whole-file Cargo.toml" data-type="programlisting">
[package]
name = "mandelbrot"
version = "0.1.0"
authors = ["You &lt;you@example.com&gt;"]

[dependencies]
num = "0.1.27"</pre>

<p>Now we can write the penultimate version of our loop:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">num</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">num</code>::<code class="n">Complex</code><code class="p">;</code><code class="w"/>

<code class="cp">#[allow(dead_code)]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">complex_square_add_loop</code><code class="p">(</code><code class="n">c</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="mf">0.0</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">c</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>It’s traditional to use <code>z</code> for complex numbers, so we’ve renamed our looping variable. The expression <code>Complex { re: 0.0, im: 0.0 }</code> is the way we write complex zero using the <code>num</code> crate’s <code>Complex</code> type. <code>Complex</code> is a Rust structure type (or <em>struct</em>), defined like this:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Complex</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Real portion of the complex number</code>
<code class="w">    </code><code class="n">re</code>: <code class="nc">T</code><code class="p">,</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Imaginary portion of the complex number</code>
<code class="w">    </code><code class="n">im</code>: <code class="nc">T</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The preceding code defines a struct named <code>Complex</code>, with two fields, <code>re</code> and <code>im</code>. <a contenteditable="false" data-primary="generic structs" data-type="indexterm" id="idm45251668515560"/><code>Complex</code> is a <em>generic</em> structure: you can read the <code>&lt;T&gt;</code> after the type name as “for any type <code>T</code>”. For example, <code>Complex&lt;f64&gt;</code> is a complex number whose <code>re</code> and <code>im</code> fields are <code>f64</code> values, <code>Complex&lt;f32&gt;</code> would use 32-bit floats, and so on. Given this definition, an expression like <code>Complex { re: R, im: I }</code> produces a <code>Complex</code> value with its <code>re</code> field initialized to <code>R</code>, and its <code>im</code> field initialized to <code>I</code>.</p>

<p>The <code>num</code> crate arranges for <code>*</code>, <code>+</code>, and other arithmetic operators to work on <code>Complex</code> values, so the rest of the function works just like the prior version, except that it operates on points on the complex plane, not just points along the real number line. We’ll explain how you can make Rust’s operators work with your own types in <a data-type="xref" href="ch12.xhtml#operator-overloading">Chapter 12</a>.</p>

<p>Finally, we’ve reached the destination of our pure math excursion. The Mandelbrot set is defined as the set of complex numbers <code>c</code> for which <code>z</code> does not fly out to infinity. Our original simple squaring loop was predictable enough: any number greater than 1 or less than –1 flies away. Throwing a <code>+ c</code> into each iteration makes the behavior a little harder to anticipate: as we said earlier, values of <code>c</code> greater than 0.25 or less than –2 cause <code>z</code> to fly away. But expanding the game to complex numbers produces truly bizarre and beautiful patterns, which are what we want to plot.</p>

<p>Since a complex number <code>c</code> has both real and imaginary components <code>c.re</code> and <code>c.im</code>, we’ll treat these as the <code>x</code> and <code>y</code> coordinates of a point on the Cartesian plane, and color the point black if <code>c</code> is in the Mandelbrot set, or a lighter color otherwise. So for each pixel in our image, we must run the preceding loop on the corresponding point on the complex plane, see whether it escapes to infinity or orbits around the origin forever, and color it accordingly.</p>

<p>The infinite loop takes a while to run, but there are two tricks for the impatient. First, if we give up on running the loop forever and just try some limited number of iterations, it turns out that we still get a decent approximation of the set. How many iterations we need depends on how precisely we want to plot the boundary. Second, it’s been shown that, if <code>z</code> ever once leaves the circle of radius two centered at the origin, it will definitely fly infinitely far away from the origin eventually.</p>

<p>So here’s the final version of our loop, and the heart of our program:</p>

<pre data-code-language="rust" data-testing="replace-whole-file src/main.rs" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">num</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">num</code>::<code class="n">Complex</code><code class="p">;</code><code class="w"/>

<code class="sd">/// Try to determine if `c` is in the Mandelbrot set, using at most `limit`</code>
<code class="sd">/// iterations to decide.</code>
<code class="sd">///</code>
<code class="sd">/// If `c` is not a member, return `Some(i)`, where `i` is the number of</code>
<code class="sd">/// iterations it took for `c` to leave the circle of radius two centered on the</code>
<code class="sd">/// origin. If `c` seems to be a member (more precisely, if we reached the</code>
<code class="sd">/// iteration limit without being able to prove that `c` is not a member),</code>
<code class="sd">/// return `None`.</code>
<code class="k">fn</code> <code class="nf">escape_time</code><code class="p">(</code><code class="n">c</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">limit</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="kt">u32</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="mf">0.0</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="p">..</code><code class="n">limit</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">c</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">z</code><code class="p">.</code><code class="n">norm_sqr</code><code class="p">()</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mf">4.0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nb">None</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function takes the complex number <code>c</code> that we want to test for membership in the Mandelbrot set, and a limit on the number of iterations to try before giving up and declaring <code>c</code> to probably be a member.</p>

<p>The function’s return value is an <code>Option&lt;u32&gt;</code>. Rust’s standard library defines the <code>Option</code> type as follows:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="k">enum</code> <code class="nb">Option</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">T</code><code class="p">),</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="enums" data-secondary="defined" data-type="indexterm" id="idm45251668303336"/><code>Option</code> is an <em>enumerated type</em>, often called an <em>enum</em>, because its definition enumerates several variants that a value of this type could be: for any type <code>T</code>, a value of type <code>Option&lt;T&gt;</code> is either <code>Some(v)</code>, where <code>v</code> is a value of type <code>T</code>; or <code>None</code>, indicating no <code>T</code> value is available. Like the <code>Complex</code> type we discussed earlier, <code>Option</code> is a generic type: you can use <code>Option&lt;T&gt;</code> to represent an optional value of any type <code>T</code> you like.</p>

<p>In our case, <code>escape_time</code> returns an <code>Option&lt;u32&gt;</code> to indicate whether <code>c</code> is in the Mandelbrot set—and if it’s not, how long we had to iterate to find that out. If <code>c</code> is not in the set, <code>escape_time</code> returns <code>Some(i)</code>, where <code>i</code> is the number of the iteration at which <code>z</code> left the circle of radius two. Otherwise, <code>c</code> is apparently in the set, and <code>escape_time</code> returns <code>None</code>.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="p">..</code><code class="n">limit</code><code class="w"> </code><code class="p">{</code><code class="w"/></pre>

<p>The earlier examples showed <code>for</code> loops iterating over command-line arguments and vector elements; this <code>for</code> loop simply iterates over the range of integers starting with <code>0</code> and up to (but not including) <code>limit</code>.</p>

<p>The <code>z.norm_sqr()</code> method call returns the square of <code>z</code>’s distance from the origin. To decide whether <code>z</code> has left the circle of radius two, instead of computing a square root, we just compare the squared distance with 4.0, which is faster.</p>

<p><a contenteditable="false" data-primary="/// (documentation comments)" data-type="indexterm" id="idm45251668246536"/><a contenteditable="false" data-primary="documentation comments" data-type="indexterm" id="idm45251668245240"/>You may have noticed that we use <code>///</code> to mark the comment lines above the function definition; the comments above the members of the <code>Complex</code> structure start with <code>///</code> as well. These are <em>documentation comments</em>; the <code>rustdoc</code> utility knows how to parse them, together with the code they describe, and produce online documentation. The documentation for Rust’s standard library is written in this form. We describe documentation comments in detail in <a data-type="xref" href="ch08.xhtml#crates-and-modules">Chapter 8</a>.</p>

<p>The rest of the program is concerned with deciding which portion of the set to plot at what resolution, and distributing the work across several threads to speed up the <span class="keep-together">calculation.</span><a contenteditable="false" data-primary="" data-startref="C02-tour.html10" data-type="indexterm" id="idm45251668239448"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Parsing Pair Command-Line Arguments"><div class="sect2" id="parsing-pair-command-line-arguments">
<h2>Parsing Pair Command-Line Arguments</h2>

<p><a contenteditable="false" data-primary="command-line arguments" data-type="indexterm" id="C02-tour.html11"/><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="parsing pair command-line arguments" data-type="indexterm" id="C02-tour.html12"/>The program needs to take several command-line arguments controlling the resolution of the image we’ll write, and the portion of the Mandelbrot set the image shows. Since these command-line arguments all follow a common form, here’s a function to parse them:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="kt">str</code>::<code class="n">FromStr</code><code class="p">;</code><code class="w"/>

<code class="sd">/// Parse the string `s` as a coordinate pair, like `"400x600"` or `"1.0,0.5"`.</code>
<code class="sd">///</code>
<code class="sd">/// Specifically, `s` should have the form &lt;left&gt;&lt;sep&gt;&lt;right&gt;, where &lt;sep&gt; is</code>
<code class="sd">/// the character given by the `separator` argument, and &lt;left&gt; and &lt;right&gt; are both</code>
<code class="sd">/// strings that can be parsed by `T::from_str`.</code>
<code class="sd">///</code>
<code class="sd">/// If `s` has the proper form, return `Some&lt;(x, y)&gt;`. If it doesn't parse</code>
<code class="sd">/// correctly, return `None`.</code>
<code class="k">fn</code> <code class="nf">parse_pair</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nc">FromStr</code><code class="o">&gt;</code><code class="p">(</code><code class="n">s</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">separator</code>: <code class="nc">char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="p">(</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="n">separator</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">index</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">match</code><code class="w"> </code><code class="p">(</code><code class="n">T</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">[..</code><code class="n">index</code><code class="p">]),</code><code class="w"> </code><code class="n">T</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">[</code><code class="n">index</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">..]))</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="p">(</code><code class="nb">Ok</code><code class="p">(</code><code class="n">l</code><code class="p">),</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">r</code><code class="p">))</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">((</code><code class="n">l</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">)),</code><code class="w"/>
<code class="w">                </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cp">#[test]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">test_parse_pair</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_pair</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(</code><code class="s">""</code><code class="p">,</code><code class="w">        </code><code class="sc">','</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_pair</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"10,"</code><code class="p">,</code><code class="w">     </code><code class="sc">','</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_pair</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(</code><code class="s">",10"</code><code class="p">,</code><code class="w">     </code><code class="sc">','</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_pair</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"10,20"</code><code class="p">,</code><code class="w">   </code><code class="sc">','</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">((</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">)));</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_pair</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"10,20xy"</code><code class="p">,</code><code class="w"> </code><code class="sc">','</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_pair</code>::<code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"0.5x"</code><code class="p">,</code><code class="w">    </code><code class="sc">'x'</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_pair</code>::<code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">(</code><code class="s">"0.5x1.5"</code><code class="p">,</code><code class="w"> </code><code class="sc">'x'</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">((</code><code class="mf">0.5</code><code class="p">,</code><code class="w"> </code><code class="mf">1.5</code><code class="p">)));</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="generic functions" data-type="indexterm" id="idm45251668210792"/>The definition of <code>parse_pair</code> is a <em>generic function</em>:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">fn</code> <code class="nf">parse_pair</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nc">FromStr</code><code class="o">&gt;</code><code class="p">(</code><code class="n">s</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">separator</code>: <code class="nc">char</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="p">(</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/></pre>

<p>You can read the clause <code>&lt;T: FromStr&gt;</code> aloud as, “For any type <code>T</code> that implements the <code>FromStr</code> trait...”. This effectively lets us define an entire family of functions at once: <code>parse_pair::&lt;i32&gt;</code> is a function that parses pairs of <code>i32</code> values; <code>parse_pair::&lt;f64&gt;</code> parses pairs of floating-point values; and so on. This is very much like a function template in C++. <a contenteditable="false" data-primary="type parameters" data-type="indexterm" id="idm45251667999112"/>A Rust programmer would call <code>T</code> a <em>type parameter</em> of <code>parse_pair</code>. When you use a generic function, Rust will often be able to infer type parameters for you, and you won’t need to write them out as we did in the test code.</p>

<p>Our return type is <code>Option&lt;(T, T)&gt;</code>: either <code>None</code>, or a value <code>Some((v1, v2))</code>, where <code>(v1, v2)</code> is a tuple of two values, both of type <code>T</code>. The <code>parse_pair</code> function doesn’t use an explicit return statement, so its return value is the value of the last (and the only) expression in its body:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">match</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="n">separator</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">index</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>String</code> type’s <code>find</code> method searches the string for a character that matches <code>separator</code>. If <code>find</code> returns <code>None</code>, meaning that the separator character doesn’t occur in the string, the entire <code>match</code> expression evaluates to <code>None</code>, indicating that the parse failed. Otherwise, we take <code>index</code> to be the separator’s position in the string.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting" class="pagebreak-before">
<code class="k">match</code><code class="w"> </code><code class="p">(</code><code class="n">T</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">[..</code><code class="n">index</code><code class="p">]),</code><code class="w"> </code><code class="n">T</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">[</code><code class="n">index</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">..]))</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="nb">Ok</code><code class="p">(</code><code class="n">l</code><code class="p">),</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">r</code><code class="p">))</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">((</code><code class="n">l</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">)),</code><code class="w"/>
<code class="w">    </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This begins to show off the power of the <code>match</code> expression. The argument to the match is this tuple expression:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="p">(</code><code class="n">T</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">[..</code><code class="n">index</code><code class="p">]),</code><code class="w"> </code><code class="n">T</code>::<code class="n">from_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">s</code><code class="p">[</code><code class="n">index</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">..]))</code><code class="w"/></pre>

<p>The expressions <code>&amp;s[..index]</code> and <code>&amp;s[index + 1..]</code> are slices of the string, preceding and following the separator. The type parameter <code>T</code>’s associated <code>from_str</code> function takes each of these and tries to parse them as a value of type <code>T</code>, producing a tuple of results. This is what we match against:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="p">(</code><code class="nb">Ok</code><code class="p">(</code><code class="n">l</code><code class="p">),</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="n">r</code><code class="p">))</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">((</code><code class="n">l</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">)),</code><code class="w"/></pre>

<p>This pattern matches only if both elements of the tuple are <code>Ok</code> variants of the <code>Result</code> type, indicating that both parses succeeded. If so, <code>Some((l, r))</code> is the value of the match expression, and hence the return value of the function.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="w"/></pre>

<p>The wildcard pattern <code>_</code> matches anything, and ignores its value. If we reach this point, then <code>parse_pair</code> has failed, so we evaluate to <code>None</code>, again providing the return value of the function.</p>

<p>Now that we have <code>parse_pair</code>, it’s easy to write a function to parse a pair of floating-point coordinates and return them as a <code>Complex&lt;f64&gt;</code> value:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Parse a pair of floating-point numbers separated by a comma as a complex</code>
<code class="sd">/// number.</code>
<code class="k">fn</code> <code class="nf">parse_complex</code><code class="p">(</code><code class="n">s</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">parse_pair</code><code class="p">(</code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="sc">','</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">((</code><code class="n">re</code><code class="p">,</code><code class="w"> </code><code class="n">im</code><code class="p">))</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code><code class="p">,</code><code class="w"> </code><code class="n">im</code><code class="w"> </code><code class="p">}),</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cp">#[test]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">test_parse_complex</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_complex</code><code class="p">(</code><code class="s">"1.25,-0.0625"</code><code class="p">),</code><code class="w"/>
<code class="w">               </code><code class="nb">Some</code><code class="p">(</code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="mf">1.25</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="o">-</code><code class="mf">0.0625</code><code class="w"> </code><code class="p">}));</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">parse_complex</code><code class="p">(</code><code class="s">",-0.0625"</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>parse_complex</code> function calls <code>parse_pair</code>, builds a <code>Complex</code> value if the coordinates were parsed successfully, and passes failures along to its caller.</p>

<p>If you were reading closely, you may have noticed that we used a shorthand notation to build the <code>Complex</code> value. It’s common to initialize a struct’s fields with variables of the same name, so rather than forcing you to write <code>Complex { re: re, im: im }</code>, Rust lets you simply write <code>Complex { re, im }</code>. This is modeled on similar notations in JavaScript and Haskell.<a contenteditable="false" data-primary="" data-startref="C02-tour.html12" data-type="indexterm" id="idm45251671046184"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html11" data-type="indexterm" id="idm45251671044808"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Mapping from Pixels to Complex Numbers"><div class="sect2" id="mapping-from-pixels-to-complex-numbers">
<h2>Mapping from Pixels to Complex Numbers</h2>

<p><a contenteditable="false" data-primary="complex numbers" data-type="indexterm" id="idm45251671042360"/><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="mapping from pixels to complex numbers" data-type="indexterm" id="idm45251671041256"/><a contenteditable="false" data-primary="mapping" data-type="indexterm" id="idm45251671039912"/>The program needs to work in two related coordinate spaces: each pixel in the output image corresponds to a point on the complex plane. The relationship between these two spaces depends on which portion of the Mandelbrot set we’re going to plot, and the resolution of the image requested, as determined by command-line arguments. The following function converts from <em>image space</em> to <em>complex number space</em>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Given the row and column of a pixel in the output image, return the</code>
<code class="sd">/// corresponding point on the complex plane.</code>
<code class="sd">///</code>
<code class="sd">/// `bounds` is a pair giving the width and height of the image in pixels.</code>
<code class="sd">/// `pixel` is a (column, row) pair indicating a particular pixel in that image.</code>
<code class="sd">/// The `upper_left` and `lower_right` parameters are points on the complex</code>
<code class="sd">/// plane designating the area our image covers.</code>
<code class="k">fn</code> <code class="nf">pixel_to_point</code><code class="p">(</code><code class="n">bounds</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">),</code><code class="w"/>
<code class="w">                  </code><code class="n">pixel</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">),</code><code class="w"/>
<code class="w">                  </code><code class="n">upper_left</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">                  </code><code class="n">lower_right</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">)</code><code class="w"/>
<code class="w">    </code>-&gt; <code class="nc">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">width</code><code class="p">,</code><code class="w"> </code><code class="n">height</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">lower_right</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">upper_left</code><code class="p">.</code><code class="n">re</code><code class="p">,</code><code class="w"/>
<code class="w">                           </code><code class="n">upper_left</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">lower_right</code><code class="p">.</code><code class="n">im</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">re</code>: <code class="nc">upper_left</code><code class="p">.</code><code class="n">re</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">pixel</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">f64</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">width</code><code class="w">  </code><code class="o">/</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">f64</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">im</code>: <code class="nc">upper_left</code><code class="p">.</code><code class="n">im</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">pixel</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">f64</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">height</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">f64</code><code class="w"/>
<code class="w">        </code><code class="c1">// Why subtraction here? pixel.1 increases as we go down,</code>
<code class="w">        </code><code class="c1">// but the imaginary component increases as we go up.</code>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="cp">#[test]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">test_pixel_to_point</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">pixel_to_point</code><code class="p">((</code><code class="mi">100</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">),</code><code class="w"> </code><code class="p">(</code><code class="mi">25</code><code class="p">,</code><code class="w"> </code><code class="mi">75</code><code class="p">),</code><code class="w"/>
<code class="w">                              </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="o">-</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>:  <code class="mf">1.0</code><code class="w"> </code><code class="p">},</code><code class="w"/>
<code class="w">                              </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>:  <code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="o">-</code><code class="mf">1.0</code><code class="w"> </code><code class="p">}),</code><code class="w"/>
<code class="w">               </code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="o">-</code><code class="mf">0.5</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="o">-</code><code class="mf">0.5</code><code class="w"> </code><code class="p">});</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><a data-type="xref" href="#tour-pixel-to-point">Figure 2-4</a> illustrates the calculation <code>pixel_to_point</code> performs.</p>

<figure><div id="tour-pixel-to-point" class="figure"><img alt="(The complex points `upper_left` and `lower_right` mark            two opposite corners of a rectangle.            The rectangle is divided into `bounds.0` columns and `bounds.1` rows of pixels.            The upper left pixel is row 0, column 0,            and the lower right pixel is row `bounds.0 - 1`, column `bounds.1 - 1`.)" src="Images/rust_0203.png"/>
<h6><span class="label">Figure 2-4. </span>The relationship between the complex plane and the image’s pixels</h6>
</div></figure>

<p>The code of <code>pixel_to_point</code> is simply calculation, so we won’t explain it in detail. However, there are a few things to point out. Expressions with this form refer to tuple elements:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">pixel</code><code class="p">.</code><code class="mi">0</code><code class="w"/></pre>

<p>This refers to the first element of the tuple <code>pixel</code>.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">pixel</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">f64</code><code class="w"/></pre>

<p>This is Rust’s syntax for a type conversion: this converts <code>pixel.0</code> to an <code>f64</code> value. Unlike C and C++, Rust generally refuses to convert between numeric types implicitly; you must write out the conversions you need. This can be tedious, but being explicit about which conversions occur and when is surprisingly helpful. Implicit integer conversions seem innocent enough, but historically they have been a frequent source of bugs and security holes in real-world C and C++ code.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Plotting the Set"><div class="sect2" id="plotting-the-set">
<h2>Plotting the Set</h2>

<p><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="plotting" data-type="indexterm" id="idm45251670759208"/><a contenteditable="false" data-primary="plotting" data-secondary="Mandelbrot set" data-type="indexterm" id="idm45251670757832"/>To plot the Mandelbrot set, for every pixel in the image, we simply apply <code>escape_time</code> to the corresponding point on the complex plane, and color the pixel depending on the result:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Render a rectangle of the Mandelbrot set into a buffer of pixels.</code>
<code class="sd">///</code>
<code class="sd">/// The `bounds` argument gives the width and height of the buffer `pixels`,</code>
<code class="sd">/// which holds one grayscale pixel per byte. The `upper_left` and `lower_right`</code>
<code class="sd">/// arguments specify points on the complex plane corresponding to the upper-</code>
<code class="sd">/// left and lower-right corners of the pixel buffer.</code>
<code class="k">fn</code> <code class="nf">render</code><code class="p">(</code><code class="n">pixels</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="p">[</code><code class="kt">u8</code><code class="p">],</code><code class="w"/>
<code class="w">          </code><code class="n">bounds</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">),</code><code class="w"/>
<code class="w">          </code><code class="n">upper_left</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="n">lower_right</code>: <code class="nc">Complex</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">)</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">pixels</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">row</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="n">column</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">point</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pixel_to_point</code><code class="p">(</code><code class="n">bounds</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="n">column</code><code class="p">,</code><code class="w"> </code><code class="n">row</code><code class="p">),</code><code class="w"/>
<code class="w">                                       </code><code class="n">upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">lower_right</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="n">pixels</code><code class="p">[</code><code class="n">row</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">column</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">                </code><code class="k">match</code><code class="w"> </code><code class="n">escape_time</code><code class="p">(</code><code class="n">point</code><code class="p">,</code><code class="w"> </code><code class="mi">255</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>
<code class="w">                    </code><code class="nb">Some</code><code class="p">(</code><code class="n">count</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">255</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u8</code><code class="w"/>
<code class="w">                </code><code class="p">};</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This should all look pretty familiar at this point.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">pixels</code><code class="p">[</code><code class="n">row</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">column</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">escape_time</code><code class="p">(</code><code class="n">point</code><code class="p">,</code><code class="w"> </code><code class="mi">255</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">count</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">255</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u8</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/></pre>

<p>If <code>escape_time</code> says that <code>point</code> belongs to the set, <code>render</code> colors the corresponding pixel black (<code>0</code>). Otherwise, <code>render</code> assigns darker colors to the numbers that took longer to escape the circle.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Writing Image Files"><div class="sect2" id="writing-image-files">
<h2>Writing Image Files</h2>

<p><a contenteditable="false" data-primary="image files, for Mandelbrot set" data-type="indexterm" id="C02-tour.html13"/><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="writing image files" data-type="indexterm" id="C02-tour.html14"/>The <code>image</code> crate provides functions for reading and writing a wide variety of image formats, along with some basic image manipulation functions. In particular, it includes an encoder for the PNG image file format, which this program uses to save the final results of the calculation. In order to use <code>image</code>, add the following line to the <code>[dependencies]</code> section of <em>Cargo.toml</em>:</p>

<pre data-type="programlisting">
image = "0.13.0"</pre>

<p>With that in place, we can write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">image</code><code class="p">;</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">image</code>::<code class="n">ColorType</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">image</code>::<code class="n">png</code>::<code class="n">PNGEncoder</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code><code class="p">;</code><code class="w"/>

<code class="sd">/// Write the buffer `pixels`, whose dimensions are given by `bounds`, to the</code>
<code class="sd">/// file named `filename`.</code>
<code class="k">fn</code> <code class="nf">write_image</code><code class="p">(</code><code class="n">filename</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">pixels</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">],</code><code class="w"> </code><code class="n">bounds</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">))</code><code class="w"/>
<code class="w">    </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">File</code>::<code class="n">create</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">encoder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">PNGEncoder</code>::<code class="n">new</code><code class="p">(</code><code class="n">output</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">encoder</code><code class="p">.</code><code class="n">encode</code><code class="p">(</code><code class="o">&amp;</code><code class="n">pixels</code><code class="p">,</code><code class="w"/>
<code class="w">                   </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u32</code><code class="p">,</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u32</code><code class="p">,</code><code class="w"/>
<code class="w">                   </code><code class="n">ColorType</code>::<code class="n">Gray</code><code class="p">(</code><code class="mi">8</code><code class="p">))</code><code class="o">?</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="nb">Ok</code><code class="p">(())</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The operation of this function is pretty straightforward: it opens a file and tries to write the image to it. We pass the encoder the actual pixel data from <code>pixels</code>, and its width and height from <code>bounds</code>, and then a final argument that says how to interpret the bytes in <code>pixels</code>: the value <code>ColorType::Gray(8)</code> indicates that each byte is an eight-bit grayscale value.</p>

<p>That’s all straightforward. What’s interesting about this function is how it copes when something goes wrong. If we encounter an error, we need to report that back to our caller. As we’ve mentioned before, fallible functions in Rust should return a <code>Result</code> value, which is either <code>Ok(s)</code> on success, where <code>s</code> is the successful value, or <code>Err(e)</code> on failure, where <code>e</code> is an error code. So what are <code>write_image</code>’s success and error types?</p>

<p>When all goes well, our <code>write_image</code> function has no useful value to return; it wrote everything interesting to the file. So its success type is the <em>unit</em> type <code>()</code>, so called because it has only one value, also written <code>()</code>. The unit type is akin to <code>void</code> in C and <span class="keep-together">C++.</span></p>

<p>When an error occurs, it’s because either <code>File::create</code> wasn’t able to create the file, or <code>encoder.encode</code> wasn’t able to write the image to it; the I/O operation returned an error code. The return type of <code>File::create</code> is <code>Result&lt;std::fs::File, std::io::Error&gt;</code>, while that of <code>encoder.encode</code> is <code>Result&lt;(), std::io::Error&gt;</code>, so both share the same error type, <code>std::io::Error</code>. It makes sense for our <code>write_image</code> function to do the same.</p>

<p>Consider the call to <code>File::create</code>. If that returns <code>Ok(f)</code> for a successfully opened <code>File</code> value <code>f</code>, then <code>write_image</code> can proceed to write the image data to <code>f</code>. But if <code>File::create</code> returns <code>Err(e)</code> for an error code <code>e</code>, <code>write_image</code> should immediately return <code>Err(e)</code> as its own return value. The call to <code>encoder.encode</code> must be handled similarly: failure should result in an immediate return, passing along the error code.</p>

<p>The <code>?</code> operator exists to make these checks convenient. Instead of spelling everything out, and writing:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">File</code>::<code class="n">create</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">);</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>you can use the equivalent and much more legible:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">File</code>::<code class="n">create</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/></pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It’s a common beginner’s mistake to attempt to use <code>?</code> in the <code>main</code> function. However, since <code>main</code> has no return value, this won’t work; you should use <code>Result</code>’s <code>expect</code> method instead. The <code>?</code> operator is only useful within functions that themselves return <code>Result</code>.</p>
</div>

<p>There’s another shorthand we could use here. Because return types of the form <code>Result&lt;T, std::io::Error&gt;</code> for some type <code>T</code> are so common—this is often the right type for a function that does I/O—the Rust standard library defines a shorthand for it. In the <code>std::io</code> module, we have the definitions:</p>

<pre data-code-language="rust" data-testing="ignore" data-type="programlisting">
<code class="c1">// The std::io::Error type.</code>
<code class="k">struct</code> <code class="nc">Error</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="c1">// The std::io::Result type, equivalent to the usual `Result`, but</code>
<code class="c1">// specialized to use std::io::Error as the error type.</code>
<code class="k">type</code> <code class="nb">Result</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">result</code>::<code class="nb">Result</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="w"/></pre>

<p>If we bring this definition into scope with a <code>use std::io::Result</code> declaration, we can write <code>write_image</code>’s return type more tersely as <code>Result&lt;()&gt;</code>. This is the form you will often see when reading the documentation for functions in <code>std::io</code>, <code>std::fs</code>, and elsewhere.<a contenteditable="false" data-primary="" data-startref="C02-tour.html14" data-type="indexterm" id="idm45251669912088"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html13" data-type="indexterm" id="idm45251669910792"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="A Concurrent Mandelbrot Program"><div class="sect2" id="a-concurrent-mandelbrot-program">
<h2>A Concurrent Mandelbrot Program</h2>

<p><a contenteditable="false" data-primary="concurrency/concurrent programming" data-secondary="Mandelbrot set" data-type="indexterm" id="C02-tour.html15"/><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="concurrent program for" data-type="indexterm" id="C02-tour.html16"/>Finally, all the pieces are in place, and we can show you the <code>main</code> function, where we can put concurrency to work for us. First, a nonconcurrent version for simplicity:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Write</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">args</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">collect</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">args</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">io</code>::<code class="n">stderr</code><code class="p">(),</code><code class="w"/>
<code class="w">                 </code><code class="s">"Usage: mandelbrot FILE PIXELS UPPERLEFT LOWERRIGHT"</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">io</code>::<code class="n">stderr</code><code class="p">(),</code><code class="w"/>
<code class="w">                 </code><code class="s">"Example: {} mandel.png 1000x750 -1.20,0.35 -1,0.20"</code><code class="p">,</code><code class="w"/>
<code class="w">                 </code><code class="n">args</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">process</code>::<code class="n">exit</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">bounds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pair</code><code class="p">(</code><code class="o">&amp;</code><code class="n">args</code><code class="p">[</code><code class="mi">2</code><code class="p">],</code><code class="w"> </code><code class="sc">'x'</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error parsing image dimensions"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">upper_left</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_complex</code><code class="p">(</code><code class="o">&amp;</code><code class="n">args</code><code class="p">[</code><code class="mi">3</code><code class="p">])</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error parsing upper left corner point"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">lower_right</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_complex</code><code class="p">(</code><code class="o">&amp;</code><code class="n">args</code><code class="p">[</code><code class="mi">4</code><code class="p">])</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error parsing lower right corner point"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">pixels</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="p">];</code><code class="w"/>

<code class="w">    </code><code class="n">render</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">pixels</code><code class="p">,</code><code class="w"> </code><code class="n">bounds</code><code class="p">,</code><code class="w"> </code><code class="n">upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">lower_right</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="n">write_image</code><code class="p">(</code><code class="o">&amp;</code><code class="n">args</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code><code class="w"> </code><code class="o">&amp;</code><code class="n">pixels</code><code class="p">,</code><code class="w"> </code><code class="n">bounds</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error writing PNG file"</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>After collecting the command-line arguments into a vector of <code>String</code>s, we parse each one and then begin calculations.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">pixels</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="p">];</code><code class="w"/></pre>

<p>A macro call <code>vec![v; n]</code> creates a vector <code>n</code> elements long whose elements are initialized to <code>v</code>, so the preceding code creates a vector of zeros whose length is <code>bounds.0 * bounds.1</code>, where <code>bounds</code> is the image resolution parsed from the command line. We’ll use this vector as a rectangular array of one-byte grayscale pixel values, as shown in <a data-type="xref" href="#tour-pixels-figure">Figure 2-5</a>.</p>

<figure><div id="tour-pixels-figure" class="figure"><img alt="(Using a vector as a rectangular array of pixels.            The width is bounds.0, the height bounds.1.            Elements 0 through bounds.0-1 are the top row of pixels.            Element bounds.0*bounds.1-1 is the bottom right pixel.)" src="Images/rust_0204.png"/>
<h6><span class="label">Figure 2-5. </span>Using a vector as a rectangular array of pixels</h6>
</div></figure>

<p>The next line of interest is this:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">render</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">pixels</code><code class="p">,</code><code class="w"> </code><code class="n">bounds</code><code class="p">,</code><code class="w"> </code><code class="n">upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">lower_right</code><code class="p">);</code><code class="w"/></pre>

<p>This calls the <code>render</code> function to actually compute the image. The expression <code>&amp;mut pixels</code> borrows a mutable reference to our pixel buffer, allowing <code>render</code> to fill it with computed grayscale values, even while <code>pixels</code> remains the vector’s owner. The remaining arguments pass the image’s dimensions, and the rectangle of the complex plane we’ve chosen to plot.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">write_image</code><code class="p">(</code><code class="o">&amp;</code><code class="n">args</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code><code class="w"> </code><code class="o">&amp;</code><code class="n">pixels</code><code class="p">,</code><code class="w"> </code><code class="n">bounds</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">expect</code><code class="p">(</code><code class="s">"error writing PNG file"</code><code class="p">);</code><code class="w"/></pre>

<p>Finally, we write the pixel buffer out to disk as a PNG file. In this case, we pass a shared (nonmutable) reference to the buffer, since <code>write_image</code> should have no need to modify the buffer’s contents.</p>

<p>The natural way to distribute this calculation across multiple processors is to divide the image into sections, one per processor, and let each processor color the pixels assigned to it. For simplicity, we’ll break it into horizontal bands, as shown in <a data-type="xref" href="#tour-banded-figure">Figure 2-6</a>. When all processors have finished, we can write out the pixels to disk.</p>

<figure><div id="tour-banded-figure" class="figure"><img alt="(Dividing the pixel buffer into horizontal bands. The first thread renders the top band, the second thread the band below that, and so on.)" src="Images/rust_0205.png"/>
<h6><span class="label">Figure 2-6. </span>Dividing the pixel buffer into bands for parallel rendering</h6>
</div></figure>

<p>The <code>crossbeam</code> crate provides a number of valuable concurrency facilities, including a <em>scoped thread</em> facility that does exactly what we need here. To use it, we must add the following line to our <em>Cargo.toml</em> file:</p>

<pre data-type="programlisting">
crossbeam = "0.2.8"</pre>

<p>Then, we must add the following line to the top of our <em>main.rs</em> file:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">crossbeam</code><code class="p">;</code><code class="w"/></pre>

<p>Then we need to take out the single line calling <code>render</code>, and replace it with the following:</p>

<pre data-code-language="rust" data-testing="replace-line render\(.*\);" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">threads</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">8</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">rows_per_band</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">threads</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>

<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">bands</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="k">mut</code><code class="w"> </code><code class="p">[</code><code class="kt">u8</code><code class="p">]</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">        </code><code class="n">pixels</code><code class="p">.</code><code class="n">chunks_mut</code><code class="p">(</code><code class="n">rows_per_band</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">crossbeam</code>::<code class="n">scope</code><code class="p">(</code><code class="o">|</code><code class="n">spawner</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">band</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">bands</code><code class="p">.</code><code class="n">into_iter</code><code class="p">().</code><code class="n">enumerate</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">top</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rows_per_band</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">height</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">band</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">band_bounds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">height</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">band_upper_left</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">                </code><code class="n">pixel_to_point</code><code class="p">(</code><code class="n">bounds</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">top</code><code class="p">),</code><code class="w"> </code><code class="n">upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">lower_right</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">band_lower_right</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">                </code><code class="n">pixel_to_point</code><code class="p">(</code><code class="n">bounds</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">top</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">height</code><code class="p">),</code><code class="w"/>
<code class="w">                               </code><code class="n">upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">lower_right</code><code class="p">);</code><code class="w"/>

<code class="w">            </code><code class="n">spawner</code><code class="p">.</code><code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">render</code><code class="p">(</code><code class="n">band</code><code class="p">,</code><code class="w"> </code><code class="n">band_bounds</code><code class="p">,</code><code class="w"> </code><code class="n">band_upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">band_lower_right</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="p">});</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">});</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Breaking this down in the usual way:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">threads</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">8</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">rows_per_band</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">threads</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/></pre>

<p>Here we decide to use eight threads.<sup><a data-type="noteref" id="idm45251667105816-marker" href="ch02.xhtml#idm45251667105816">1</a></sup> Then we compute how many rows of pixels each band should have. We round the row count upward, to make sure the bands cover the entire image even if the height isn’t a multiple of <code>threads</code>.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">bands</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="k">mut</code><code class="w"> </code><code class="p">[</code><code class="kt">u8</code><code class="p">]</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">pixels</code><code class="p">.</code><code class="n">chunks_mut</code><code class="p">(</code><code class="n">rows_per_band</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"/></pre>

<p>Here we divide the pixel buffer into bands. The buffer’s <code>chunks_mut</code> method returns an iterator producing mutable, nonoverlapping slices of the buffer, each of which encloses <code>rows_per_band * bounds.0</code> pixels—in other words, <code>rows_per_band</code> complete rows of pixels. The last slice that <code>chunks_mut</code> produces may contain fewer rows, but each row will contain the same number of pixels. Finally, the iterator’s <code>collect</code> method builds a vector holding these mutable, nonoverlapping slices.</p>

<p>Now we can put the <code>crossbeam</code> library to work:</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">crossbeam</code>::<code class="n">scope</code><code class="p">(</code><code class="o">|</code><code class="n">spawner</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">});</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="closures" data-secondary="defined" data-type="indexterm" id="idm45251667033032"/>The argument <code>|spawner| { ... }</code> is a Rust <em>closure</em> expression. A closure is a value that can be called as if it were a function. Here, <code>|spawner|</code> is the argument list, and <code>{ ... }</code> is the body of the function. Note that, unlike functions declared with <code>fn</code>, we don’t need to declare the types of a closure’s arguments; Rust will infer them, along with its return type.</p>

<p>In this case, <code>crossbeam::scope</code> calls the closure, passing as the <code>spawner</code> argument a value the closure can use to create new threads. The <code>crossbeam::scope</code> function waits for all such threads to finish execution before returning itself. This behavior allows Rust to be sure that such threads will not access their portions of <code>pixels</code> after it has gone out of scope, and allows us to be sure that when <code>crossbeam::scope</code> returns, the computation of the image is complete.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="n">band</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">bands</code><code class="p">.</code><code class="n">into_iter</code><code class="p">().</code><code class="n">enumerate</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/></pre>

<p>Here we iterate over the pixel buffer’s bands. The <code>into_iter()</code> iterator gives each iteration of the loop body exclusive ownership of one band, ensuring that only one thread can write to it at a time. We explain how this works in detail in <a data-type="xref" href="ch05.xhtml#references">Chapter 5</a>. Then, the <code>enumerate</code> adapter produces tuples pairing each vector element with its index.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">top</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rows_per_band</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">height</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">band</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">band_bounds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">height</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">band_upper_left</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">pixel_to_point</code><code class="p">(</code><code class="n">bounds</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">top</code><code class="p">),</code><code class="w"> </code><code class="n">upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">lower_right</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">band_lower_right</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">pixel_to_point</code><code class="p">(</code><code class="n">bounds</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">top</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">height</code><code class="p">),</code><code class="w"/>
<code class="w">                   </code><code class="n">upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">lower_right</code><code class="p">);</code><code class="w"/></pre>

<p>Given the index and the actual size of the band (recall that the last one might be shorter than the others), we can produce a bounding box of the sort <code>render</code> requires, but one that refers only to this band of the buffer, not the entire image. Similarly, we repurpose the renderer’s <code>pixel_to_point</code> function to find where the band’s upper-left and lower-right corners fall on the complex plane.</p>

<pre data-code-language="rust" data-testing="match-in-current-file" data-type="programlisting">
<code class="n">spawner</code><code class="p">.</code><code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">render</code><code class="p">(</code><code class="n">band</code><code class="p">,</code><code class="w"> </code><code class="n">band_bounds</code><code class="p">,</code><code class="w"> </code><code class="n">band_upper_left</code><code class="p">,</code><code class="w"> </code><code class="n">band_lower_right</code><code class="p">);</code><code class="w"/>
<code class="p">});</code><code class="w"/></pre>

<p>Finally, we create a thread, running the closure <code>move || { ... }</code>. This syntax is a bit strange to read: it denotes a closure of no arguments whose body is the <code>{ ... }</code> form. The <code>move</code> keyword at the front indicates that this closure takes ownership of the variables it uses; in particular, only the closure may use the mutable slice <code>band</code>.</p>

<p>As we mentioned earlier, the <code>crossbeam::scope</code> call ensures that all threads have completed before it returns, meaning that it is safe to save the image to a file, which is our next action.<a contenteditable="false" data-primary="" data-startref="C02-tour.html16" data-type="indexterm" id="idm45251666694936"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html15" data-type="indexterm" id="idm45251666693560"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Running the Mandelbrot Plotter"><div class="sect2" id="running-the-mandelbrot-plotter">
<h2>Running the Mandelbrot Plotter</h2>

<p><a contenteditable="false" data-primary="Mandelbrot set" data-secondary="running the plotter" data-type="indexterm" id="idm45251666690920"/><a contenteditable="false" data-primary="plotting" data-secondary="running the Mandelbrot plotter" data-type="indexterm" id="idm45251666689320"/>We’ve used several external crates in this program: <code>num</code> for complex number arithmetic; <code>image</code> for writing PNG files; and <code>crossbeam</code> for the scoped thread creation primitives. Here’s the final <em>Cargo.toml</em> file including all those dependencies:</p>

<pre data-testing="replace-whole-file Cargo.toml" data-type="programlisting">
[package]
name = "mandelbrot"
version = "0.1.0"
authors = ["You &lt;you@example.com&gt;"]

[dependencies]
crossbeam = "0.2.8"
image = "0.13.0"
num = "0.1.27"</pre>

<p>With that in place, we can build and run the program:</p>

<pre class="console" data-code-language="console" data-testing="ignore-nonmatching-lines" data-type="programlisting">
<code class="gp">$</code> cargo build --release
<code class="go">    Updating registry `https://github.com/rust-lang/crates.io-index`</code>
<code class="go">   Compiling bitflags v0.3.3</code>
<code class="go">   ...</code>
<code class="go">   Compiling png v0.4.3</code>
<code class="go">   Compiling image v0.13.0</code>
<code class="go">   Compiling mandelbrot v0.1.0 (file:///home/jimb/rust/mandelbrot)</code>
<code class="go">    Finished release [optimized] target(s) in 42.64 secs</code>
<code class="gp">$</code> <code class="nb">time </code>target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20
<code class="go">real    0m1.750s</code>
<code class="go">user    0m6.205s</code>
<code class="go">sys     0m0.026s</code>
<code class="gp">$</code></pre>

<p>Here, we’ve used the Unix <code>time</code> program to see how long the program took to run; note that even though we spent more than six seconds of processor time computing the image, the elapsed real time was less than two seconds. You can verify that a substantial portion of that real time is spent writing the image file by commenting out the code that does so; on the laptop where this code was tested, the concurrent version reduces the Mandelbrot calculation time proper by a factor of almost four. We’ll show how to substantially improve on this in <a data-type="xref" href="ch19.xhtml#concurrency">Chapter 19</a>.</p>

<p>This command should create a file called <em>mandel.png</em>, which you can view with your system’s image viewing program or in a web browser. If all has gone well, it should look like <a data-type="xref" href="#fig0206">Figure 2-7</a>.</p>

<figure><div id="fig0206" class="figure"><img alt="Results from parallel Mandelbrot program" src="Images/rust_0206.png" title="Results from parallel Mandelbrot program"/>
<h6><span class="label">Figure 2-7. </span>Results from parallel Mandelbrot program</h6>
</div></figure>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Safety Is Invisible"><div class="sect2" id="safety-is-invisible">
<h2>Safety Is Invisible</h2>

<p><a contenteditable="false" data-primary="safety" data-secondary="invisibility of" data-type="indexterm" id="idm45251666607048"/>In the end, the parallel program we ended up with is not substantially different from what we might write in any other language: we apportion pieces of the pixel buffer out among the processors; let each one work on its piece separately; and when they’ve all finished, present the result. So what is so special about Rust’s concurrency support?<a contenteditable="false" data-primary="" data-startref="C02-tour.html9" data-type="indexterm" id="idm45251666605176"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html8" data-type="indexterm" id="idm45251666603800"/><a contenteditable="false" data-primary="" data-startref="C02-tour.html7" data-type="indexterm" id="idm45251666602424"/></p>

<p>What we haven’t shown here is all the Rust programs we <em>cannot</em> write. The code we looked at in this chapter partitions the buffer among the threads correctly, but there are many small variations on that code that do not (and thus introduce data races); not one of those variations will pass the Rust compiler’s static checks. <a contenteditable="false" data-primary="data races" data-secondary="safety and" data-type="indexterm" id="idm45251666599928"/>A C or C++ compiler will cheerfully help you explore the vast space of programs with subtle data races; Rust tells you, up front, when something could go wrong.</p>

<p>In Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.xhtml#ownership">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.xhtml#references">5</a>, we’ll describe Rust’s rules for memory safety. <a data-type="xref" href="ch19.xhtml#concurrency">Chapter 19</a> explains how these rules also ensure proper concurrency hygiene.<a contenteditable="false" data-primary="" data-startref="C02-tour.html0" data-type="indexterm" id="idm45251666594344"/> But for those to make sense, it’s essential to get a grounding in Rust’s fundamental types, which we’ll cover in the next chapter.</p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45251667105816"><sup><a href="ch02.xhtml#idm45251667105816-marker">1</a></sup> The <code>num_cpus</code> crate provides a function that returns the number of CPUs available on the current system.</p></div></div></section></div></body>
</html>