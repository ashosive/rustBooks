<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. References"><div class="chapter" id="references">
<h1><span class="label">Chapter 5. </span>References</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>Libraries cannot provide new inabilities.</p>
<p data-type="attribution">Mark Miller</p>
</blockquote>

<p><a contenteditable="false" data-primary="references (pointer type)" data-type="indexterm" id="C05-references.html0"/>All the pointer types we’ve seen so far—the simple <code>Box&lt;T&gt;</code> heap pointer, and the pointers internal to <code>String</code> and <code>Vec</code> values—are owning pointers: when the owner is dropped, the referent goes with it. Rust also has nonowning pointer types called <em>references</em>, which have no effect on their referents’ lifetimes.</p>

<p>In fact, it’s rather the opposite: references must never outlive their referents. You must make it apparent in your code that no reference can possibly outlive the value it points to. <a contenteditable="false" data-primary="borrowing" data-secondary="defined" data-type="indexterm" id="idm45251644436616"/>To emphasize this, Rust refers to creating a reference to some value as <em>borrowing</em> the value: what you have borrowed, you must eventually return to its owner.</p>

<p>If you felt a moment of skepticism when reading the phrase “You must make it apparent in your code,” you’re in excellent company. The references themselves are nothing special—under the hood, they’re just addresses. But the rules that keep them safe are novel to Rust; outside of research languages, you won’t have seen anything like them before. And although these rules are the part of Rust that requires the most effort to master, the breadth of classic, absolutely everyday bugs they prevent is surprising, and their effect on multithreaded programming is liberating. This is Rust’s radical wager, again.</p>

<p>As an example, let’s suppose we’re going to build a table of murderous Renaissance artists and the works they’re known for. Rust’s standard library includes a hash table type, so we can define our type like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">HashMap</code><code class="p">;</code><code class="w"/>

<code class="k">type</code> <code class="nc">Table</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;&gt;</code><code class="p">;</code><code class="w"/></pre>

<p>In other words, this is a hash table that maps <code>String</code> values to <code>Vec&lt;String&gt;</code> values, taking the name of an artist to a list of the names of their works. You can iterate over the entries of a <code>HashMap</code> with a <code>for</code> loop, so we can write a function to print out a <code>Table</code> for debugging:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">show</code><code class="p">(</code><code class="n">table</code>: <code class="nc">Table</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">artist</code><code class="p">,</code><code class="w"> </code><code class="n">works</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">table</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"works by {}:"</code><code class="p">,</code><code class="w"> </code><code class="n">artist</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="n">work</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">works</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"  {}"</code><code class="p">,</code><code class="w"> </code><code class="n">work</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Constructing and printing the table is straightforward:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">table</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Table</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">table</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Gesualdo"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                 </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"many madrigals"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                      </code><code class="s">"Tenebrae Responsoria"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()]);</code><code class="w"/>
<code class="w">    </code><code class="n">table</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Caravaggio"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                 </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"The Musicians"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                      </code><code class="s">"The Calling of St. Matthew"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()]);</code><code class="w"/>
<code class="w">    </code><code class="n">table</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="s">"Cellini"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                 </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"Perseus with the head of Medusa"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">                      </code><code class="s">"a salt cellar"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()]);</code><code class="w"/>

<code class="w">    </code><code class="n">show</code><code class="p">(</code><code class="n">table</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>And it all works fine:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="gp">$</code> cargo run
<code class="go">     Running `/home/jimb/rust/book/fragments/target/debug/fragments`</code>
<code class="go">works by Gesualdo:</code>
<code class="go">  Tenebrae Responsoria</code>
<code class="go">  many madrigals</code>
<code class="go">works by Cellini:</code>
<code class="go">  Perseus with the head of Medusa</code>
<code class="go">  a salt cellar</code>
<code class="go">works by Caravaggio:</code>
<code class="go">  The Musicians</code>
<code class="go">  The Calling of St. Matthew</code>
<code class="gp">$</code></pre>

<p>But if you’ve read the previous chapter’s section on moves, this definition for <code>show</code> should raise a few questions. In particular, <code>HashMap</code> is not <code>Copy</code>—it can’t be, since it owns a dynamically allocated table. So when the program calls <code>show(table)</code>, the whole structure gets moved to the function, leaving the variable <code>table</code> uninitialized. If the calling code tries to use <code>table</code> now, it’ll run into trouble:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="p">...</code><code class="w"/>
<code class="n">show</code><code class="p">(</code><code class="n">table</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">table</code><code class="p">[</code><code class="s">"Gesualdo"</code><code class="p">][</code><code class="mi">0</code><code class="p">],</code><code class="w"> </code><code class="s">"many madrigals"</code><code class="p">);</code><code class="w"/></pre>

<p>Rust complains that <code>table</code> isn’t available anymore:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0382]: use of moved value: `table`</code>
<code class="go">  --&gt; references_show_moves_table.rs:29:16</code>
<code class="go">   |</code>
<code class="go">28 |     show(table);</code>
<code class="go">   |          ----- value moved here</code>
<code class="go">29 |     assert_eq!(table["Gesualdo"][0], "many madrigals");</code>
<code class="go">   |                ^^^^^ value used here after move</code>
<code class="go">   |</code>
<code class="go">   = note: move occurs because `table` has type `HashMap&lt;String, Vec&lt;String&gt;&gt;`,</code>
<code class="go">           which does not implement the `Copy` trait</code></pre>

<p>In fact, if we look into the definition of <code>show</code>, the outer <code>for</code> loop takes ownership of the hash table and consumes it entirely; and the inner <code>for</code> loop does the same to each of the vectors. (We saw this behavior earlier, in the “liberté, égalité, fraternité” example.) Because of move semantics, we’ve completely destroyed the entire structure simply by trying to print it out. Thanks, Rust!</p>

<p>The right way to handle this is to use references. A reference lets you access a value without affecting its ownership. <a contenteditable="false" data-primary="references (pointer type)" data-secondary="shared vs. mutable" data-type="indexterm" id="idm45251644148712"/>References come in two kinds:</p>

<ul>
<li><p><a contenteditable="false" data-primary="shared references" data-type="indexterm" id="idm45251644146584"/>A <em>shared reference</em> lets you read but not modify its referent. However, you can have as many shared references to a particular value at a time as you like. The expression <code>&amp;e</code> yields a shared reference to <code>e</code>’s value; if <code>e</code> has the type <code>T</code>, then <code>&amp;e</code> has the type <code>&amp;T</code>, pronounced “ref <code>T</code>”. Shared references are <code>Copy</code>.</p></li>
<li><p><a contenteditable="false" data-primary="mutable references (&amp;mutT)" data-type="indexterm" id="idm45251644039384"/>If you have a <em>mutable reference</em> to a value, you may both read and modify the value. However, you may not have any other references of any sort to that value active at the same time. The expression <code>&amp;mut e</code> yields a mutable reference to <code>e</code>’s value; you write its type as <code>&amp;mut T</code>, which is pronounced “ref mute <code>T</code>”. Mutable references are not <code>Copy</code>.</p></li>
</ul>

<p>You can think of the distinction between shared and mutable references as a way to enforce a <em>multiple readers or single writer</em> rule at compile time. In fact, this rule doesn’t apply only to references; it covers the borrowed value’s owner as well. As long as there are shared references to a value, not even its owner can modify it; the value is locked down. Nobody can modify <code>table</code> while <code>show</code> is working with it. Similarly, if there is a mutable reference to a value, it has exclusive access to the value; you can’t use the owner at all, until the mutable reference goes away. Keeping sharing and mutation fully separate turns out to be essential to memory safety, for reasons we’ll go into later in the chapter.</p>

<p>The printing function in our example doesn’t need to modify the table, just read its contents. So the caller should be able to pass it a shared reference to the table, as follows:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">show</code><code class="p">(</code><code class="o">&amp;</code><code class="n">table</code><code class="p">);</code><code class="w"/></pre>

<p>References are nonowning pointers, so the <code>table</code> variable remains the owner of the entire structure; <code>show</code> has just borrowed it for a bit. Naturally, we’ll need to adjust the definition of <code>show</code> to match, but you’ll have to look closely to see the difference:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">show</code><code class="p">(</code><code class="n">table</code>: <code class="kp">&amp;</code><code class="nc">Table</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">artist</code><code class="p">,</code><code class="w"> </code><code class="n">works</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">table</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"works by {}:"</code><code class="p">,</code><code class="w"> </code><code class="n">artist</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="n">work</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">works</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"  {}"</code><code class="p">,</code><code class="w"> </code><code class="n">work</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The type of <code>show</code>’s parameter <code>table</code> has changed from <code>Table</code> to <code>&amp;Table</code>: instead of passing the table by value (and hence moving ownership into the function), we’re now passing a shared reference. That’s the only textual change. But how does this play out as we work through the body?</p>

<p>Whereas our original outer <code>for</code> loop took ownership of the <code>HashMap</code> and consumed it, in our new version it receives a shared reference to the <code>HashMap</code>. Iterating over a shared reference to a <code>HashMap</code> is defined to produce shared references to each entry’s key and value: <code>artist</code> has changed from a <code>String</code> to a <code>&amp;String</code>, and <code>works</code> from a <code>Vec&lt;String&gt;</code> to a <code>&amp;Vec&lt;String&gt;</code>.</p>

<p>The inner loop is changed similarly. Iterating over a shared reference to a vector is defined to produce shared references to its elements, so <code>work</code> is now a <code>&amp;String</code>. No ownership changes hands anywhere in this function; it’s just passing around nonowning references.</p>

<p>Now, if we wanted to write a function to alphabetize the works of each artist, a shared reference doesn’t suffice, since shared references don’t permit modification. Instead, the sorting function needs to take a mutable reference to the table:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">sort_works</code><code class="p">(</code><code class="n">table</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Table</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">_artist</code><code class="p">,</code><code class="w"> </code><code class="n">works</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">table</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">works</code><code class="p">.</code><code class="n">sort</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>And we need to pass it one:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">sort_works</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">table</code><code class="p">);</code><code class="w"/></pre>

<p>This mutable borrow grants <code>sort_works</code> the ability to read and modify our structure, as required by the vectors’ <code>sort</code> method.</p>

<p><a contenteditable="false" data-primary="passing by value/by reference" data-type="indexterm" id="idm45251643808792"/><a contenteditable="false" data-primary="values" data-secondary="passing by value/by reference" data-type="indexterm" id="idm45251643848808"/>When we pass a value to a function in a way that moves ownership of the value to the function, we say that we have passed it <em>by value</em>. If we instead pass the function a reference to the value, we say that we have passed the value <em>by reference</em>. For example, we fixed our <code>show</code> function by changing it to accept the table by reference, rather than by value. Many languages draw this distinction, but it’s especially important in Rust, because it spells out how ownership is affected.</p>

<section data-type="sect1" data-pdf-bookmark="References as Values"><div class="sect1" id="references-as-values">
<h1>References as Values</h1>

<p><a contenteditable="false" data-primary="references (pointer type)" data-secondary="as values" data-type="indexterm" id="C05-references.html1"/><a contenteditable="false" data-primary="values" data-secondary="references as" data-type="indexterm" id="C05-references.html2"/>The preceding example shows a pretty typical use for references: allowing functions to access or manipulate a structure without taking ownership. But references are more flexible than that, so let’s look at some examples to get a more detailed view of what’s going on.</p>

<section data-type="sect2" data-pdf-bookmark="Rust References Versus C++ References"><div class="sect2" id="rust-references-versus-c-references">
<h2>Rust References Versus C++ References</h2>

<p><a contenteditable="false" data-primary="C++" data-secondary="reference creation in" data-type="indexterm" id="idm45251643868616"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="Rust vs. C++" data-type="indexterm" id="idm45251643867240"/>If you’re familiar with references in C++, they do have something in common with Rust references. Most importantly, they’re both just addresses at the machine level. But in practice, Rust’s references have a very different feel.</p>

<p>In C++, references are created implicitly by conversion, and dereferenced implicitly too:</p>
<pre class="cpp" data-type="programlisting" data-code-language="cpp"><code class="c1">// C++ code!</code>
<code class="kt">int</code> <code class="n">x</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>
<code class="kt">int</code> <code class="o">&amp;</code><code class="n">r</code> <code class="o">=</code> <code class="n">x</code><code class="p">;</code>             <code class="c1">// initialization creates reference implicitly</code>
<code class="n">assert</code><code class="p">(</code><code class="n">r</code> <code class="o">==</code> <code class="mi">10</code><code class="p">);</code>        <code class="c1">// implicitly dereference r to see x's value</code>
<code class="n">r</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>                 <code class="c1">// stores 20 in x, r itself still points to x</code></pre>

<p><a contenteditable="false" data-primary="* operator" data-type="indexterm" id="idm45251643857848"/><a contenteditable="false" data-primary="&amp; operator" data-type="indexterm" id="idm45251643755096"/><a contenteditable="false" data-primary="dereferencing" data-secondary="* operator" data-type="indexterm" id="idm45251643754024"/>In Rust, references are created explicitly with the <code>&amp;</code> operator, and dereferenced explicitly with the <code>*</code> operator:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="c1">// Back to Rust code from this point onward.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w">             </code><code class="c1">// &amp;x is a shared reference to x</code>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">r</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">10</code><code class="p">);</code><code class="w">      </code><code class="c1">// explicitly dereference r</code></pre>

<p><a contenteditable="false" data-primary="&amp;mut operator" data-type="indexterm" id="idm45251643646152"/>To create a mutable reference, use the <code>&amp;mut</code> operator:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">32</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w">        </code><code class="c1">// &amp;mut y is a mutable reference to y</code>
<code class="o">*</code><code class="n">m</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">32</code><code class="p">;</code><code class="w">              </code><code class="c1">// explicitly dereference m to set y's value</code>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">m</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">64</code><code class="p">);</code><code class="w">     </code><code class="c1">// and to see y's new value</code></pre>
<p>But you might recall that, when we fixed the <code>show</code> function to take the table of artists by reference instead of by value, we never had to use the <code>*</code> operator. Why is that?</p>

<p><a contenteditable="false" data-primary=". operator" data-type="indexterm" id="idm45251643614520"/>Since references are so widely used in Rust, the <code>.</code> operator implicitly dereferences its left operand, if needed:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Anime</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code>: <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">bechdel_pass</code>: <code class="kt">bool</code> <code class="p">};</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">aria</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Anime</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code>: <code class="s">"Aria: The Animation"</code><code class="p">,</code><code class="w"> </code><code class="n">bechdel_pass</code>: <code class="nc">true</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">anime_ref</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">aria</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">anime_ref</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="s">"Aria: The Animation"</code><code class="p">);</code><code class="w"/>

<code class="c1">// Equivalent to the above, but with the dereference written out:</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">((</code><code class="o">*</code><code class="n">anime_ref</code><code class="p">).</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="s">"Aria: The Animation"</code><code class="p">);</code><code class="w"/></pre>
<p>The <code>println!</code> macro used in the <code>show</code> function expands to code that uses the <code>.</code> operator, so it takes advantage of this implicit dereference as well.</p>

<p>The <code>.</code> operator can also implicitly borrow a reference to its left operand, if needed for a method call. For example, <code>Vec</code>’s <code>sort</code> method takes a mutable reference to the vector, so the two calls shown here are equivalent:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1973</code><code class="p">,</code><code class="w"> </code><code class="mi">1968</code><code class="p">];</code><code class="w"/>
<code class="n">v</code><code class="p">.</code><code class="n">sort</code><code class="p">();</code><code class="w">           </code><code class="c1">// implicitly borrows a mutable reference to v</code>
<code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="p">).</code><code class="n">sort</code><code class="p">();</code><code class="w">    </code><code class="c1">// equivalent; much uglier</code></pre>

<p>In a nutshell, whereas C++ converts implicitly between references and lvalues (that is, expressions referring to locations in memory), with these conversions appearing anywhere they’re needed, in Rust you use the <code>&amp;</code> and <code>*</code> operators to create and follow references, with the exception of the <code>.</code> operator, which borrows and dereferences implicitly.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Assigning References"><div class="sect2" id="assigning-references">
<h2>Assigning References</h2>

<p><a contenteditable="false" data-primary="assignment" data-secondary="references" data-type="indexterm" id="idm45251643396312"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="assigning" data-type="indexterm" id="idm45251643394936"/>Assigning to a Rust reference makes it point at a new value:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">20</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w"/>

<code class="k">if</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">y</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">r</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="o">*</code><code class="n">r</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">20</code><code class="p">);</code><code class="w"/></pre>

<p>The reference <code>r</code> initially points to <code>x</code>. But if <code>b</code> is true, the code points it at <code>y</code> instead, as illustrated in <a data-type="xref" href="#fig0501">Figure 5-1</a>.</p>

<figure><div id="fig0501" class="figure">
<img src="Images/rust_05in01.png" alt="a reference that has been repointed by assignment"/>
<h6><span class="label">Figure 5-1. </span>The reference r, now pointing to y instead of x</h6>
</div></figure>

<p>This is very different from C++, where assigning to a reference stores the value in its referent. There’s no way to point a C++ reference to a location other than the one it was initialized with.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="References to References"><div class="sect2" id="references-to-references">
<h2>References to References</h2>

<p><a contenteditable="false" data-primary="references (pointer type)" data-secondary="to references" data-type="indexterm" id="idm45251643341400"/>Rust permits references to references:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kt">i32</code> <code class="p">}</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">point</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">1000</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">729</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="nc">Point</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">point</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">rr</code>: <code class="kp">&amp;&amp;</code><code class="nc">Point</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">rrr</code>: <code class="kp">&amp;&amp;&amp;</code><code class="nc">Point</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">rr</code><code class="p">;</code><code class="w"/></pre>

<p>(We’ve written out the reference types for clarity, but you could omit them; there’s nothing here Rust can’t infer for itself.) The <code>.</code> operator follows as many references as it takes to find its target:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">rrr</code><code class="p">.</code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="mi">729</code><code class="p">);</code><code class="w"/></pre>

<p>In memory, the references are arranged as shown in <a data-type="xref" href="#fig0502">Figure 5-2</a>.</p>

<figure><div id="fig0502" class="figure">
<img src="Images/rust_05in02.png" alt="a reference to a reference to a reference, and the . operator"/>
<h6><span class="label">Figure 5-2. </span>A chain of references to references</h6>
</div></figure>

<p>So the expression <code>rrr.y</code>, guided by the type of <code>rrr</code>, actually traverses three references to get to the <code>Point</code> before fetching its <code>y</code> field.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Comparing References"><div class="sect2" id="comparing-references">
<h2>Comparing References</h2>

<p><a contenteditable="false" data-primary="comparison operators" data-secondary="references and" data-type="indexterm" id="idm45251643182104"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="comparing" data-type="indexterm" id="idm45251643180728"/>Like the <code>.</code> operator, Rust’s comparison operators “see through” any number of references, as long as both operands have the same type:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">rx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">ry</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">y</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">rrx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">rx</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">rry</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">ry</code><code class="p">;</code><code class="w"/>

<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">rrx</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">rry</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">rrx</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">rry</code><code class="p">);</code><code class="w"/></pre>

<p>The final assertion here succeeds, even though <code>rrx</code> and <code>rry</code> point at different values (namely, <code>rx</code> and <code>ry</code>), because the <code>==</code> operator follows all the references and performs the comparison on their final targets, <code>x</code> and <code>y</code>. This is almost always the behavior you want, especially when writing generic functions. If you actually want to know whether two references point to the same memory, you can use <code>std::ptr::eq</code>, which compares them as addresses:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">rx</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">ry</code><code class="p">);</code><code class="w">              </code><code class="c1">// their referents are equal</code>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">!</code><code class="n">std</code>::<code class="n">ptr</code>::<code class="n">eq</code><code class="p">(</code><code class="n">rx</code><code class="p">,</code><code class="w"> </code><code class="n">ry</code><code class="p">));</code><code class="w"> </code><code class="c1">// but occupy different addresses</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="References Are Never Null"><div class="sect2" id="references-are-never-null">
<h2>References Are Never Null</h2>

<p><a contenteditable="false" data-primary="null pointers" data-type="indexterm" id="idm45251643058440"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="null pointers and" data-type="indexterm" id="idm45251643049720"/>Rust references are never null. There’s no analogue to C’s <code>NULL</code> or C++’s <code>nullptr</code>; there is no default initial value for a reference (you can’t use any variable until it’s been initialized, regardless of its type); and Rust won’t convert integers to references (outside of <code>unsafe</code> code), so you can’t convert zero into a reference.</p>

<p>C and C++ code often uses a null pointer to indicate the absence of a value: for example, the <code>malloc</code> function either returns a pointer to a new block of memory, or <code>nullptr</code> if there isn’t enough memory available to satisfy the request. <a contenteditable="false" data-primary="Option&lt;&amp;T&gt;" data-type="indexterm" id="idm45251643044968"/>In Rust, if you need a value that is either a reference to something or not, use the type <code>Option&lt;&amp;T&gt;</code>. At the machine level, Rust represents <code>None</code> as a null pointer, and <code>Some(r)</code>, where <code>r</code> is a <code>&amp;T</code> value, as the nonzero address, so <code>Option&lt;&amp;T&gt;</code> is just as efficient as a nullable pointer in C or C++, even though it’s safer: its type requires you to check whether it’s <code>None</code> before you can use it.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Borrowing References to Arbitrary Expressions"><div class="sect2" id="borrowing-references-to-arbitrary-expressions">
<h2>Borrowing References to Arbitrary Expressions</h2>

<p><a contenteditable="false" data-primary="borrowing" data-secondary="arbitrary expressions and" data-type="indexterm" id="idm45251643038840"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="borrowing to arbitrary expressions" data-type="indexterm" id="idm45251643037448"/>Whereas C and C++ only let you apply the <code>&amp;</code> operator to certain kinds of expressions, Rust lets you borrow a reference to the value of any sort of expression at all:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">factorial</code><code class="p">(</code><code class="n">n</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="mi">1</code><code class="p">..</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">).</code><code class="n">fold</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">b</code><code class="o">|</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">factorial</code><code class="p">(</code><code class="mi">6</code><code class="p">);</code><code class="w"/>
<code class="c1">// Arithmetic operators can see through one level of references.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">r</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="o">&amp;</code><code class="mi">1009</code><code class="p">,</code><code class="w"> </code><code class="mi">1729</code><code class="p">);</code><code class="w"/></pre>

<p>In situations like this, Rust simply creates an anonymous variable to hold the expression’s value, and makes the reference point to that. The lifetime of this anonymous variable depends on what you do with the reference:</p>

<ul>
<li><p>If you immediately assign the reference to a variable in a <code>let</code> statement (or make it part of some struct or array that is being immediately assigned), then Rust makes the anonymous variable live as long as the variable the <code>let</code> initializes. In the preceding example, Rust would do this for the referent of <code>r</code>.</p></li>

<li><p>Otherwise, the anonymous variable lives to the end of the enclosing statement. In our example, the anonymous variable created to hold <code>1009</code> lasts only to the end of the <code>assert_eq!</code> statement.</p></li>
</ul>

<p>If you’re used to C or C++, this may sound error-prone. But remember that Rust will never let you write code that would produce a dangling reference. If the reference could ever be used beyond the anonymous variable’s lifetime, Rust will always report the problem to you at compile time. You can then fix your code to keep the referent in a named variable with an appropriate lifetime.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="References to Slices and Trait Objects"><div class="sect2" id="references-to-slices-and-trait-objects">
<h2>References to Slices and Trait Objects</h2>

<p><a contenteditable="false" data-primary="fat pointer" data-type="indexterm" id="idm45251642920936"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="to slices and trait objects" data-type="indexterm" id="idm45251642919832"/><a contenteditable="false" data-primary="slices" data-secondary="references to" data-type="indexterm" id="idm45251642918520"/><a contenteditable="false" data-primary="trait objects" data-secondary="references to" data-type="indexterm" id="idm45251642917144"/>The references we’ve shown so far are all simple addresses. However, Rust also includes two kinds of <em>fat pointers</em>, two-word values carrying the address of some value, along with some further information necessary to put the value to use.</p>

<p>A reference to a slice is a fat pointer, carrying the starting address of the slice and its length. We described slices in detail in <a data-type="xref" href="ch03.xhtml#basic-types">Chapter 3</a>.</p>

<p>Rust’s other kind of fat pointer is a <em>trait object</em>, a reference to a value that implements a certain trait. A trait object carries a value’s address and a pointer to the trait’s implementation appropriate to that value, for invoking the trait’s methods. We’ll cover trait objects in detail in <a data-type="xref" href="ch11.xhtml#trait-objects">“Trait Objects”</a>.</p>

<p>Aside from carrying this extra data, slice and trait object references behave just like the other sorts of references we’ve shown so far in this chapter: they don’t own their referents; they are not allowed to outlive their referents; they may be mutable or shared; and so on.<a contenteditable="false" data-primary="" data-startref="C05-references.html2" data-type="indexterm" id="idm45251642910600"/><a contenteditable="false" data-primary="" data-startref="C05-references.html1" data-type="indexterm" id="idm45251642909224"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Reference Safety"><div class="sect1" id="reference-safety">
<h1>Reference Safety</h1>

<p><a contenteditable="false" data-primary="references (pointer type)" data-secondary="safety" data-type="indexterm" id="C05-references.html3"/><a contenteditable="false" data-primary="safety" data-secondary="with references" data-type="indexterm" id="C05-references.html4"/>As we’ve presented them so far, references look pretty much like ordinary pointers in C or C++. But those are unsafe; how does Rust keep its references under control? Perhaps the best way to see the rules in action is to try to break them. We’ll start with the simplest example possible, and then add in interesting complications and explain how they work out.</p>

<section data-type="sect2" data-pdf-bookmark="Borrowing a Local Variable"><div class="sect2" id="borrowing-a-local-variable">
<h2>Borrowing a Local Variable</h2>

<p><a contenteditable="false" data-primary="borrowing" data-secondary="local variables and" data-type="indexterm" id="C05-references.html5"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="constraints on borrowing local variables" data-type="indexterm" id="C05-references.html6"/>Here’s a pretty obvious case. You can’t borrow a reference to a local variable and take it out of the variable’s scope:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w">  </code><code class="c1">// bad: reads memory `x` used to occupy</code>
<code class="p">}</code><code class="w"/></pre>

<p>The Rust compiler rejects this program, with a detailed error message:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error: `x` does not live long enough</code>
<code class="go">  --&gt; references_dangling.rs:8:5</code>
<code class="go">   |</code>
<code class="go">7  |         r = &amp;x;</code>
<code class="go">   |              - borrow occurs here</code>
<code class="go">8  |     }</code>
<code class="go">   |     ^ `x` dropped here while still borrowed</code>
<code class="go">9  |     assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy</code>
<code class="go">10 | }</code>
<code class="go">   | - borrowed value needs to live until here</code></pre>

<p>Rust’s complaint is that <code>x</code> lives only until the end of the inner block, whereas the reference remains alive until the end of the outer block, making it a dangling pointer, which is verboten.</p>
<p>While it’s obvious to a human reader that this program is broken, it’s worth looking at how Rust itself reached that conclusion. Even this simple example shows the logical tools Rust uses to check much more complex code.</p>

<p><a contenteditable="false" data-primary="lifetime" data-secondary="defined" data-type="indexterm" id="idm45251642804552"/>Rust tries to assign each reference type in your program a <em>lifetime</em> that meets the constraints imposed by how it is used. A lifetime is some stretch of your program for which a reference could be safe to use: a lexical block, a statement, an expression, the scope of some variable, or the like. Lifetimes are entirely figments of Rust’s compile-time imagination. At runtime, a reference is nothing but an address; its lifetime is part of its type and has no runtime representation.</p>

<p>In this example, there are three lifetimes whose relationships we need to work out. The variables <code>r</code> and <code>x</code> each have a lifetime, extending from the point at which they’re initialized until the point that they go out of scope. The third lifetime is that of a reference type: the type of the reference we borrow to <code>&amp;x</code>, and store in <code>r</code>.</p>

<p>Here’s one constraint that should seem pretty obvious: if you have a variable <code>x</code>, then a reference to <code>x</code> must not outlive <code>x</code> itself, as shown in <a data-type="xref" href="#variable-x-reference">Figure 5-3</a>.</p>

<figure><div id="variable-x-reference" class="figure"><img class="width_set_50" src="Images/rust_05in03.png" alt="permissible lifetimes for &amp;x"/>
<h6><span class="label">Figure 5-3. </span>Permissible lifetimes for &amp;x</h6>
</div></figure>

<p>Beyond the point where <code>x</code> goes out of scope, the reference would be a dangling pointer. We say that the variable’s lifetime must <em>contain</em> or <em>enclose</em> that of the reference borrowed from it.</p>

<p>Here’s another kind of constraint: if you store a reference in a variable <code>r</code>, the reference’s type must be good for the entire lifetime of the variable, from the point it is initialized to the point it goes out of scope, as shown in <a data-type="xref" href="#reference-stored-in-r">Figure 5-4</a>.</p>

<figure><div id="reference-stored-in-r" class="figure"><img class="width_set_50" src="Images/rust_05in04.png" alt="permissible lifetimes for reference stored in r"/>
<h6><span class="label">Figure 5-4. </span>Permissible lifetimes for reference stored in r</h6>
</div></figure>

<p>If the reference can’t live at least as long as the variable does, then at some point <code>r</code> will be a dangling pointer. We say that the reference’s lifetime must contain or enclose the variable’s.</p>

<p>The first kind of constraint limits how large a reference’s lifetime can be, while the second kind limits how small it can be. Rust simply tries to find a lifetime for each reference that satisfies all these constraints. In our example, however, there is no such lifetime, as shown in <a data-type="xref" href="#contradictory-constraints">Figure 5-5</a>.</p>

<figure><div id="contradictory-constraints" class="figure">
<img class="width_set_50" src="Images/rust_05in05.png" alt="a reference with contradictory constraints on its lifetime"/>
<h6><span class="label">Figure 5-5. </span>A reference with contradictory constraints on its lifetime</h6>
</div></figure>

<p>Let’s now consider a different example where things do work out. We have the same kinds of constraints: the reference’s lifetime must be contained by <code>x</code>’s, but fully enclose <code>r</code>’s. But because <code>r</code>’s lifetime is smaller now, there is a lifetime that meets the constraints, as shown in <a data-type="xref" href="#lifetime-enclosing-r">Figure 5-6</a>.</p>

<figure><div id="lifetime-enclosing-r" class="figure">
<img class="width_set_50" src="Images/rust_05in06.png" alt="a reference with a lifetime enclosing r's scope, but within x's scope"/>
<h6><span class="label">Figure 5-6. </span>A reference with a lifetime enclosing r’s scope, but within x’s scope</h6>
</div></figure>

<p>These rules apply in a natural way when you borrow a reference to some part of some larger data structure, like an element of a vector:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code><code class="w"/></pre>

<p>Since <code>v</code> owns the vector, which owns its elements, the lifetime of <code>v</code> must enclose that of the reference type of <code>&amp;v[1]</code>. Similarly, if you store a reference in some data structure, its lifetime must enclose that of the data structure. If you build a vector of references, say, all of them must have lifetimes enclosing that of the variable that owns the vector.</p>

<p>This is the essence of the process Rust uses for all code. Bringing more language features into the picture—data structures and function calls, say—introduces new sorts of constraints, but the principle remains the same: first, understand the constraints arising from the way the program uses references; then, find lifetimes that satisfy them. This is not so different from the process C and C++ programmers impose on themselves; the difference is that Rust knows the rules, and enforces them.<a contenteditable="false" data-primary="" data-startref="C05-references.html6" data-type="indexterm" id="idm45251642702152"/><a contenteditable="false" data-primary="" data-startref="C05-references.html5" data-type="indexterm" id="idm45251642700888"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Receiving References as Parameters"><div class="sect2" id="receiving-references-as-parameters">
<h2>Receiving References as Parameters</h2>

<p><a contenteditable="false" data-primary="parameters" data-secondary="receiving references as" data-type="indexterm" id="C05-references.html7"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="constraints on receiving as parameters" data-type="indexterm" id="C05-references.html8"/>When we pass a reference to a function, how does Rust make sure the function uses it safely? Suppose we have a function <code>f</code> that takes a reference and stores it in a global variable. We’ll need to make a few revisions to this, but here’s a first cut:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="c1">// This code has several problems, and doesn't compile.</code>
<code class="k">static</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">STASH</code>: <code class="kp">&amp;</code><code class="kt">i32</code><code class="p">;</code><code class="w"/>
<code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="n">p</code>: <code class="kp">&amp;</code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">STASH</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="static (value)" data-type="indexterm" id="idm45251642635192"/>Rust’s equivalent of a global variable is called a <em>static</em>: it’s a value that’s created when the program starts and  lasts until it terminates. (Like any other declaration, Rust’s module system controls where statics are visible, so they’re only “global” in their lifetime, not their visibility.) We cover statics in <a data-type="xref" href="ch08.xhtml#crates-and-modules">Chapter 8</a>, but for now we’ll just call out a few rules that the code just shown doesn’t follow:</p>

<ul>
<li><p>Every static must be initialized.</p></li>
<li><p><a contenteditable="false" data-primary="mutable statics" data-type="indexterm" id="idm45251642615704"/>Mutable statics are inherently not thread-safe (after all, any thread can access a static at any time), and even in single-threaded programs, they can fall prey to other sorts of reentrancy problems. For these reasons, you may access a mutable static only within an <code>unsafe</code> block. In this example we’re not concerned with those particular problems, so we’ll just throw in an <code>unsafe</code> block and move on.</p></li>
</ul>

<p>With those revisions made, we now have the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">static</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">STASH</code>: <code class="kp">&amp;</code><code class="kt">i32</code> <code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="mi">128</code><code class="p">;</code><code class="w"/>
<code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="n">p</code>: <code class="kp">&amp;</code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="c1">// still not good enough</code>
<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">STASH</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We’re almost done. To see the remaining problem, we need to write out a few things that Rust is helpfully letting us omit. The signature of <code>f</code> as written here is actually shorthand for the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">f</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">p</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>Here, the lifetime <code>'a</code> (pronounced “tick A”) is a <em>lifetime parameter</em> of <code>f</code>. You can read <code>&lt;'a&gt;</code> as “for any lifetime <code>'a</code>” so when we write <code>fn f&lt;'a&gt;(p: &amp;'a i32)</code>, we’re defining a function that takes a reference to an <code>i32</code> with any given lifetime <code>'a</code>.</p>

<p>Since we must allow <code>'a</code> to be any lifetime, things had better work out if it’s the smallest possible lifetime: one just enclosing the call to <code>f</code>. This assignment then becomes a point of contention:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">STASH</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="p">;</code><code class="w"/></pre>

<p>Since <code>STASH</code> lives for the program’s entire execution, the reference type it holds must have a lifetime of the same length; Rust calls this the <em><code>'static</code> lifetime</em>. But the lifetime of <code>p</code>’s reference is some <code>'a</code>, which could be anything, as long as it encloses the call to <code>f</code>. So, Rust rejects our code:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0312]: lifetime of reference outlives lifetime of borrowed content...</code>
<code class="go"> --&gt; references_static.rs:6:17</code>
<code class="go">  |</code>
<code class="go">6 |         STASH = p;</code>
<code class="go">  |                 ^</code>
<code class="go">  |</code>
<code class="go">  = note: ...the reference is valid for the static lifetime...</code>
<code class="go">note: ...but the borrowed content is only valid for the anonymous lifetime #1</code>
<code class="go">      defined on the function body at 4:0</code>
<code class="go"> --&gt; references_static.rs:4:1</code>
<code class="go">  |</code>
<code class="go">4 | / fn f(p: &amp;i32) { // still not good enough</code>
<code class="go">5 | |     unsafe {</code>
<code class="go">6 | |         STASH = p;</code>
<code class="go">7 | |     }</code>
<code class="go">8 | | }</code>
<code class="go">  | |_^</code></pre>

<p>At this point, it’s clear that our function can’t accept just any reference as an argument. But it ought to be able to accept a reference that has a <code>'static</code> lifetime: storing such a reference in <code>STASH</code> can’t create a dangling pointer. And indeed, the following code compiles just fine:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">static</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">STASH</code>: <code class="kp">&amp;</code><code class="kt">i32</code> <code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="mi">10</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="n">p</code>: <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">STASH</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This time, <code>f</code>’s signature spells out that <code>p</code> must be a reference with lifetime <code>'static</code>, so there’s no longer any problem storing that in <code>STASH</code>. We can only apply <code>f</code> to references to other statics, but that’s the only thing that’s certain not to leave <code>STASH</code> dangling anyway. So we can write:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">static</code><code class="w"> </code><code class="n">WORTH_POINTING_AT</code>: <code class="kt">i32</code> <code class="o">=</code><code class="w"> </code><code class="mi">1000</code><code class="p">;</code><code class="w"/>
<code class="n">f</code><code class="p">(</code><code class="o">&amp;</code><code class="n">WORTH_POINTING_AT</code><code class="p">);</code><code class="w"/></pre>

<p>Since <code>WORTH_POINTING_AT</code> is a static, the type of <code>&amp;WORTH_POINTING_AT</code> is <code>&amp;'static i32</code>, which is safe to pass to <code>f</code>.</p>

<p>Take a step back, though, and notice what happened to <code>f</code>’s signature as we amended our way to correctness: the original <code>f(p: &amp;i32)</code> ended up as <code>f(p: &amp;'static i32)</code>. In other words, we were unable to write a function that stashed a reference in a global variable without reflecting that intention in the function’s signature. In Rust, a function’s signature always exposes the body’s behavior.</p>

<p>Conversely, if we do see a function with a signature like <code>g(p: &amp;i32)</code> (or with the lifetimes written out, <code>g&lt;'a&gt;(p: &amp;'a i32)</code>), we can tell that it <em>does not</em> stash its argument <code>p</code> anywhere that will outlive the call. There’s no need to look into <code>g</code>’s definition; the signature alone tells us what <code>g</code> can and can’t do with its argument. This fact ends up being very useful when you’re trying to establish the safety of a call to the function.<a contenteditable="false" data-primary="" data-startref="C05-references.html8" data-type="indexterm" id="idm45251642341352"/><a contenteditable="false" data-primary="" data-startref="C05-references.html7" data-type="indexterm" id="idm45251642339976"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Passing References as Arguments"><div class="sect2" id="passing-references-as-arguments">
<h2>Passing References as Arguments</h2>

<p><a contenteditable="false" data-primary="arguments" data-secondary="passing references as" data-type="indexterm" id="idm45251642337464"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="constraints on passing references as arguments" data-type="indexterm" id="idm45251642336088"/>Now that we’ve shown how a function’s signature relates to its body, let’s examine how it relates to the function’s callers. Suppose you have the following code:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="c1">// This could be written more briefly: fn g(p: &amp;i32),</code>
<code class="c1">// but let's write out the lifetimes for now.</code>
<code class="k">fn</code> <code class="nf">g</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">p</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="n">g</code><code class="p">(</code><code class="o">&amp;</code><code class="n">x</code><code class="p">);</code><code class="w"/></pre>

<p>From <code>g</code>’s signature alone, Rust knows it will not save <code>p</code> anywhere that might outlive the call: any lifetime that encloses the call must work for <code>'a</code>. So Rust chooses the smallest possible lifetime for <code>&amp;x</code>: that of the call to <code>g</code>. This meets all constraints: it doesn’t outlive <code>x</code>, and encloses the entire call to <code>g</code>. So this code passes muster.</p>

<p>Note that although <code>g</code> takes a lifetime parameter <code>'a</code>, we didn’t need to mention it when calling <code>g</code>. You only need to worry about lifetime parameters when defining functions and types; when using them, Rust infers the lifetimes for you.</p>
<p>What if we tried to pass <code>&amp;x</code> to our function <code>f</code> from earlier that stores its argument in a static?</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="n">p</code>: <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="n">f</code><code class="p">(</code><code class="o">&amp;</code><code class="n">x</code><code class="p">);</code><code class="w"/></pre>

<p>This fails to compile: the reference <code>&amp;x</code> must not outlive <code>x</code>, but by passing it to <code>f</code>, we constrain it to live at least as long as <code>'static</code>. There’s no way to satisfy everyone here, so Rust rejects the code.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Returning References"><div class="sect2" id="returning-references">
<h2>Returning References</h2>

<p><a contenteditable="false" data-primary="references (pointer type)" data-secondary="constraints on returning" data-type="indexterm" id="idm45251642227864"/>It’s common for a function to take a reference to some data structure, and then return a reference into some part of that structure. For example, here’s a function that returns a reference to the smallest element of a slice:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="c1">// v should have at least one element.</code>
<code class="k">fn</code> <code class="nf">smallest</code><code class="p">(</code><code class="n">v</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">i32</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="kt">i32</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">[</code><code class="mi">1</code><code class="p">..]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="o">*</code><code class="n">r</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="o">*</code><code class="n">s</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">s</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We’ve omitted lifetimes from that function’s signature in the usual way. When a function takes a single reference as an argument, and returns a single reference, Rust assumes that the two must have the same lifetime. Writing this out explicitly would give us:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">smallest</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">v</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="p">[</code><code class="kt">i32</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>Suppose we call <code>smallest</code> like this:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="p">;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">parabola</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">smallest</code><code class="p">(</code><code class="o">&amp;</code><code class="n">parabola</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"> </code><code class="c1">// bad: points to element of dropped array</code></pre>

<p>From <code>smallest</code>’s signature, we can see that its argument and return value must have the same lifetime, <code>'a</code>. In our call, the argument <code>&amp;parabola</code> must not outlive <code>parabola</code> itself; yet <code>smallest</code>’s return value must live at least as long as <code>s</code>. There’s no possible lifetime <code>'a</code> that can satisfy both constraints, so Rust rejects the code:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error: `parabola` does not live long enough</code>
<code class="go">  --&gt; references_lifetimes_propagated.rs:12:5</code>
<code class="go">   |</code>
<code class="go">11 |         s = smallest(&amp;parabola);</code>
<code class="go">   |                       -------- borrow occurs here</code>
<code class="go">12 |     }</code>
<code class="go">   |     ^ `parabola` dropped here while still borrowed</code>
<code class="go">13 |     assert_eq!(*s, 0); // bad: points to element of dropped array</code>
<code class="go">14 | }</code>
<code class="go">   | - borrowed value needs to live until here</code></pre>
<p>Moving <code>s</code> so that its lifetime is clearly contained within <code>parabola</code>’s fixes the problem:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">parabola</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">smallest</code><code class="p">(</code><code class="o">&amp;</code><code class="n">parabola</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"> </code><code class="c1">// fine: parabola still alive</code>
<code class="p">}</code><code class="w"/></pre>

<p>Lifetimes in function signatures let Rust assess the relationships between the references you pass to the function and those the function returns, and ensure they’re being used safely.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Structs Containing References"><div class="sect2" id="structs-containing-references">
<h2>Structs Containing References</h2>

<p><a contenteditable="false" data-primary="references (pointer type)" data-secondary="constraints on structs containing" data-type="indexterm" id="C05-references.html9"/><a contenteditable="false" data-primary="structs" data-secondary="references in" data-type="indexterm" id="C05-references.html10"/>How does Rust handle references stored in data structures? Here’s the same erroneous program we looked at earlier, except that we’ve put the reference inside a structure:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="c1">// This does not compile.</code>
<code class="k">struct</code> <code class="nc">S</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="kt">i32</code>
<code class="p">}</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="p">;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">S</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="nc">x</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">s</code><code class="p">.</code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">);</code><code class="w"> </code><code class="c1">// bad: reads from dropped `x`</code></pre>

<p>The safety constraints Rust places on references can’t magically disappear just because we hid the reference inside a struct. Somehow, those constraints must end up applying to <code>S</code> as well. Indeed, Rust is skeptical:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0106]: missing lifetime specifier</code>
<code class="go"> --&gt; references_in_struct.rs:7:12</code>
<code class="go">  |</code>
<code class="go">7 |         r: &amp;i32</code>
<code class="go">  |            ^ expected lifetime parameter</code></pre>

<p>Whenever a reference type appears inside another type’s definition, you must write out its lifetime. You can write this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">S</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">i32</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This says that <code>r</code> can only refer to <code>i32</code> values that will last for the lifetime of the program, which is rather limiting. The alternative is to give the type a lifetime parameter <code>'a</code>, and use that for <code>r</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">S</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Now the <code>S</code> type has a lifetime, just as reference types do. Each value you create of type <code>S</code> gets a fresh lifetime <code>'a</code>, which becomes constrained by how you use the value. The lifetime of any reference you store in <code>r</code> had better enclose <code>'a</code>, and <code>'a</code> must outlast the lifetime of wherever you store the <code>S</code>.</p>

<p>Turning back to the preceding code, the expression <code>S { r: &amp;x }</code> creates a fresh <code>S</code> value with some lifetime <code>'a</code>. When you store <code>&amp;x</code> in the <code>r</code> field, you constrain <code>'a</code> to lie entirely within <code>x</code>’s lifetime.</p>

<p>The assignment <code>s = S { ... }</code> stores this <code>S</code> in a variable whose lifetime extends to the end of the example, constraining <code>'a</code> to outlast the lifetime of <code>s</code>. And now Rust has arrived at the same contradictory constraints as before: <code>'a</code> must not outlive <code>x</code>, yet must live at least as long as <code>s</code>. No satisfactory lifetime exists, and Rust rejects the code. Disaster averted!</p>

<p>How does a type with a lifetime parameter behave when placed inside some other type?</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">s</code>: <code class="nc">S</code><code class="w">  </code><code class="c1">// not adequate</code>
<code class="p">}</code><code class="w"/></pre>

<p>Rust is skeptical, just as it was when we tried placing a reference in <code>S</code> without specifying its lifetime:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0106]: missing lifetime specifier</code>
<code class="go"> --&gt; references_in_nested_struct.rs:8:8</code>
<code class="go">  |</code>
<code class="go">8 |     s: S  // not adequate</code>
<code class="go">  |        ^ expected lifetime parameter</code></pre>

<p>We can’t leave off <code>S</code>’s lifetime parameter here: Rust needs to know how a <code>T</code>’s lifetime relates to that of the reference in its <code>S</code>, in order to apply the same checks to <code>T</code> that it does for <code>S</code> and plain references.</p>

<p>We could give <code>s</code> the <code>'static</code> lifetime. This works:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">s</code>: <code class="nc">S</code><code class="o">&lt;</code><code class="nb">'static</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>With this definition, the <code>s</code> field may only borrow values that live for the entire execution of the program. That’s somewhat restrictive, but it does mean that a <code>T</code> can’t possibly borrow a local variable; there are no special constraints on a <code>T</code>’s lifetime.</p>

<p>The other approach would be to give <code>T</code> its own lifetime parameter, and pass that to <code>S</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">T</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">s</code>: <code class="nc">S</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>By taking a lifetime parameter <code>'a</code> and using it in <code>s</code>’s type, we’ve allowed Rust to relate a <code>T</code> value’s lifetime to that of the reference its <code>S</code> holds.</p>

<p>We showed earlier how a function’s signature exposes what it does with the references we pass it. Now we’ve shown something similar about types: a type’s lifetime parameters always reveal whether it contains references with interesting (that is, non-<code>'static</code>) lifetimes, and what those lifetimes can be.</p>

<p>For example, suppose we have a parsing function that takes a slice of bytes, and returns a structure holding the results of the parse:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">parse_record</code><code class="o">&lt;</code><code class="na">'i</code><code class="o">&gt;</code><code class="p">(</code><code class="n">input</code>: <code class="kp">&amp;</code><code class="na">'i</code><code class="w"> </code><code class="p">[</code><code class="kt">u8</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nc">Record</code><code class="o">&lt;</code><code class="na">'i</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>Without looking into the definition of the <code>Record</code> type at all, we can tell that, if we receive a <code>Record</code> from <code>parse_record</code>, whatever references it contains must point into the input buffer we passed in, and nowhere else (except perhaps at <code>'static</code> values).</p>

<p>In fact, this exposure of internal behavior is the reason Rust requires types that contain references to take explicit lifetime parameters. There’s no reason Rust couldn’t simply make up a distinct lifetime for each reference in the struct, and save you the trouble of writing them out. Early versions of Rust actually behaved this way, but developers found it confusing: it is helpful to know when one value borrows something from another value, especially when working through errors.</p>

<p>It’s not just references and types like <code>S</code> that have lifetimes. Every type in Rust has a lifetime, including <code>i32</code> and <code>String</code>. Most are simply <code>'static</code>, meaning that values of those types can live for as long as you like; for example, a <code>Vec&lt;i32&gt;</code> is self-contained, and needn’t be dropped before any particular variable goes out of scope. But a type like <code>Vec&lt;&amp;'a i32&gt;</code> has a lifetime that must be enclosed by <code>'a</code>: it must be dropped while its referents are still alive.<a contenteditable="false" data-primary="" data-startref="C05-references.html10" data-type="indexterm" id="idm45251641407176"/><a contenteditable="false" data-primary="" data-startref="C05-references.html9" data-type="indexterm" id="idm45251641406024"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Distinct Lifetime Parameters"><div class="sect2" id="distinct-lifetime-parameters">
<h2>Distinct Lifetime Parameters</h2>

<p><a contenteditable="false" data-primary="lifetime" data-secondary="distinct parameters for references" data-type="indexterm" id="idm45251641403336"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="need for distinct lifetime parameters" data-type="indexterm" id="idm45251641401992"/>Suppose you’ve defined a structure containing two references like this:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">S</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">x</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Both references use the same lifetime <code>'a</code>. This could be a problem if your code wants to do something like this:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">20</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">S</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="kp">&amp;</code><code class="nc">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="nc">y</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">        </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This code doesn’t create any dangling pointers. The reference to <code>y</code> stays in <code>s</code>, which goes out of scope before <code>y</code> does. The reference to <code>x</code> ends up in <code>r</code>, which doesn’t <span class="keep-together">outlive <code>x</code></span>.</p>

<p>If you try to compile this, however, Rust will complain that <code>y</code> does not live long enough, even though it clearly does. Why is Rust worried? If you work through the code carefully, you can follow its reasoning:</p>

<ul>
<li><p>Both fields of <code>S</code> are references with the same lifetime <code>'a</code>, so Rust must find a single lifetime that works for both <code>s.x</code> and <code>s.y</code>.</p></li>
<li><p>We assign <code>r = s.x</code>, requiring <code>'a</code> to enclose <code>r</code>’s lifetime.</p></li>
<li><p>We initialized <code>s.y</code> with <code>&amp;y</code>, requiring <code>'a</code> to be no longer than <code>y</code>’s lifetime.</p></li>
</ul>

<p>These constraints are impossible to satisfy: no lifetime is shorter than <code>y</code>’s scope, but longer than <code>r</code>’s. Rust balks.</p>

<p>The problem arises because both references in <code>S</code> have the same lifetime <code>'a</code>. Changing the definition of <code>S</code> to let each reference have a distinct lifetime fixes everything:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">S</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="na">'b</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">x</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="na">'b</code><code class="w"> </code><code class="kt">i32</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>With this definition, <code>s.x</code> and <code>s.y</code> have independent lifetimes. What we do with <code>s.x</code> has no effect on what we store in <code>s.y</code>, so it’s easy to satisfy the constraints now: <code>'a</code> can simply be <code>r</code>’s lifetime, and <code>'b</code> can be <code>s</code>’s. (<code>y</code>’s lifetime would work too for <code>'b</code>, but Rust tries to choose the smallest lifetime that works.) Everything ends up fine.</p>

<p>Function signatures can have similar effects. Suppose we have a function like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">f</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">r</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">s</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// perhaps too tight</code></pre>

<p>Here, both reference parameters use the same lifetime <code>'a</code>, which can unnecessarily constrain the caller in the same way we’ve shown previously. If this is a problem, you can let parameters’ lifetimes vary independently:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">f</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="na">'b</code><code class="o">&gt;</code><code class="p">(</code><code class="n">r</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">s</code>: <code class="kp">&amp;</code><code class="na">'b</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// looser</code></pre>

<p>The downside to this is that adding lifetimes can make types and function signatures harder to read. Your authors tend to try the simplest possible definition first, and then loosen restrictions until the code compiles. Since Rust won’t permit the code to run unless it’s safe, simply waiting to be told when there’s a problem is a perfectly acceptable tactic.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Omitting Lifetime Parameters"><div class="sect2" id="omitting-lifetime-parameters">
<h2>Omitting Lifetime Parameters</h2>

<p><a contenteditable="false" data-primary="lifetime" data-secondary="omitting parameters from references" data-type="indexterm" id="C05-references.html11"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="omitting lifetime parameters from" data-type="indexterm" id="C05-references.html12"/>We’ve shown plenty of functions so far in this book that return references or take them as parameters, but we’ve usually not needed to spell out which lifetime is which. The lifetimes are there; Rust is just letting us omit them when it’s reasonably obvious what they should be.</p>

<p>In the simplest cases, you may never need to write out lifetimes for your parameters. Rust just assigns a distinct lifetime to each spot that needs one. For example:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">S</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="na">'b</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">x</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="na">'b</code><code class="w"> </code><code class="kt">i32</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">sum_r_xy</code><code class="p">(</code><code class="n">r</code>: <code class="kp">&amp;</code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">s</code>: <code class="nc">S</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">r</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">y</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function’s signature is shorthand for:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">sum_r_xy</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="na">'b</code><code class="p">,</code><code class="w"> </code><code class="na">'c</code><code class="o">&gt;</code><code class="p">(</code><code class="n">r</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">s</code>: <code class="nc">S</code><code class="o">&lt;</code><code class="na">'b</code><code class="p">,</code><code class="w"> </code><code class="na">'c</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code></pre>

<p>If you do return references or other types with lifetime parameters, Rust still tries to make the unambiguous cases easy. If there’s only a single lifetime that appears among your function’s parameters, then Rust assumes any lifetimes in your return value must be that one:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">first_third</code><code class="p">(</code><code class="n">point</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">i32</code><code class="p">;</code><code class="w"> </code><code class="mi">3</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="o">&amp;</code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">(</code><code class="o">&amp;</code><code class="n">point</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code><code class="w"> </code><code class="o">&amp;</code><code class="n">point</code><code class="p">[</code><code class="mi">2</code><code class="p">])</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>With all the lifetimes written out, the equivalent would be:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">first_third</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">point</code>: <code class="kp">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="p">[</code><code class="kt">i32</code><code class="p">;</code><code class="w"> </code><code class="mi">3</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"/></pre>

<p>If there are multiple lifetimes among your parameters, then there’s no natural reason to prefer one over the other for the return value, and Rust makes you spell out what’s going on.</p>

<p>But as one final shorthand, if your function is a method on some type and takes its <code>self</code> parameter by reference, then that breaks the tie: Rust assumes that <code>self</code>’s lifetime is the one to give everything in your return value. (A <code>self</code> parameter refers to the value the method is being called on, Rust’s equivalent of <code>this</code> in C++, Java, or JavaScript, or <code>self</code> in Python. We’ll cover methods in <a data-type="xref" href="ch09.xhtml#defining-methods-with-impl">“Defining Methods with impl”</a>.)</p>

<p>For example, you can write the following:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">StringTable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">elements</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">StringTable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">find_by_prefix</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">prefix</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">elements</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">elements</code><code class="p">[</code><code class="n">i</code><code class="p">].</code><code class="n">starts_with</code><code class="p">(</code><code class="n">prefix</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">.</code><code class="n">elements</code><code class="p">[</code><code class="n">i</code><code class="p">]);</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>find_by_prefix</code> method’s signature is shorthand for:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">find_by_prefix</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="na">'b</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">prefix</code>: <code class="kp">&amp;</code><code class="na">'b</code><code class="w"> </code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="na">'a</code><code class="w"> </code><code class="nb">String</code><code class="o">&gt;</code><code class="w"/></pre>

<p>Rust assumes that whatever you’re borrowing, you’re borrowing from <code>self</code>.</p>

<p>Again, these are just abbreviations, meant to be helpful without introducing surprises. When they’re not what you want, you can always write the lifetimes out <span class="keep-together">explicitly</span><a contenteditable="false" data-primary="" data-startref="C05-references.html12" data-type="indexterm" id="idm45251640627032"/><a contenteditable="false" data-primary="" data-startref="C05-references.html11" data-type="indexterm" id="idm45251640625656"/>.<a contenteditable="false" data-primary="" data-startref="C05-references.html4" data-type="indexterm" id="idm45251640610744"/><a contenteditable="false" data-primary="" data-startref="C05-references.html3" data-type="indexterm" id="idm45251640609448"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Sharing Versus Mutation"><div class="sect1" id="sharing-versus-mutation">
<h1>Sharing Versus Mutation</h1>

<p><a contenteditable="false" data-primary="mutable references (&amp;mutT)" data-secondary="shared references vs." data-type="indexterm" id="C05-references.html13"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="shared vs. mutable" data-type="indexterm" id="C05-references.html14"/><a contenteditable="false" data-primary="shared references" data-secondary="mutable references vs." data-type="indexterm" id="C05-references.html15"/>So far, we’ve discussed how Rust ensures no reference will ever point to a variable that has gone out of scope. But there are other ways to introduce dangling pointers. Here’s an easy case:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">19</code><code class="p">,</code><code class="w"> </code><code class="mi">27</code><code class="p">,</code><code class="w"> </code><code class="mi">34</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">aside</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">v</code><code class="p">;</code><code class="w">  </code><code class="c1">// move vector to aside</code>
<code class="n">r</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w">           </code><code class="c1">// bad: uses `v`, which is now uninitialized</code></pre>

<p>The assignment to <code>aside</code> moves the vector, leaving <code>v</code> uninitialized, turning <code>r</code> into a dangling pointer,
as shown in <a data-type="xref" href="#fig0507">Figure 5-7</a>.</p>

<figure><div id="fig0507" class="figure">
<img src="Images/rust_05in07.png" alt="a reference pointing to a vector that has been moved"/>
<h6><span class="label">Figure 5-7. </span>A reference to a vector that has been moved away</h6>
</div></figure>

<p class="pagebreak-after">Although <code>v</code> stays in scope for <code>r</code>’s entire lifetime, the problem here is that <code>v</code>’s value gets moved elsewhere, leaving <code>v</code> uninitialized while <code>r</code> still refers to it. Naturally, Rust catches the error:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0505]: cannot move out of `v` because it is borrowed</code>
<code class="go">  --&gt; references_sharing_vs_mutation_1.rs:10:9</code>
<code class="go">   |</code>
<code class="go">9  |     let r = &amp;v;</code>
<code class="go">   |              - borrow of `v` occurs here</code>
<code class="go">10 |     let aside = v;  // move vector to aside</code>
<code class="go">   |         ^^^^^ move out of `v` occurs here</code></pre>

<p>Throughout its lifetime, a shared reference makes its referent read-only: you may not assign to the referent or move its value elsewhere. In this code, <code>r</code>’s lifetime contains the attempt to move the vector, so Rust rejects the program. If you change the program as shown here, there’s no problem:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">19</code><code class="p">,</code><code class="w"> </code><code class="mi">27</code><code class="p">,</code><code class="w"> </code><code class="mi">34</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">];</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">r</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w">       </code><code class="c1">// ok: vector is still there</code>
<code class="p">}</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">aside</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">v</code><code class="p">;</code><code class="w"/></pre>

<p>In this version, <code>r</code> goes out of scope earlier, the reference’s lifetime ends before <code>v</code> is moved aside, and all is well.</p>

<p>Here’s a different way to wreak havoc. Suppose we have a handy function to extend a vector with the elements of a slice:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">extend</code><code class="p">(</code><code class="n">vec</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">slice</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">f64</code><code class="p">])</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">elt</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">slice</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">vec</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="o">*</code><code class="n">elt</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is a less flexible (and much less optimized) version of the standard library’s <code>extend_from_slice</code> method on vectors. We can use it to build up a vector from slices of other vectors or arrays:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">wave</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">head</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">tail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">1.0</code><code class="p">];</code><code class="w"/>

<code class="n">extend</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">wave</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">head</code><code class="p">);</code><code class="w">   </code><code class="c1">// extend wave with another vector</code>
<code class="n">extend</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">wave</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">tail</code><code class="p">);</code><code class="w">   </code><code class="c1">// extend wave with an array</code>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">wave</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">1.0</code><code class="p">]);</code><code class="w"/></pre>

<p>So we’ve built up one period of a sine wave here. If we want to add another undulation, can we append the vector to itself?</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">extend</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">wave</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">wave</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">wave</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">1.0</code><code class="p">,</code><code class="w"/>
<code class="w">                      </code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">1.0</code><code class="p">]);</code><code class="w"/></pre>

<p>This may look fine on casual inspection. But remember that when we add an element to a vector, if its buffer is full, it must allocate a new buffer with more space. Suppose <code>wave</code> starts with space for four elements, and so must allocate a larger buffer when <code>extend</code> tries to add a fifth. Memory ends up looking like <a data-type="xref" href="#fig0508">Figure 5-8</a>.</p>

<figure><div id="fig0508" class="figure">
<img src="Images/rust_05in08.png" alt="extending a vector with a slice of itself"/>
<h6><span class="label">Figure 5-8. </span>A slice turned into a dangling pointer by a vector reallocation</h6>
</div></figure>

<p>The <code>extend</code> function’s <code>vec</code> argument borrows <code>wave</code> (owned by the caller), which has allocated itself a new buffer with space for eight elements. But <code>slice</code> continues to point to the old four-element buffer, which has been dropped.</p>

<p>This sort of problem isn’t unique to Rust: modifying collections while pointing into them is delicate territory in many languages. In C++, the <code>std::vector</code> specification cautions you that “reallocation [of the vector’s buffer] invalidates all the references, pointers, and iterators referring to the elements in the sequence.” Similarly, Java says, of modifying a <code>java.util.Hashtable</code> object:</p>

<blockquote>
<p>[I]f the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove method, the iterator will throw a ConcurrentModificationException.</p>
</blockquote>

<p>What’s especially difficult about this sort of bug is that it doesn’t happen all the time. In testing, your vector might always happen to have enough space, the buffer might never be reallocated, and the problem might never come to light.</p>

<p class="pagebreak-before">Rust, however, reports the problem with our call to <code>extend</code> at compile time:</p>

<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0502]: cannot borrow `wave` as immutable because it is also borrowed as mutable</code>
<code class="go"> --&gt; references_sharing_vs_mutation_2.rs:9:24</code>
<code class="go">  |</code>
<code class="go">9 |     extend(&amp;mut wave, &amp;wave);</code>
<code class="go">  |                 ----   ^^^^- mutable borrow ends here</code>
<code class="go">  |                 |      |</code>
<code class="go">  |                 |      immutable borrow occurs here</code>
<code class="go">  |                 mutable borrow occurs here</code></pre>

<p>In other words, we may borrow a mutable reference to the vector, and we may borrow a shared reference to its elements, but those two references’ lifetimes may not overlap. In our case, both references’ lifetimes contain the call to <code>extend</code>, so Rust rejects the code.</p>

<p>These errors both stem from violations of Rust’s rules for mutation and sharing:</p>

<ul>
<li><p><a contenteditable="false" data-primary="read-only access, shared access as" data-type="indexterm" id="idm45251640018264"/><a contenteditable="false" data-primary="shared access" data-type="indexterm" id="idm45251640017192"/><a contenteditable="false" data-primary="shared references" data-secondary="rules for" data-type="indexterm" id="idm45251640131560"/><em>Shared access is read-only access.</em> Values borrowed by shared references are read-only. Across the lifetime of a shared reference, neither its referent, nor anything reachable from that referent, can be changed <em>by anything</em>. There exist no live mutable references to anything in that structure; its owner is held read-only; and so on. It’s really frozen.</p></li>

<li><p><a contenteditable="false" data-primary="mutable references (&amp;mutT)" data-secondary="rules for" data-type="indexterm" id="idm45251640128664"/><em>Mutable access is exclusive access.</em> A value borrowed by a mutable reference is reachable exclusively via that reference. Across the lifetime of a mutable reference, there is no other usable path to its referent, or to any value reachable from there. The only references whose lifetimes may overlap with a mutable reference are those you borrow from the mutable reference itself.</p></li>
</ul>

<p>Rust reported the <code>extend</code> example as a violation of the second rule: since we’ve borrowed a mutable reference to <code>wave</code>, that mutable reference must be the only way to reach the vector or its elements. The shared reference to the slice is itself another way to reach the elements, violating the second rule.</p>

<p>But Rust could also have treated our bug as a violation of the first rule: since we’ve borrowed a shared reference to <code>wave</code>’s elements, the elements and the <code>Vec</code> itself are all read-only. You can’t borrow a mutable reference to a read-only value.</p>

<p>Each kind of reference affects what we can do with the values along the owning path to the referent, and the values reachable from the referent (<a data-type="xref" href="#fig0509">Figure 5-9</a>).</p>

<figure><div id="fig0509" class="figure">
<img src="Images/rust_05in09.png" alt="effects of borrowing on values in an ownership tree"/>
<h6><span class="label">Figure 5-9. </span>Borrowing a reference affects what you can do with other values in the same ownership tree</h6>
</div></figure>

<p>Note that in both cases, the path of ownership leading to the referent cannot be changed for the reference’s lifetime. For a shared borrow, the path is read-only; for a mutable borrow, it’s completely inaccessible. So there’s no way for the program to do anything that will invalidate the reference.</p>

<p>Paring these principles down to the simplest possible examples:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w">     </code><code class="c1">// ok: multiple shared borrows permitted</code>
<code class="n">x</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w">         </code><code class="c1">// error: cannot assign to `x` because it is borrowed</code>
<code class="kd">let</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w">  </code><code class="c1">// error: cannot borrow `x` as mutable because it is</code>
<code class="w">                 </code><code class="c1">// also borrowed as immutable</code>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">20</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">m1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">m2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w">  </code><code class="c1">// error: cannot borrow as mutable more than once</code>
<code class="kd">let</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w">        </code><code class="c1">// error: cannot use `y` because it was mutably borrowed</code></pre>

<p>It is OK to reborrow a shared reference from a shared reference:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">w</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">107</code><code class="p">,</code><code class="w"> </code><code class="mi">109</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">w</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r0</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">r</code><code class="p">.</code><code class="mi">0</code><code class="p">;</code><code class="w">         </code><code class="c1">// ok: reborrowing shared as shared</code>
<code class="kd">let</code><code class="w"> </code><code class="n">m1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="mi">1</code><code class="p">;</code><code class="w">     </code><code class="c1">// error: can't reborrow shared as mutable</code></pre>

<p>You can reborrow from a mutable reference:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">136</code><code class="p">,</code><code class="w"> </code><code class="mi">139</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">m0</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="mi">0</code><code class="p">;</code><code class="w">      </code><code class="c1">// ok: reborrowing mutable from mutable</code>
<code class="o">*</code><code class="n">m0</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">137</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">r1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">m</code><code class="p">.</code><code class="mi">1</code><code class="p">;</code><code class="w">          </code><code class="c1">// ok: reborrowing shared from mutable,</code>
<code class="w">                        </code><code class="c1">// and doesn't overlap with m0</code>
<code class="n">v</code><code class="p">.</code><code class="mi">1</code><code class="p">;</code><code class="w">                    </code><code class="c1">// error: access through other paths still forbidden</code></pre>

<p>These restrictions are pretty tight. Turning back to our attempted call <code>extend(&amp;mut wave, &amp;wave)</code>, there’s no quick and easy way to fix up the code to work the way we’d like. And Rust applies these rules everywhere: if we borrow, say, a shared reference to a key in a <code>HashMap</code>, we can’t borrow a mutable reference to the <code>HashMap</code> until the shared reference’s lifetime ends.</p>

<p>But there’s good justification for this: designing collections to support unrestricted, simultaneous iteration and modification is difficult, and often precludes simpler, more efficient implementations. Java’s <code>Hashtable</code> and C++’s <code>vector</code> don’t bother, and neither Python dictionaries nor JavaScript objects define exactly how such access behaves. Other collection types in JavaScript do, but require heavier implementations as a result. C++’s <code>std::map</code> promises that inserting new entries doesn’t invalidate pointers to other entries in the map, but by making that promise, the standard precludes more cache-efficient designs like Rust’s <code>BTreeMap</code>, which stores multiple entries in each node of the tree.</p>

<p>Here’s another example of the kind of bug these rules catch. Consider the following <span class="keep-together">C++</span> code, meant to manage a file descriptor. To keep things simple, we’re only going to show a constructor and a copying assignment operator, and we’re going to omit error handling:</p>

<pre class="cpp" data-type="programlisting" data-code-language="cpp"><code class="k">struct</code> <code class="n">File</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">descriptor</code><code class="p">;</code>

  <code class="n">File</code><code class="p">(</code><code class="kt">int</code> <code class="n">d</code><code class="p">)</code> <code class="o">:</code> <code class="n">descriptor</code><code class="p">(</code><code class="n">d</code><code class="p">)</code> <code class="p">{</code> <code class="p">}</code>

  <code class="n">File</code><code class="o">&amp;</code> <code class="k">operator</code><code class="o">=</code><code class="p">(</code><code class="k">const</code> <code class="n">File</code> <code class="o">&amp;</code><code class="n">rhs</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">close</code><code class="p">(</code><code class="n">descriptor</code><code class="p">);</code>
    <code class="n">descriptor</code> <code class="o">=</code> <code class="n">dup</code><code class="p">(</code><code class="n">rhs</code><code class="p">.</code><code class="n">descriptor</code><code class="p">);</code>
    <code class="k">return</code> <code class="o">*</code><code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code></pre>
<p>The assignment operator is simple enough, but fails badly in a situation like this:</p>
<pre class="cpp" data-type="programlisting" data-code-language="cpp"><code class="n">File</code> <code class="nf">f</code><code class="p">(</code><code class="n">open</code><code class="p">(</code><code class="s">"foo.txt"</code><code class="p">,</code> <code class="p">...));</code>
<code class="p">...</code>
<code class="n">f</code> <code class="o">=</code> <code class="n">f</code><code class="p">;</code></pre>

<p>If we assign a <code>File</code> to itself, both <code>rhs</code> and <code>*this</code> are the same object, so <code>operator=</code> closes the very file descriptor it’s about to pass to <code>dup</code>. We destroy the same resource we were meant to copy.</p>

<p>In Rust, the analogous code would be:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">File</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">descriptor</code>: <code class="kt">i32</code>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">new_file</code><code class="p">(</code><code class="n">d</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">File</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">descriptor</code>: <code class="nc">d</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">clone_from</code><code class="p">(</code><code class="n">this</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">File</code><code class="p">,</code><code class="w"> </code><code class="n">rhs</code>: <code class="kp">&amp;</code><code class="nc">File</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">close</code><code class="p">(</code><code class="n">this</code><code class="p">.</code><code class="n">descriptor</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">this</code><code class="p">.</code><code class="n">descriptor</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dup</code><code class="p">(</code><code class="n">rhs</code><code class="p">.</code><code class="n">descriptor</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>(This is not idiomatic Rust. There are excellent ways to give Rust types their own constructor functions and methods, which we describe in <a data-type="xref" href="ch09.xhtml#structs">Chapter 9</a>, but the preceding definitions work for this example.)</p>

<p>If we write the Rust code corresponding to the use of <code>File</code>, we get:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">new_file</code><code class="p">(</code><code class="n">open</code><code class="p">(</code><code class="s">"foo.txt"</code><code class="p">,</code><code class="w"> </code><code class="p">...));</code><code class="w"/>
<code class="p">...</code><code class="w"/>
<code class="n">clone_from</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">f</code><code class="p">);</code><code class="w"/></pre>

<p>Rust, of course, refuses to even compile this code:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0502]: cannot borrow `f` as immutable because it is also</code>
<code class="go">borrowed as mutable</code>
<code class="go">  --&gt; references_self_assignment.rs:18:25</code>
<code class="go">   |</code>
<code class="go">18 |     clone_from(&amp;mut f, &amp;f);</code>
<code class="go">   |                     -   ^- mutable borrow ends here</code>
<code class="go">   |                     |   |</code>
<code class="go">   |                     |   immutable borrow occurs here</code>
<code class="go">   |                     mutable borrow occurs here</code></pre>

<p>This should look familiar. It turns out that two classic C++ bugs—failure to cope with self-assignment, and using invalidated iterators—are the same underlying kind of bug! In both cases, code assumes it is modifying one value while consulting another, when in fact they’re both the same value. If you’ve ever accidentally let the source and destination of a call to <code>memcpy</code> or <code>strcpy</code> call overlap in C or C++, that’s yet another form the bug can take. By requiring mutable access to be exclusive, Rust has fended off a wide class of everyday mistakes.</p>

<p>The immiscibility of shared and mutable references really demonstrates its value when writing concurrent code. A data race is possible only when some value is both mutable and shared between threads—which is exactly what Rust’s reference rules eliminate. A concurrent Rust program that avoids <code>unsafe</code> code is free of data races <em>by construction</em>. We’ll cover this aspect in more detail when we talk about concurrency in <a data-type="xref" href="ch19.xhtml#concurrency">Chapter 19</a>, but in summary, concurrency is much easier to use in Rust than in most other languages.</p>

<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before"><div class="sidebar" id="idm45251639364392">
<h5 id="rusts-shared-references-versus-cs-pointers-to-const">Rust’s Shared References Versus C’s Pointers to const</h5>
<p><a contenteditable="false" data-primary="shared references" data-secondary="C's pointers to const values vs." data-type="indexterm" id="idm45251639362408"/><a contenteditable="false" data-primary="shared references" data-secondary="rules for" data-type="indexterm" id="idm45251639361064"/>On first inspection, Rust’s shared references seem to closely resemble C and C++’s pointers to <code>const</code> values. However, Rust’s rules for shared references are much stricter. For example, consider the following C code:</p>
<pre class="cpp" data-type="programlisting" data-code-language="cpp"><code class="kt">int</code> <code class="n">x</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>             <code class="c1">// int variable, not const</code>
<code class="k">const</code> <code class="kt">int</code> <code class="o">*</code><code class="n">p</code> <code class="o">=</code> <code class="o">&amp;</code><code class="n">x</code><code class="p">;</code>      <code class="c1">// pointer to const int</code>
<code class="n">assert</code><code class="p">(</code><code class="o">*</code><code class="n">p</code> <code class="o">==</code> <code class="mi">42</code><code class="p">);</code>
<code class="n">x</code><code class="o">++</code><code class="p">;</code>                    <code class="c1">// change variable directly</code>
<code class="n">assert</code><code class="p">(</code><code class="o">*</code><code class="n">p</code> <code class="o">==</code> <code class="mi">43</code><code class="p">);</code>       <code class="c1">// “constant” referent's value has changed</code></pre>
<p>The fact that <code>p</code> is a <code>const int *</code> means that you can’t modify its referent via <code>p</code> itself: <code>(*p)++</code> is forbidden. But you can also get at the referent directly as <code>x</code>, which is not <code>const</code>, and change its value that way. The C family’s <code>const</code> keyword has its uses, but constant it is not.</p>
<p>In Rust, a shared reference forbids all modifications to its referent, until its lifetime ends:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">42</code><code class="p">;</code><code class="w">         </code><code class="c1">// nonconst i32 variable</code>
<code class="kd">let</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w">             </code><code class="c1">// shared reference to i32</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">p</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">);</code><code class="w"/>
<code class="n">x</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w">                 </code><code class="c1">// error: cannot assign to x because it is borrowed</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">p</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">);</code><code class="w">     </code><code class="c1">// if you take out the assignment, this is true</code></pre>
<p>To ensure a value is constant, we need to keep track of all possible paths to that value, and make sure that they either don’t permit modification or cannot be used at all. C and C++ pointers are too unrestricted for the compiler to check this. Rust’s references are always tied to a particular lifetime, making it feasible to check them at compile time.<a contenteditable="false" data-primary="" data-startref="C05-references.html15" data-type="indexterm" id="idm45251639245560"/><a contenteditable="false" data-primary="" data-startref="C05-references.html14" data-type="indexterm" id="idm45251639244344"/><a contenteditable="false" data-primary="" data-startref="C05-references.html13" data-type="indexterm" id="idm45251639243000"/></p>
</div></aside>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Taking Arms Against a Sea of Objects"><div class="sect1" id="taking-arms-against-a-sea-of-objects">
<h1>Taking Arms Against a Sea of Objects</h1>

<p><a contenteditable="false" data-primary="references (pointer type)" data-secondary="&quot;sea of objects&quot; and" data-type="indexterm" id="C05-references.html16"/>Since the rise of automatic memory management in the 1990s, the default architecture of all programs has been the <em>sea of objects</em>, shown in <a data-type="xref" href="#figure-sea-of-objects">Figure 5-10</a>.</p>

<p>This is what happens if you have garbage collection and you start writing a program without designing anything. We’ve all built systems that look like this.</p>

<p>This architecture has many advantages that don’t show up in the diagram: initial progress is rapid, it’s easy to hack stuff in, and a few years down the road, you’ll have no difficulty justifying a complete rewrite. (Cue AC/DC’s “Highway to Hell.”)</p>

<figure><div id="figure-sea-of-objects" class="figure">
<img src="Images/rust_0501.png" alt="A graph of the objects in a program, showing infinitely many objects,          all pointing at each other."/>
<h6><span class="label">Figure 5-10. </span>
A sea of objects
</h6>
</div></figure>

<p>Of course, there are disadvantages too. When everything depends on everything else like this, it’s hard to test, evolve, or even think about any component in isolation.</p>

<p>One fascinating thing about Rust is that the ownership model puts a speed bump on the highway to hell. It takes a bit of effort to make a cycle in Rust—two values such that each one contains a reference pointing to the other. You have to use a smart pointer type, such as <code>Rc</code>, and <a href="ch09.xhtml#interior-mutability">interior mutability</a>—a topic we haven’t even covered yet. Rust prefers for pointers, ownership, and data flow to pass through the system in one direction, as shown in <a data-type="xref" href="#figure-tree-of-values">Figure 5-11</a>.</p>

<figure><div id="figure-tree-of-values" class="figure">
<img src="Images/rust_0502.png" alt="Another diagram, showing a tree of values with clear lines of ownership."/>
<h6><span class="label">Figure 5-11. </span>
A tree of values
</h6>
</div></figure>

<p>The reason we bring this up right now is that it would be natural, after reading this chapter, to want to run right out and create a “sea of structs,” all tied together with <code>Rc</code> smart pointers, and re-create all the object-oriented antipatterns you’re familiar with. This won’t work for you right away. Rust’s ownership model will give you some trouble. The cure is to do some up-front design and build a better program.</p>
<p>Rust is all about transferring the pain of understanding your program from the future to the present. It works unreasonably well: not only can Rust force you to understand why your program is thread-safe, it can even require some amount of high-level architectural design<a contenteditable="false" data-primary="" data-startref="C05-references.html16" data-type="indexterm" id="idm45251639226456"/>.<a contenteditable="false" data-primary="" data-startref="C05-references.html0" data-type="indexterm" id="idm45251639224952"/></p>
</div></section>
</div></section></div></body>
</html>