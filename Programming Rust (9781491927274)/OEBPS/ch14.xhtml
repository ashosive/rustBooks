<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Closures"><div class="chapter" id="closures">
<h1><span class="label">Chapter 14. </span>Closures</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>
Save the environment! Create a closure today!
</p>
<p data-type="attribution">
Cormac Flanagan
</p>
</blockquote>

<p>Sorting a vector of integers is easy.</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">integers</code><code class="p">.</code><code class="n">sort</code><code class="p">();</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="closures" data-type="indexterm" id="C14-closures.html0"/>It is, therefore, a sad fact that when we want some data sorted, it’s hardly ever a vector of integers. We typically have records of some kind, and the built-in <code>sort</code> method typically does not work:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">City</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">population</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">country</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">sort_cities</code><code class="p">(</code><code class="n">cities</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">cities</code><code class="p">.</code><code class="n">sort</code><code class="p">();</code><code class="w">  </code><code class="c1">// error: how do you want them sorted?</code>
<code class="p">}</code><code class="w"/></pre>
<p>Rust complains that <code>City</code> does not implement <code>std::cmp::Ord</code>. We need to specify the sort order, like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="sd">/// Helper function for sorting cities by population.</code>
<code class="k">fn</code> <code class="nf">city_population_descending</code><code class="p">(</code><code class="n">city</code>: <code class="kp">&amp;</code><code class="nc">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">-</code><code class="n">city</code><code class="p">.</code><code class="n">population</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">sort_cities</code><code class="p">(</code><code class="n">cities</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">cities</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="n">city_population_descending</code><code class="p">);</code><code class="w">  </code><code class="c1">// ok</code>
<code class="p">}</code><code class="w"/></pre>
<p>The helper function, <code>city_population_descending</code>, takes a <code>City</code> record and extracts the <em>key</em>, the field by which we want to sort our data. (It returns a negative number because <code>sort</code> arranges numbers in increasing order, and we want decreasing order: the most populous city first.) The <code>sort_by_key</code> method takes this key-function as a parameter.</p>
<p>This works fine, but it’s more concise to write the helper function as a <em>closure</em>, an anonymous function expression:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">sort_cities</code><code class="p">(</code><code class="n">cities</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">cities</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="o">|</code><code class="n">city</code><code class="o">|</code><code class="w"> </code><code class="o">-</code><code class="n">city</code><code class="p">.</code><code class="n">population</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The closure here is <code>|city| -city.population</code>. It takes an argument <code>city</code> and returns <code>-city.population</code>. Rust infers the argument type and return type from how the closure is used.</p>
<p>Other examples of standard library features that accept closures include:</p>
<ul>
<li><p><code>Iterator</code> methods such as <code>map</code> and <code>filter</code>, for working with sequential data. We’ll cover these methods in <a data-type="xref" href="ch15.xhtml#iterators">Chapter 15</a>.</p></li>
<li><p>Threading APIs like <code>thread::spawn</code>, which starts a new system thread. Concurrency is all about moving work to other threads, and closures conveniently represent units of work. We’ll cover these features in <a data-type="xref" href="ch19.xhtml#concurrency">Chapter 19</a>.</p></li>
<li><p>Some methods that conditionally need to compute a default value, like the <code>or_insert_with</code> method of <code>HashMap</code> entries. This method either gets or creates an entry in a <code>HashMap</code>, and it’s used when the default value is expensive to compute. The default value is passed in as a closure that is called only if a new entry must be created.</p></li>
</ul>
<p>Of course, anonymous functions are everywhere these days, even in languages like Java, C#, Python, and C++ that didn’t originally have them. From now on we’ll assume you’ve seen anonymous functions before and focus on what makes Rust’s closures a little different. In this chapter, you’ll learn how to use closures with standard library methods, how a closure can “capture” variables in its scope, how to write your own functions and methods that take closures as arguments, and how to store closures for later use as callbacks. We’ll also explain how Rust closures work and why they’re faster than you might expect.</p>

<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Capturing Variables"><div class="sect1" id="capturing-variables">
<h1>Capturing Variables</h1>

<p><a contenteditable="false" data-primary="closures" data-secondary="capturing variables" data-type="indexterm" id="idm45251606430600"/><a contenteditable="false" data-primary="variable capture" data-type="indexterm" id="idm45251606429224"/>A closure can use data that belongs to an enclosing function. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="sd">/// Sort by any of several different statistics.</code>
<code class="k">fn</code> <code class="nf">sort_by_statistic</code><code class="p">(</code><code class="n">cities</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">stat</code>: <code class="nc">Statistic</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">cities</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="o">|</code><code class="n">city</code><code class="o">|</code><code class="w"> </code><code class="o">-</code><code class="n">city</code><code class="p">.</code><code class="n">get_statistic</code><code class="p">(</code><code class="n">stat</code><code class="p">));</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The closure here uses <code>stat</code>, which is owned by the enclosing function, <code>sort_by_statistic</code>. We say that the closure “captures” <code>stat</code>. This is one of the classic features of closures, so naturally, Rust supports it; but in Rust, this feature comes with a string attached.</p>
<p><a contenteditable="false" data-primary="garbage collection" data-secondary="closures and" data-type="indexterm" id="idm45251606374296"/>In most languages with closures, garbage collection plays an important role. For example, consider this JavaScript code:</p>
<pre class="javascript" data-type="programlisting" data-code-language="javascript"><code class="c1">// Start an animation that rearranges the rows in a table of cities.</code>
<code class="kd">function</code> <code class="nx">startSortingAnimation</code><code class="p">(</code><code class="nx">cities</code><code class="p">,</code> <code class="nx">stat</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Helper function that we'll use to sort the table.</code>
    <code class="c1">// Note that this function refers to stat.</code>
    <code class="kd">function</code> <code class="nx">keyfn</code><code class="p">(</code><code class="nx">city</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">city</code><code class="p">.</code><code class="nx">get_statistic</code><code class="p">(</code><code class="nx">stat</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">pendingSort</code><code class="p">)</code>
        <code class="nx">pendingSort</code><code class="p">.</code><code class="nx">cancel</code><code class="p">();</code>

    <code class="c1">// Now kick off an animation, passing keyfn to it.</code>
    <code class="c1">// The sorting algorithm will call keyfn later.</code>
    <code class="nx">pendingSort</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SortingAnimation</code><code class="p">(</code><code class="nx">cities</code><code class="p">,</code> <code class="nx">keyfn</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>The closure <code>keyfn</code> is stored in the new <code>SortingAnimation</code> object. It’s meant to be called after <code>startSortingAnimation</code> returns. Now, normally when a function returns, all its variables and arguments go out of scope and are discarded. But here, the JavaScript engine must keep <code>stat</code> around somehow, since the closure uses it. Most JavaScript engines do this by allocating <code>stat</code> in the heap and letting the garbage collector reclaim it later.</p>
<p>Rust doesn’t have garbage collection. How will this work? To answer this question, we’ll look at two examples.</p>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Closures That Borrow"><div class="sect2" id="closures-that-borrow">
<h2>Closures That Borrow</h2>

<p><a contenteditable="false" data-primary="closures" data-secondary="borrowing references" data-type="indexterm" id="idm45251604675032"/><a contenteditable="false" data-primary="references (pointer type)" data-secondary="borrowing" data-type="indexterm" id="idm45251604673656"/>First, let’s repeat the opening example of this section:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">sort_by_statistic</code><code class="p">(</code><code class="n">cities</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">stat</code>: <code class="nc">Statistic</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">cities</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="o">|</code><code class="n">city</code><code class="o">|</code><code class="w"> </code><code class="o">-</code><code class="n">city</code><code class="p">.</code><code class="n">get_statistic</code><code class="p">(</code><code class="n">stat</code><code class="p">));</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In this case, when Rust creates the closure, it automatically borrows a reference to <code>stat</code>. It stands to reason: the closure refers to <code>stat</code>, so it must have a reference to it.</p>
<p>The rest is simple. The closure is subject to the rules about borrowing and lifetimes that we described in <a data-type="xref" href="ch05.xhtml#references">Chapter 5</a>. In particular, since the closure contains a reference to <code>stat</code>, Rust won’t let it outlive <code>stat</code>. Since the closure is only used during sorting, this example is fine.</p>
<p>In short, Rust ensures safety by using lifetimes instead of garbage collection. Rust’s way is faster: even a fast GC allocation will be slower than storing <code>stat</code> on the stack, as Rust does in this case.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Closures That Steal"><div class="sect2" id="closures-that-steal">
<h2>Closures That Steal</h2>

<p><a contenteditable="false" data-primary="closures" data-secondary="moves with" data-type="indexterm" id="idm45251606057144"/><a contenteditable="false" data-primary="moves" data-secondary="closures and" data-type="indexterm" id="idm45251606055768"/>The second example is trickier:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">start_sorting_thread</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="n">cities</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">stat</code>: <code class="nc">Statistic</code><code class="p">)</code><code class="w"/>
<code class="w">    </code>-&gt; <code class="nc">thread</code>::<code class="n">JoinHandle</code><code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">key_fn</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">|</code><code class="n">city</code>: <code class="kp">&amp;</code><code class="nc">City</code><code class="o">|</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"> </code><code class="o">-</code><code class="n">city</code><code class="p">.</code><code class="n">get_statistic</code><code class="p">(</code><code class="n">stat</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">    </code><code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">cities</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="n">key_fn</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">cities</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This is a bit more like what our JavaScript example was doing: <code>thread::spawn</code> takes a closure and calls it in a new system thread. Note that <code>||</code> is the closure’s empty argument list.</p>
<p>The new thread runs in parallel with the caller. When the closure returns, the new thread exits. (The closure’s return value is sent back to the calling thread as a <code>JoinHandle</code> value. We’ll cover that in <a data-type="xref" href="ch19.xhtml#concurrency">Chapter 19</a>.)</p>
<p>Again, the closure <code>key_fn</code> contains a reference to <code>stat</code>. But this time, Rust can’t guarantee that the reference is used safely. Rust therefore rejects this program:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0373]: closure may outlive the current function, but it borrows `stat`,</code>
<code class="go">              which is owned by the current function</code>
<code class="go">  --&gt; closures_sort_thread.rs:33:18</code>
<code class="go">   |</code>
<code class="go">33 | let key_fn = |city: &amp;City| -&gt; i64 { -city.get_statistic(stat) };</code>
<code class="go">   |              ^^^^^^^^^^^^^^^^^^^^                       ^^^^</code>
<code class="go">   |              |                                      `stat` is borrowed here</code>
<code class="go">   |              may outlive borrowed value `stat`</code></pre>
<p>In fact, there are two problems here, because <code>cities</code> is shared unsafely as well. Quite simply, the new thread created by <code>thread::spawn</code> can’t be expected to finish its work before <code>cities</code> and <code>stat</code> are destroyed at the end of the function.</p>
<p>The solution to both problems is the same: tell Rust to <em>move</em> <code>cities</code> and <code>stat</code> into the closures that use them instead of borrowing references to them.</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">start_sorting_thread</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="n">cities</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">stat</code>: <code class="nc">Statistic</code><code class="p">)</code><code class="w"/>
<code class="w">    </code>-&gt; <code class="nc">thread</code>::<code class="n">JoinHandle</code><code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">key_fn</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">move</code><code class="w"> </code><code class="o">|</code><code class="n">city</code>: <code class="kp">&amp;</code><code class="nc">City</code><code class="o">|</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"> </code><code class="o">-</code><code class="n">city</code><code class="p">.</code><code class="n">get_statistic</code><code class="p">(</code><code class="n">stat</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">    </code><code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">cities</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="n">key_fn</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">cities</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The only thing we’ve changed is to add the <code>move</code> keyword before each of the two closures. The <code>move</code> keyword tells Rust that a closure doesn’t borrow the variables it uses: it steals them.</p>
<p>The first closure, <code>key_fn</code>, takes ownership of <code>stat</code>. Then the second closure takes ownership of both <code>cities</code> and <code>key_fn</code>.</p>
<p>Rust thus offers two ways for closures to get data from enclosing scopes: moves and borrowing. Really there is nothing more to say than that; closures follow the same rules about moves and borrowing that we already covered in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.xhtml#ownership">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.xhtml#references">5</a>. A few cases in point:</p>
<ul>
<li><p>Just as everywhere else in the language, if a closure would <code>move</code> a value of a copyable type, like <code>i32</code>, it copies the value instead. So if <code>Statistic</code> happened to be a copyable type, we could keep using <code>stat</code> even after creating a <code>move</code> closure that uses it.</p></li>
<li><p>Values of noncopyable types, like <code>Vec&lt;City&gt;</code>, really are moved: the code above transfers <code>cities</code> to the new thread, by way of the <code>move</code> closure. Rust would not let us access <code>cities</code> by name after creating the closure.</p></li>
<li><p>As it happens, this code doesn’t need to use <code>cities</code> after the point where the closure moves it. If we did, though, the workaround would be easy: we could tell Rust to clone <code>cities</code> and store the copy in a different variable. The closure would only steal one of the copies—whichever one it refers to.</p></li>
</ul>
<p>We get something important by accepting Rust’s strict rules: thread safety. It is precisely because the vector is moved, rather than being shared across threads, that we know the old thread won’t free the vector while the new thread is modifying it.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Function and Closure Types"><div class="sect1" id="function-and-closure-types">
<h1>Function and Closure Types</h1>

<p><a contenteditable="false" data-primary="closures" data-secondary="types" data-type="indexterm" id="C14-closures.html1"/><a contenteditable="false" data-primary="functions" data-secondary="types" data-type="indexterm" id="C14-closures.html2"/><a contenteditable="false" data-primary="types" data-secondary="closures and" data-type="indexterm" id="C14-closures.html3"/>Throughout this chapter, we’ve seen functions and closures used as values. Naturally, this means that they have types. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">city_population_descending</code><code class="p">(</code><code class="n">city</code>: <code class="kp">&amp;</code><code class="nc">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">-</code><code class="n">city</code><code class="p">.</code><code class="n">population</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This function takes one argument (a <code>&amp;City</code>) and returns an <code>i64</code>. It has the type <code>fn(&amp;City) -&gt; i64</code>.</p>
<p>You can do all the same things with functions that you do with other values. You can store them in variables. You can use all the usual Rust syntax to compute function values:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">my_key_fn</code>: <code class="nc">fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">user</code><code class="p">.</code><code class="n">prefs</code><code class="p">.</code><code class="n">by_population</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">city_population_descending</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">city_monster_attack_risk_descending</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/>

<code class="n">cities</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="n">my_key_fn</code><code class="p">);</code><code class="w"/></pre>
<p>Structs may have function-typed fields. Generic types like <code>Vec</code> can store scads of functions, as long as they all share the same <code>fn</code> type. And function values are tiny: a <code>fn</code> value is the memory address of the function’s machine code, just like a function pointer in C++.</p>
<p>A function can take another function as an argument. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="sd">/// Given a list of cities and a test function,</code>
<code class="sd">/// return how many cities pass the test.</code>
<code class="k">fn</code> <code class="nf">count_selected_cities</code><code class="p">(</code><code class="n">cities</code>: <code class="kp">&amp;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">                         </code><code class="n">test_fn</code>: <code class="nc">fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">city</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">cities</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">test_fn</code><code class="p">(</code><code class="n">city</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">count</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="sd">/// An example of a test function. Note that the type of</code>
<code class="sd">/// this function is `fn(&amp;City) -&gt; bool`, the same as</code>
<code class="sd">/// the `test_fn` argument to `count_selected_cities`.</code>
<code class="k">fn</code> <code class="nf">has_monster_attacks</code><code class="p">(</code><code class="n">city</code>: <code class="kp">&amp;</code><code class="nc">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">city</code><code class="p">.</code><code class="n">monster_attack_risk</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mf">0.0</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// How many cities are at risk for monster attack?</code>
<code class="kd">let</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">count_selected_cities</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_cities</code><code class="p">,</code><code class="w"> </code><code class="n">has_monster_attacks</code><code class="p">);</code><code class="w"/></pre>
<p>If you’re familiar with function pointers in C/C++, you’ll see that Rust’s function values are exactly the same thing.</p>
<p>After all this, it may come as a surprise that closures do <em>not</em> have the same type as functions:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">limit</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">preferences</code><code class="p">.</code><code class="n">acceptable_monster_risk</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">count_selected_cities</code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="o">&amp;</code><code class="n">my_cities</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="o">|</code><code class="n">city</code><code class="o">|</code><code class="w"> </code><code class="n">city</code><code class="p">.</code><code class="n">monster_attack_risk</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">limit</code><code class="p">);</code><code class="w">  </code><code class="c1">// error: type mismatch</code></pre>
<p>The second argument causes a type error. To support closures, we must change the type signature of this function. It needs to look like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">count_selected_cities</code><code class="o">&lt;</code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="n">cities</code>: <code class="kp">&amp;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">City</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">test_fn</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code>
    <code class="nc">where</code><code class="w"> </code><code class="n">F</code>: <code class="nb">Fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">city</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">cities</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">test_fn</code><code class="p">(</code><code class="n">city</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">count</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>We have changed only the type signature of <code>count_selected_cities</code>, not the body. The new version is generic. It takes a <code>test_fn</code> of any type <code>F</code> as long as <code>F</code> implements the special trait <code>Fn(&amp;City) -&gt; bool</code>. This trait is automatically implemented by all functions and closures that take a single <code>&amp;City</code> as an argument and return a Boolean value.</p>
<pre data-type="programlisting" data-code-language="rust" data-testing-pragma="oneliners"><code class="k">fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code>    <code class="c1">// fn type (functions only)</code>
<code class="nb">Fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">City</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code>    <code class="c1">// Fn trait (both functions and closures)</code></pre>
<p>This special syntax is built into the language. The <code>-&gt;</code> and return type are optional; if omitted, the return type is <code>()</code>.</p>
<p>The new version of <code>count_selected_cities</code> accepts either a function or a closure:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">count_selected_cities</code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="o">&amp;</code><code class="n">my_cities</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">has_monster_attacks</code><code class="p">);</code><code class="w">  </code><code class="c1">// ok</code>

<code class="n">count_selected_cities</code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="o">&amp;</code><code class="n">my_cities</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="o">|</code><code class="n">city</code><code class="o">|</code><code class="w"> </code><code class="n">city</code><code class="p">.</code><code class="n">monster_attack_risk</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">limit</code><code class="p">);</code><code class="w">  </code><code class="c1">// also ok</code></pre>
<p>Why didn’t our first attempt work? Well, a closure is callable, but it’s not a <code>fn</code>. The closure <code>|city| city.monster_attack_risk &gt; limit</code> has its own type that’s not a <code>fn</code> type.</p>
<p>In fact, every closure you write has its own type, because a closure may contain data: values either borrowed or stolen from enclosing scopes. This could be any number of variables, in any combination of types. So every closure has an ad hoc type created by the compiler, large enough to hold that data. No two closures have exactly the same type. But every closure implements a <code>Fn</code> trait; the closure in our example implements <code>Fn(&amp;City) -&gt; i64</code>.</p>
<p>Since every closure has its own type, code that works with closures usually needs to be generic, like <code>count_selected_cities</code>. It’s a little clunky to spell out the generic types each time, but to see the advantages of this design, just read on.<a contenteditable="false" data-primary="" data-startref="C14-closures.html3" data-type="indexterm" id="idm45251604040904"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html2" data-type="indexterm" id="idm45251604039528"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html1" data-type="indexterm" id="idm45251604038152"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Closure Performance"><div class="sect1" id="closure-performance">
<h1>Closure Performance</h1>

<p><a contenteditable="false" data-primary="closures" data-secondary="performance" data-type="indexterm" id="idm45251604035272"/>Rust’s closures are designed to be fast: faster than function pointers, fast enough that you can use them even in red-hot, performance-sensitive code. If you’re familiar with C++ lambdas, you’ll find that Rust closures are just as fast and compact, but safer.</p>
<p>In most languages, closures are allocated in the heap, dynamically dispatched, and garbage collected. So creating them, calling them, and collecting them each cost a tiny bit of extra CPU time. <a contenteditable="false" data-primary="inlining" data-type="indexterm" id="idm45251604032856"/>Worse, closures tend to rule out <em>inlining</em>, a key technique compilers use to eliminate function call overhead and enable a raft of other optimizations. All told, closures are slow enough in these languages that it can be worth manually removing them from tight inner loops.</p>
<p>Rust closures have none of these performance drawbacks. They’re not garbage collected. Like everything else in Rust, they aren’t allocated on the heap unless you put them in a <code>Box</code>, <code>Vec</code>, or other container. And since each closure has a distinct type, whenever the Rust compiler knows the type of the closure you’re calling, it can inline the code for that particular closure. This makes it OK to use closures in tight loops, and Rust programs often do so, enthusiastically, as you’ll see in <a data-type="xref" href="ch15.xhtml#iterators">Chapter 15</a>.</p>

<p><a contenteditable="false" data-primary="closures" data-secondary="layout in memory" data-type="indexterm" id="idm45251604027896"/><a data-type="xref" href="#closures-layout">Figure 14-1</a> shows how Rust closures are laid out in memory. At the top of the figure, we show a couple of local variables that our closures will refer to: a string <code>food</code> and a simple enum <code>weather</code>, whose numeric value happens to be 27.</p>

<figure><div id="closures-layout" class="figure">
<img src="Images/rust_1401.png" alt="Picture showing three closures labeled (a), (b), and (c)." width="882" height="576"/>
<h6><span class="label">Figure 14-1. </span>
Layout of closures in memory
</h6>
</div></figure>

<p>Closure (a) uses both variables. Apparently we’re looking for cities that have both tacos and tornadoes. In memory, this closure looks like a small struct containing references to the variables it uses.</p>
<p>Note that it doesn’t contain a pointer to its code! That’s not necessary: as long as Rust knows the closure’s type, it knows which code to run when you call it.</p>
<p>Closure (b) is exactly the same, except it’s a <code>move</code> closure, so it contains values instead of references.</p>
<p>Closure (c) doesn’t use any variables from its environment. The struct is empty, so this closure does not take up any memory at all.</p>
<p>As the figure shows, these closures don’t take up much space. But even those few bytes are not always needed in practice. Often, the compiler can inline all calls to a closure, and then even the small structs shown in this figure are optimized away.</p>
<p>In <a data-type="xref" href="#callbacks">“Callbacks”</a>, we’ll show how to allocate closures in the heap and call them dynamically, using trait objects. That is a bit slower, but it is still as fast as any other trait object method.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Closures and Safety"><div class="sect1" id="closures-and-safety">
<h1>Closures and Safety</h1>

<p><a contenteditable="false" data-primary="closures" data-secondary="safety" data-type="indexterm" id="C14-closures.html4"/><a contenteditable="false" data-primary="safety" data-secondary="closures and" data-type="indexterm" id="C14-closures.html5"/>The next few pages complete our explanation of how closures interact with Rust’s safety system. As we said earlier in this chapter, most of the story is simply that when a closure is created, it either moves or borrows the captured variables. But some of the consequences are not exactly obvious. In particular, we’ll be talking about what happens when a closure drops or modifies a captured value.</p>

<section data-type="sect2" data-pdf-bookmark="Closures That Kill"><div class="sect2" id="closures-that-kill">
<h2>Closures That Kill</h2>

<p><a contenteditable="false" data-primary="closures" data-secondary="&quot;that kill&quot;" data-type="indexterm" id="C14-closures.html6"/><a contenteditable="false" data-primary="closures" data-secondary="dropping values" data-type="indexterm" id="C14-closures.html7"/><a contenteditable="false" data-primary="dropping values" data-secondary="in closures" data-type="indexterm" id="C14-closures.html8"/>We have seen closures that borrow values and closures that steal them; it was only a matter of time before they went all the way bad.</p>
<p>Of course, <em>kill</em> is not really the right terminology. In Rust, we <em>drop</em> values. The most straightforward way to do it is to call <code>drop()</code>:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">my_str</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"hello"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">drop</code><code class="p">(</code><code class="n">my_str</code><code class="p">);</code><code class="w"/></pre>
<p>When <code>f</code> is called, <code>my_str</code> is dropped.</p>
<p>So what happens if we call it twice?</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">f</code><code class="p">();</code><code class="w"/>
<code class="n">f</code><code class="p">();</code><code class="w"/></pre>
<p>Let’s think it through. The first time we call <code>f</code>, it drops <code>my_str</code>, which means the memory where the string is stored is freed, returned to the system. The second time we call <code>f</code>, the same thing happens. It’s a <em>double free</em>, a classic mistake in C++ programming that triggers undefined behavior.</p>
<p>Dropping a <code>String</code> twice would be an equally bad idea in Rust. Fortunately, Rust can’t be fooled so easily:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">f</code><code class="p">();</code><code class="w">  </code><code class="c1">// ok</code>
<code class="n">f</code><code class="p">();</code><code class="w">  </code><code class="c1">// error: use of moved value</code></pre>
<p>Rust knows this closure can’t be called twice.</p>
<p>A closure that can only be called once may seem like a rather extraordinary thing. But we’ve been talking throughout this book about ownership and lifetimes. The idea of values being used up (that is, moved) is one of the core concepts in Rust. It works the same with closures as with everything else.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="FnOnce"><div class="sect2" id="fnonce">
<h2>FnOnce</h2>

<p><a contenteditable="false" data-primary="closures" data-secondary="FnOnce" data-type="indexterm" id="C14-closures.html9"/><a contenteditable="false" data-primary="dropping values" data-secondary="FnOnce" data-type="indexterm" id="C14-closures.html10"/><a contenteditable="false" data-primary="FnOnce trait" data-type="indexterm" id="C14-closures.html11"/>Let’s try once more to trick Rust into dropping a <code>String</code> twice. This time, we’ll use this generic function:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">call_twice</code><code class="o">&lt;</code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="n">closure</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">F</code>: <code class="nb">Fn</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">closure</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">closure</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This generic function may be passed any closure that implements the trait <code>Fn()</code>: that is, closures that take no arguments and return <code>()</code>. (As with functions, the return type can be omitted if it’s <code>()</code>; <code>Fn()</code> is shorthand for <code>Fn() -&gt; ()</code>.)</p>
<p>Now what happens if we pass our unsafe closure to this generic function?</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">my_str</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"hello"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">drop</code><code class="p">(</code><code class="n">my_str</code><code class="p">);</code><code class="w"/>
<code class="n">call_twice</code><code class="p">(</code><code class="n">f</code><code class="p">);</code><code class="w"/></pre>
<p>Again, the closure will drop <code>my_str</code> when it’s called. Calling it twice would be a double free. But again, Rust is not fooled:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0525]: expected a closure that implements the `Fn` trait, but</code>
<code class="go">              this closure only implements `FnOnce`</code>
<code class="go">  --&gt; closures_twice.rs:12:13</code>
<code class="go">   |</code>
<code class="go">12 |     let f = || drop(my_str);</code>
<code class="go">   |             ^^^^^^^^^^^^^^^</code>
<code class="go">   |</code>
<code class="go">note: the requirement to implement `Fn` derives from here</code>
<code class="go">  --&gt; closures_twice.rs:13:5</code>
<code class="go">   |</code>
<code class="go">13 |     call_twice(f);</code>
<code class="go">   |     ^^^^^^^^^^</code></pre>
<p>This error message tells us more about how Rust handles “closures that kill.” They could have been banned from the language entirely, but cleanup closures are useful sometimes. So instead, Rust restricts their use. Closures that drop values, like <code>f</code>, are not allowed to have <code>Fn</code>. They are, quite literally, no <code>Fn</code> at all. They implement a less powerful trait, <code>FnOnce</code>, the trait of closures that can be called once.</p>
<p>The first time you call a <code>FnOnce</code> closure, <em>the closure itself is used up.</em> It’s as though the two traits, <code>Fn</code> and <code>FnOnce</code>, were defined like this:</p>
<pre>
// Pseudocode for `Fn` and `FnOnce` traits with no arguments.
trait <strong>Fn() -&gt; R</strong> {
    fn call(<strong>&amp;self</strong>) -&gt; R;
}

trait <strong>FnOnce() -&gt; R</strong> {
    fn call_once(<strong>self</strong>) -&gt; R;
}
</pre>
<p>Just as an arithmetic expression like <code>a + b</code> is shorthand for a method call, <code>Add::add(a, b)</code>, Rust treats <code>closure()</code> as shorthand for one of the two trait methods shown above. For a <code>Fn</code> closure, <code>closure()</code> expands to <code>closure.call()</code>. This method takes <code>self</code> by reference, so the closure is not moved. But if the closure is only safe to call once, then <code>closure()</code> expands to <code>closure.call_once()</code>. That method takes <code>self</code> by value, so the closure is used up.</p>

<p>Of course we’ve been deliberately stirring up trouble here by using <code>drop()</code>. In practice, you’ll mostly get into this situation by accident. It doesn’t happen often, but once in a great while you’ll write some closure code that unintentionally uses up a value:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">dict</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">produce_glossary</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">debug_dump_dict</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">key</code><code class="p">,</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">dict</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><code class="c1">// oops!</code>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?} - {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">key</code><code class="p">,</code><code class="w"> </code><code class="n">value</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>Then, when you call <code>debug_dump_dict()</code> more than once, you’ll get an error message like this:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0382]: use of moved value: `debug_dump_dict`</code>
<code class="go">  --&gt; closures_debug_dump_dict.rs:18:5</code>
<code class="go">   |</code>
<code class="go">17 |     debug_dump_dict();</code>
<code class="go">   |     --------------- value moved here</code>
<code class="go">18 |     debug_dump_dict();</code>
<code class="go">   |     ^^^^^^^^^^^^^^^ value used here after move</code>
<code class="go">   |</code>
<code class="go">   = help: closure was moved because it only implements `FnOnce`</code></pre>
<p>To debug this, we have to figure out why the closure is a <code>FnOnce</code>. Which value is being used up here? The only one we’re referring to at all is <code>dict</code>. Ah, there’s the bug: we’re using up <code>dict</code> by iterating over it directly. We should be looping over <code>&amp;dict</code> rather than plain <code>dict</code>, to access the values by reference:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="n">debug_dump_dict</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">key</code><code class="p">,</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">dict</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><code class="c1">// does not use up dict</code>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?} - {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">key</code><code class="p">,</code><code class="w"> </code><code class="n">value</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>This fixes the error; the function is now a <code>Fn</code> and can be called any number of times<a contenteditable="false" data-primary="" data-startref="C14-closures.html11" data-type="indexterm" id="idm45251603546552"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html10" data-type="indexterm" id="idm45251603545416"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html9" data-type="indexterm" id="idm45251603544040"/>.<a contenteditable="false" data-primary="" data-startref="C14-closures.html8" data-type="indexterm" id="idm45251603542536"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html7" data-type="indexterm" id="idm45251603541128"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html6" data-type="indexterm" id="idm45251603539752"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="FnMut"><div class="sect2" id="fnmut">
<h2>FnMut</h2>

<p><a contenteditable="false" data-primary="closures" data-secondary="FnMut" data-type="indexterm" id="C14-closures.html12"/><a contenteditable="false" data-primary="FnMut trait" data-type="indexterm" id="C14-closures.html13"/><a contenteditable="false" data-primary="mutable references (&amp;mutT)" data-secondary="FnMut" data-type="indexterm" id="C14-closures.html14"/>There is one more kind of closure, the kind that contains mutable data or <code>mut</code> references.</p>
<p>Rust considers non-<code>mut</code> values safe to share across threads. But it wouldn’t be safe to share non-<code>mut</code> closures that contain <code>mut</code> data: calling such a closure from multiple threads could lead to all sorts of race conditions as multiple threads try to read and write the same data at the same time.</p>
<p>Therefore, Rust has one more category of closure, <code>FnMut</code>, the category of closures that write. <code>FnMut</code> closures are called by <code>mut</code> reference, as if they were defined like this:</p>
<pre>
// Pseudocode for `Fn`, `FnMut`, and `FnOnce` traits.
trait Fn() -&gt; R {
    fn call(&amp;self) -&gt; R;
}

trait <strong>FnMut() -&gt; R</strong> {
    fn call_mut(<strong>&amp;mut self</strong>) -&gt; R;
}

trait FnOnce() -&gt; R {
    fn call_once(self) -&gt; R;
}
</pre>
<p>Any closure that requires <code>mut</code> access to a value, but doesn’t drop any values, is a <code>FnMut</code> closure. For example:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">incr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">i</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w">  </code><code class="c1">// incr borrows a mut reference to i</code>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Ding! i is now: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="p">};</code><code class="w"/>
<code class="n">call_twice</code><code class="p">(</code><code class="n">incr</code><code class="p">);</code><code class="w"/></pre>
<p>The way we wrote <code>call_twice</code>, it requires a <code>Fn</code>. Since <code>incr</code> is a <code>FnMut</code> and not a <code>Fn</code>, this code fails to compile. There’s an easy fix, though. To understand the fix, let’s take a step back and summarize what you’ve learned about the three categories of Rust closures.</p>

<ul>
<li><p><a contenteditable="false" data-primary="Fn trait" data-type="indexterm" id="idm45251603452200"/><code>Fn</code> is the family of closures and functions that you can call multiple times without restriction. This highest category also includes all <code>fn</code> functions.</p></li>
<li><p><code>FnMut</code> is the family of closures that can be called multiple times if the closure itself is declared <code>mut</code>.</p></li>
<li><p><code>FnOnce</code> is the family of closures that can be called once, if the caller owns the closure.</p></li>
</ul>

<p>Every <code>Fn</code> meets the requirements for <code>FnMut</code>, and every <code>FnMut</code> meets the requirements for <code>FnOnce</code>. As shown in <a data-type="xref" href="#closure-venn-diagram">Figure 14-2</a>, they’re not three separate categories.</p>

<figure><div id="closure-venn-diagram" class="figure">
<img src="Images/rust_1402.png" alt="Picture showing Fn as the innermost circle, enclosed by FnMut, which is enclosed by FnOnce." width="690" height="442"/>
<h6><span class="label">Figure 14-2. </span>
Venn diagram of the three closure categories
</h6>
</div></figure>

<p>Instead, <code>Fn()</code> is a subtrait of <code>FnMut()</code>, which is a subtrait of <code>FnOnce()</code>. This makes <code>Fn</code> the most exclusive and most powerful category. <code>FnMut</code> and <code>FnOnce</code> are broader categories that include closures with usage restrictions.</p>
<p>Now that we’ve organized what we know, it’s clear that to accept the widest possible swath of closures, our <code>call_twice</code> function really ought to accept all <code>FnMut</code> closures, like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">call_twice</code><code class="o">&lt;</code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="n">closure</code>: <code class="nc">F</code><code class="p">)</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">closure</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">closure</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The bound on the first line was <code>F: Fn()</code>, and now it’s <code>F: FnMut()</code>. With this change, we still accept all <code>Fn</code> closures, and we additionally can use <code>call_twice</code> on closures that mutate data<a contenteditable="false" data-primary="" data-startref="C14-closures.html14" data-type="indexterm" id="idm45251603373064"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html13" data-type="indexterm" id="idm45251603371800"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html12" data-type="indexterm" id="idm45251603370424"/>:<a contenteditable="false" data-primary="" data-startref="C14-closures.html5" data-type="indexterm" id="idm45251603368920"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html4" data-type="indexterm" id="idm45251603367512"/></p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="n">call_twice</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w">  </code><code class="c1">// ok!</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">i</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Callbacks"><div class="sect1" id="callbacks">
<h1>Callbacks</h1>

<p><a contenteditable="false" data-primary="callbacks, closures and" data-type="indexterm" id="C14-closures.html15"/><a contenteditable="false" data-primary="closures" data-secondary="callbacks" data-type="indexterm" id="C14-closures.html16"/><a contenteditable="false" data-primary="routers, callbacks and" data-type="indexterm" id="C14-closures.html17"/>A lot of libraries use <em>callbacks</em> as part of their API: functions provided by the user, for the library to call later. In fact, you’ve seen some APIs like that already in this book. Back in <a data-type="xref" href="ch02.xhtml#a-tour-of-rust">Chapter 2</a>, we used the Iron framework to write a simple web server. It looked like this:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">router</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Router</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="n">router</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code><code class="w"> </code><code class="n">get_form</code><code class="p">,</code><code class="w"> </code><code class="s">"root"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">router</code><code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="s">"/gcd"</code><code class="p">,</code><code class="w"> </code><code class="n">post_gcd</code><code class="p">,</code><code class="w"> </code><code class="s">"gcd"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Serving on http://localhost:3000..."</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">Iron</code>::<code class="n">new</code><code class="p">(</code><code class="n">router</code><code class="p">).</code><code class="n">http</code><code class="p">(</code><code class="s">"localhost:3000"</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The purpose of the router is to route incoming requests from the Internet to the bit of Rust code that handles that particular kind of request. In this example, <code>get_form</code> and <code>post_gcd</code> were the names of some functions that we declared elsewhere in the program, using the <code>fn</code> keyword. But we could have passed closures instead, like this:</p>

<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">router</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Router</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="n">router</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">_</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Request</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">get_form_response</code><code class="p">())</code><code class="w"/>
<code class="p">},</code><code class="w"> </code><code class="s">"root"</code><code class="p">);</code><code class="w"/>
<code class="n">router</code><code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="s">"/gcd"</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">request</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Request</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_numbers</code><code class="p">(</code><code class="n">request</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">get_gcd_response</code><code class="p">(</code><code class="n">numbers</code><code class="p">))</code><code class="w"/>
<code class="p">},</code><code class="w"> </code><code class="s">"gcd"</code><code class="p">);</code><code class="w"/></pre>
<p>This is because Iron was written to accept any thread-safe <code>Fn</code> as an argument.</p>

<p>How can we do that in our own programs? Let’s try writing our own very simple router from scratch, without using any code from Iron. We can begin by declaring a few types to represent HTTP requests and responses:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Request</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">method</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">url</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">headers</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">body</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">struct</code> <code class="nc">Response</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">code</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">headers</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">body</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Now the job of a router is simply to store a table that maps URLs to callbacks, so that the right callback can be called on demand. (For simplicity’s sake, we’ll only allow users to create routes that match a single exact URL.)</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">BasicRouter</code><code class="o">&lt;</code><code class="n">C</code><code class="o">&gt;</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">C</code>: <code class="nb">Fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Response</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">routes</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">C</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">C</code><code class="o">&gt;</code><code class="w"> </code><code class="n">BasicRouter</code><code class="o">&lt;</code><code class="n">C</code><code class="o">&gt;</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">C</code>: <code class="nb">Fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Response</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Create an empty router.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">new</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">BasicRouter</code><code class="o">&lt;</code><code class="n">C</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">BasicRouter</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">routes</code>: <code class="nc">HashMap</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Add a route to the router.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add_route</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">url</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">callback</code>: <code class="nc">C</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">routes</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">url</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"> </code><code class="n">callback</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Unfortunately, we’ve made a mistake. Did you notice it?</p>
<p>This router works fine as long as we only add one route to it:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">router</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BasicRouter</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">router</code><code class="p">.</code><code class="n">add_route</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">_</code><code class="o">|</code><code class="w"> </code><code class="n">get_form_response</code><code class="p">());</code><code class="w"/></pre>
<p>This much compiles and runs. Unfortunately, if we add another route:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="n">router</code><code class="p">.</code><code class="n">add_route</code><code class="p">(</code><code class="s">"/gcd"</code><code class="p">,</code><code class="w"> </code><code class="o">|</code><code class="n">req</code><code class="o">|</code><code class="w"> </code><code class="n">get_gcd_response</code><code class="p">(</code><code class="n">req</code><code class="p">));</code><code class="w"/></pre>
<p>then we get errors:</p>
<pre class="console" data-type="programlisting" data-code-language="console"><code class="go">error[E0308]: mismatched types</code>
<code class="go">  --&gt; closures_bad_router.rs:41:30</code>
<code class="go">   |</code>
<code class="go">41 |     router.add_route("/gcd", |req| get_gcd_response(req));</code>
<code class="go">   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^</code>
<code class="go">   |                              expected closure, found a different closure</code>
<code class="go">   |</code>
<code class="go">   = note: expected type `[closure@closures_bad_router.rs:40:27: 40:50]`</code>
<code class="go">              found type `[closure@closures_bad_router.rs:41:30: 41:57]`</code>
<code class="go">note: no two closures, even if identical, have the same type</code>
<code class="go">help: consider boxing your closure and/or using it as a trait object</code></pre>
<p>Our mistake was in how we defined the <code>BasicRouter</code> type:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">BasicRouter</code><code class="o">&lt;</code><code class="n">C</code><code class="o">&gt;</code><code class="w"> </code><code class="k">where</code><code class="w"> </code><code class="n">C</code>: <code class="nb">Fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Response</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">routes</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">C</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>We unwittingly declared that each <code>BasicRouter</code> has a single callback type <code>C</code>, and all the callbacks in the <code>HashMap</code> are of that type. Back in <a data-type="xref" href="ch11.xhtml#which-to-use">“Which to Use”</a>, we showed a <code>Salad</code> type that had the same problem.</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">struct</code> <code class="nc">Salad</code><code class="o">&lt;</code><code class="n">V</code>: <code class="nc">Vegetable</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">veggies</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">V</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The solution here is the same as for the salad: since we want to support a variety of types, we need to use boxes and trait objects.</p>

<pre data-type="programlisting" data-code-language="rust"><code class="k">type</code> <code class="nc">BoxedCallback</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code><code class="o">&lt;</code><code class="nb">Fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Response</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="k">struct</code> <code class="nc">BasicRouter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">routes</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">BoxedCallback</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Each box can contain a different type of closure, so a single <code>HashMap</code> can contain all sorts of callbacks. Note that the type parameter <code>C</code> is gone.</p>
<p>This requires a few adjustments to the methods:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="n">BasicRouter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Create an empty router.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">new</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">BasicRouter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">BasicRouter</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">routes</code>: <code class="nc">HashMap</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Add a route to the router.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add_route</code><code class="o">&lt;</code><code class="n">C</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">url</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">callback</code>: <code class="nc">C</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">where</code><code class="w"> </code><code class="n">C</code>: <code class="nb">Fn</code><code class="p">(</code><code class="o">&amp;</code><code class="n">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Response</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">'static</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">routes</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">url</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">callback</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>(Note the two bounds on <code>C</code> in the type signature for <code>add_route</code>: a particular <code>Fn</code> trait, and the <code>'static</code> lifetime. Rust makes us add this <code>'static</code> bound. Without it, the call to <code>Box::new(callback)</code> would be an error, because it’s not safe to store a closure if it contains borrowed references to variables that are about to go out of scope.)<a contenteditable="false" data-primary="" data-startref="C14-closures.html17" data-type="indexterm" id="idm45251602416984"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html16" data-type="indexterm" id="idm45251602415608"/><a contenteditable="false" data-primary="" data-startref="C14-closures.html15" data-type="indexterm" id="idm45251602414232"/></p>
<p>Finally, our simple router is ready to handle incoming requests:</p>
<pre data-type="programlisting" data-code-language="rust"><code class="k">impl</code><code class="w"> </code><code class="n">BasicRouter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">handle_request</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">request</code>: <code class="kp">&amp;</code><code class="nc">Request</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Response</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">routes</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="o">&amp;</code><code class="n">request</code><code class="p">.</code><code class="n">url</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">not_found_response</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="nb">Some</code><code class="p">(</code><code class="n">callback</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">callback</code><code class="p">(</code><code class="n">request</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Using Closures Effectively"><div class="sect1" id="using-closures-effectively">
<h1>Using Closures Effectively</h1>

<p><a contenteditable="false" data-primary="closures" data-secondary="effective use of" data-type="indexterm" id="idm45251602347608"/>As we’ve seen, Rust’s closures are different from closures in most other languages. The biggest difference is that in languages with GC, you can use local variables in a closure without having to think about lifetimes or ownership. Without GC, things are different. Some design patterns that are commonplace in Java, C#, and JavaScript won’t work in Rust without changes.</p>
<p><a contenteditable="false" data-primary="Model-View-Controller (MVC)" data-type="indexterm" id="idm45251602345448"/>For example, take the Model-View-Controller design pattern (MVC for short), illustrated in <a data-type="xref" href="#mvc-diagram">Figure 14-3</a>. For every element of a user interface, an MVC framework creates three objects: a <em>model</em> representing that UI element’s state, a <em>view</em> that’s responsible for its appearance, and a <em>controller</em> that handles user interaction. Countless variations on MVC have been implemented over the years, but the general idea is that three objects divvy up the UI responsibilities somehow.</p>
<p>Here’s the problem. Typically, each object has a reference to one or both of the others, directly or through a callback, as shown in <a data-type="xref" href="#mvc-diagram">Figure 14-3</a>. Whenever anything happens to one of the objects, it notifies the others, so everything updates promptly. The question of which object “owns” the others never comes up.</p>

<figure><div id="mvc-diagram" class="figure">
<img src="Images/rust_1403.png" alt="Graph showing three objects, connected by arrows. Some of the arrows are labeled 'via callback'." width="549" height="282"/>
<h6><span class="label">Figure 14-3. </span>
The Model-View-Controller design pattern
</h6>
</div></figure>

<p>You can’t implement this pattern in Rust without making some changes. Ownership must be made explicit, and reference cycles must be eliminated. The model and the controller can’t have direct references to each other.</p>
<p>Rust’s radical wager is that good alternative designs exist. Sometimes you can fix a problem with closure ownership and lifetimes by having each closure receive the references it needs as arguments. Sometimes you can assign each thing in the system a number and pass around the numbers instead of references. Or you can implement one of the many variations on MVC where the objects don’t all have references to each other. <a contenteditable="false" data-primary="Flux" data-type="indexterm" id="idm45251602277704"/>Or model your toolkit after a non-MVC system with unidirectional data flow, like Facebook’s Flux architecture, shown in <a data-type="xref" href="#flux-diagram">Figure 14-4</a>.</p>

<figure><div id="flux-diagram" class="figure">
<img src="Images/rust_1404.png" alt="Graph showing four boxes: Action, Dispatcher, Store, View.           A user is also shown.           Arrows point in a loop from user input, through the four boxes in order,           to the user's display." width="950" height="318"/>
<h6><span class="label">Figure 14-4. </span>
The Flux architecture, an alternative to MVC
</h6>
</div></figure>

<p>In short, if you try to use Rust closures to make a “sea of objects,” you’re going to have a hard time. But there are alternatives. In this case, it seems software engineering as a discipline is already gravitating to the alternatives anyway, because they’re simpler.</p>
<p>In the next chapter, we turn to a topic where closures really shine. We’ll be writing a kind of code that takes full advantage of the concision, speed, and efficiency of Rust closures and that’s fun to write, easy to read, and eminently practical. Up next: Rust iterators.<a contenteditable="false" data-primary="" data-startref="C14-closures.html0" data-type="indexterm" id="idm45251602271720"/></p>
</div></section>
</div></section></div></body>
</html>