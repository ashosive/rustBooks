<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Collections"><div class="chapter" id="collections">
<h1><span class="label">Chapter 16. </span>Collections</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>We all behave like Maxwell’s demon. Organisms organize. In everyday experience lies the reason sober physicists across two centuries kept this cartoon fantasy alive. We sort the mail, build sand castles, solve jigsaw puzzles, separate wheat from chaff, rearrange chess pieces, collect stamps, alphabetize books, create symmetry, compose sonnets and sonatas, and put our rooms in order, and all this we do requires no great energy, as long as we can apply intelligence.</p>

<p data-type="attribution">James Gleick, <em>The Information: A History, a Theory, a Flood</em></p>
</blockquote>

<p><a contenteditable="false" data-primary="collections" data-type="indexterm" id="C16-collections.html0"/>The Rust standard library contains several <em>collections</em>, generic types for storing data in memory. We’ve already been using collections, such as <code>Vec</code> and <code>HashMap</code>, throughout this book. In this chapter, we’ll cover the methods of these two types in detail, along with the other half-dozen standard collections. Before we begin, let’s address a few systematic differences between Rust’s collections and those in other languages.</p>

<p>First, moves and borrowing are everywhere. Rust uses moves to avoid deep-copying values. That’s why the method <code>Vec&lt;T&gt;::push(item)</code> takes its argument by value, not by reference. The value is moved into the vector. The diagrams in <a data-type="xref" href="ch04.xhtml#ownership">Chapter 4</a> show how this works out in practice: pushing a Rust <code>String</code> to a <code>Vec&lt;String&gt;</code> is quick, because Rust doesn’t have to copy the string’s character data, and ownership of the string is always clear.</p>

<p>Second, Rust doesn’t have invalidation errors—the kind of dangling-pointer bug where a collection is resized, or otherwise changed, while the program is holding a pointer to data inside it. Invalidation errors are another source of undefined behavior in C++, and they cause the occasional <code>ConcurrentModificationException</code> even in memory-safe languages. Rust’s borrow checker rules them out at compile time.</p>

<p>Finally, Rust does not have <code>null</code>, so we’ll see <code>Option</code>s in places where other languages would use <code>null</code>.</p>

<p>Apart from these differences, Rust’s collections are about what you’d expect. If you’re an experienced programmer in a hurry, you can skim here, but don’t miss <a data-type="xref" href="#entries">“Entries”</a>.</p>

<section data-type="sect1" data-pdf-bookmark="Overview"><div class="sect1" id="overview">
<h1>Overview</h1>

<p><a contenteditable="false" data-primary="collections" data-secondary="summary of standard collections" data-type="indexterm" id="idm45251592218936"/><a data-type="xref" href="#table-collections">Table 16-1</a> shows Rust’s eight standard collections. All of them are generic types.</p>

<table id="table-collections" class="tallrow">
	<caption><span class="label">Table 16-1. </span>Summary of the standard collections</caption>
	<thead>
		<tr>
			<th rowspan="2">Collection</th>
			<th rowspan="2">Description</th>
			<th class="aligncenter" colspan="3">Similar collection type in...</th>
		</tr>
		<tr>
			<th>C++</th>
			<th>Java</th>
			<th>Python</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>Vec&lt;T&gt;</code></td>
			<td>Growable array</td>
			<td><code>vector</code></td>
			<td><code>ArrayList</code></td>
			<td><code>list</code></td>
		</tr>
		<tr>
			<td><code>VecDeque&lt;T&gt;</code></td>
			<td>Double-ended queue<br/>
			(growable ring buffer)</td>
			<td><code>deque</code></td>
			<td><code>ArrayDeque</code></td>
			<td><code>collections​.deque</code></td>
		</tr>
		<tr>
			<td><code>LinkedList&lt;T&gt;</code></td>
			<td>Doubly linked list</td>
			<td><code>list</code></td>
			<td><code>LinkedList</code></td>
			<td>—</td>
		</tr>
		<tr>
			<td><code>BinaryHeap&lt;T&gt;</code><br/><code> where T: Ord</code></td>
			<td>Max heap</td>
			<td><code>priority_queue</code></td>
			<td><code>PriorityQueue</code></td>
			<td><code>heapq</code></td>
		</tr>
		<tr>
			<td><code>HashMap&lt;K, V&gt;</code><br/><code> where K: Eq + Hash</code></td>
			<td>Key-value hash table</td>
			<td><code>unordered_map</code></td>
			<td><code>HashMap</code></td>
			<td><code>dict</code></td>
		</tr>
		<tr>
			<td><code>BTreeMap&lt;K, V&gt;</code><br/><code> where K: Ord</code></td>
			<td>Sorted key-value table</td>
			<td><code>map</code></td>
			<td><code>TreeMap</code></td>
			<td>—</td>
		</tr>
		<tr>
			<td><code>HashSet&lt;T&gt;</code><br/><code> where T: Eq + Hash</code></td>
			<td>Hash table</td>
			<td><code>unordered_set</code></td>
			<td><code>HashSet</code></td>
			<td><code>set</code></td>
		</tr>
		<tr>
			<td><code>BTreeSet&lt;T&gt;</code><br/><code> where T: Ord</code></td>
			<td>Sorted set</td>
			<td><code>set</code></td>
			<td><code>TreeSet</code></td>
			<td>—</td>
		</tr>
	</tbody>
</table>

<p><code>Vec&lt;T&gt;</code>, <code>HashMap&lt;K, V&gt;</code>, and <code>HashSet&lt;T&gt;</code> are the most generally useful collection types. The rest have niche uses. This chapter discusses each collection type in turn:</p>

<ul>
	<li>
	<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592178376"/><code>Vec&lt;T&gt;</code> is a growable, heap-allocated array of values of type <code>T</code>. About half of this chapter is dedicated to <code>Vec</code> and its many useful methods.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="VecDeque&lt;T&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592174952"/><code>VecDeque&lt;T&gt;</code> is like <code>Vec&lt;T&gt;</code>, but better for use as a first-in-first-out queue. It supports efficiently adding and removing values at the front of the list as well as the back. This comes at the cost of making all other operations slightly slower.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="LinkedList&lt;T&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592171720"/><code>LinkedList&lt;T&gt;</code> supports fast access to the front and back of the list, like <code>VecDeque&lt;T&gt;</code>, and adds fast concatenation. However, in general, <code>LinkedList&lt;T&gt;</code> is slower than <code>Vec&lt;T&gt;</code> and <code>VecDeque&lt;T&gt;</code>.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="BinaryHeap&lt;T&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592071432"/><code>BinaryHeap&lt;T&gt;</code> is a priority queue. The values in a <code>BinaryHeap</code> are organized so that it’s always efficient to find and remove the maximum value.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="HashMap&lt;K, V&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592068808"/><code>HashMap&lt;K, V&gt;</code> is a table of key-value pairs. Looking up a value by its key is fast. The entries are stored in an arbitrary order.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="BTreeMap&lt;K, V&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592066408"/><code>BTreeMap&lt;K, V&gt;</code> is like <code>HashMap&lt;K, V&gt;</code>, but it keeps the entries sorted by key. A <code>BTreeMap&lt;String, i32&gt;</code> stores its entries in <code>String</code> comparison order. Unless you need the entries to stay sorted, a <code>HashMap</code> is faster.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="HashSet&lt;T&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592062024"/><code>HashSet&lt;T&gt;</code> is a set of values of type <code>T</code>. Adding and removing values is fast, and it’s fast to ask whether a given value is in the set or not.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="BTreeSet&lt;T&gt; collection type" data-secondary="defined" data-type="indexterm" id="idm45251592058904"/><code>BTreeSet&lt;T&gt;</code> is like <code>HashSet&lt;T&gt;</code>, but it keeps the elements sorted by value. Again, unless you need the data sorted, a <code>HashSet</code> is faster.</p>
	</li>
</ul>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Vec&lt;T&gt;"><div class="sect1" id="vect">
<h1>Vec&lt;T&gt;</h1>

<p><a contenteditable="false" data-primary="collections" data-secondary="Vec&lt;T&gt;" data-type="indexterm" id="C16-collections.html1"/><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-type="indexterm" id="C16-collections.html2"/>We’ll assume some familiarity with <code>Vec</code>, since we’ve been using it throughout the book. For an introduction, see <a data-type="xref" href="ch03.xhtml#vectors">“Vectors”</a>. Here we’ll finally describe its methods and its inner workings in depth.</p>

<p>The easiest way to create a vector is to use the <code>vec!</code> macro:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Create an empty vector</code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">numbers</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[];</code><code class="w"/>

<code class="c1">// Create a vector with given contents</code>
<code class="kd">let</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"step"</code><code class="p">,</code><code class="w"> </code><code class="s">"on"</code><code class="p">,</code><code class="w"> </code><code class="s">"no"</code><code class="p">,</code><code class="w"> </code><code class="s">"pets"</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">buffer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="k">u8</code><code class="p">;</code><code class="w"> </code><code class="mi">1024</code><code class="p">];</code><code class="w">  </code><code class="c1">// 1024 zeroed-out bytes</code></pre>

<p>As described in <a data-type="xref" href="ch04.xhtml#ownership">Chapter 4</a>, a vector has three fields: the length, the capacity, and a pointer to a heap allocation where the elements are stored. <a data-type="xref" href="#vector-layout-figure">Figure 16-1</a> shows how the vectors created above would appear in memory. The empty vector, <code>numbers</code>, initially has a capacity of 0. No heap memory is allocated for it until the first element is added.</p>

<p>Like all collections, <code>Vec</code> implements <code>std::iter::FromIterator</code>, so you can create a vector from any iterator using the iterator’s <code>.collect()</code> method, as described in <a data-type="xref" href="ch15.xhtml#building-collections-collect-and-fromiterator">“Building Collections: collect and FromIterator”</a>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Convert another collection to a vector.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">my_vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">my_set</code><code class="p">.</code><code class="n">into_iter</code><code class="p">().</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;&gt;</code><code class="p">();</code><code class="w"/></pre>

<figure><div id="vector-layout-figure" class="figure"><img src="Images/rust_1601.png" alt="(Each vector has three fields: a buffer pointer, the capacity, and the length.           The buffer pointer of the &quot;numbers&quot; vector is null, and its capacity is zero.           Each of the other buffer pointers points to a heap-allocated array           and has a capacity equal to its length.)" width="1415" height="838"/>
<h6><span class="label">Figure 16-1. </span>Vector layout in memory. Each element of words is a &amp;str value consisting of a pointer and a length.</h6>
</div></figure>

<section data-type="sect2" data-pdf-bookmark="Accessing Elements"><div class="sect2" id="accessing-elements">
<h2>Accessing Elements</h2>

<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="accessing elements" data-type="indexterm" id="C16-collections.html3"/>Getting elements of an array, slice, or vector by index is straightforward:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Get a reference to an element</code>
<code class="kd">let</code><code class="w"> </code><code class="n">first_line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">lines</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>

<code class="c1">// Get a copy of an element</code>
<code class="kd">let</code><code class="w"> </code><code class="n">fifth_number</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">numbers</code><code class="p">[</code><code class="mi">4</code><code class="p">];</code><code class="w">       </code><code class="c1">// requires Copy</code>
<code class="kd">let</code><code class="w"> </code><code class="n">second_line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">lines</code><code class="p">[</code><code class="mi">1</code><code class="p">].</code><code class="n">clone</code><code class="p">();</code><code class="w">  </code><code class="c1">// requires Clone</code>

<code class="c1">// Get a reference to a slice</code>
<code class="kd">let</code><code class="w"> </code><code class="n">my_ref</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">buffer</code><code class="p">[</code><code class="mi">4</code><code class="p">..</code><code class="mi">12</code><code class="p">];</code><code class="w"/>

<code class="c1">// Get a copy of a slice</code>
<code class="kd">let</code><code class="w"> </code><code class="n">my_copy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">buffer</code><code class="p">[</code><code class="mi">4</code><code class="p">..</code><code class="mi">12</code><code class="p">].</code><code class="n">to_vec</code><code class="p">();</code><code class="w">  </code><code class="c1">// requires Clone</code></pre>

<p>All of these forms panic if an index is out of bounds.</p>

<p>Rust is picky about numeric types, and it makes no exceptions for vectors. Vector lengths and indices are of type <code>usize</code>. Trying to use a <code>u32</code>, <code>u64</code>, or <code>isize</code> as a vector index is an error. You can use an <code>n as usize</code> cast to convert as needed; see <a data-type="xref" href="ch06.xhtml#type-casts">“Type Casts”</a>.</p>

<p class="pagebreak-before">Several methods provide easy access to particular elements of a vector or slice (note that all slice methods are available on arrays and vectors too):</p>

<ul>
	<li>
	<p><strong><code>slice.first()</code></strong> returns a reference to the first element of <code>slice</code>, if any.</p>

	<p>The return type is <code>Option&lt;&amp;T&gt;</code>, so the return value is <code>None</code> if <code>slice</code> is empty and <code>Some(&amp;slice[0])</code> if it’s not empty.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">item</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">v</code><code class="p">.</code><code class="n">first</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"We got one! {}"</code><code class="p">,</code><code class="w"> </code><code class="n">item</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
	</li>
	<li>
	<p><strong><code>slice.last()</code></strong> is similar but returns a reference to the last element.</p>
	</li>
	<li>
	<p><strong><code>slice.get(index)</code></strong> returns <code>Some</code> reference to <code>slice[index]</code>, if it exists. If <code>slice</code> has fewer than <code>index+1</code> elements, this returns <code>None</code>.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">slice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">slice</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">2</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">slice</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="mi">4</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
	</li>
	<li>
	<p><strong><code>slice.first_mut()</code></strong>, <strong><code>slice.last_mut()</code></strong>, and <strong><code>slice.get_mut(index)</code></strong> are variations of these that borrow <code>mut</code> references.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">slice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">];</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">last</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">slice</code><code class="p">.</code><code class="n">last_mut</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w">   </code><code class="c1">// type of last: &amp;mut i32</code>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="o">*</code><code class="n">last</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">100</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">slice</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">]);</code><code class="w"/></pre>
	</li>
</ul>

<p>Because returning a <code>T</code> by value would mean moving it, methods that access elements in place typically return those elements by reference.</p>

<p>An exception is the <code>.to_vec()</code> method, which makes copies:</p>

<ul>
	<li>
	<p><strong><code>slice.to_vec()</code></strong> clones a whole slice, returning a new vector.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">to_vec</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">]);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">[</code><code class="mi">0</code><code class="p">..</code><code class="mi">6</code><code class="p">].</code><code class="n">to_vec</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">]);</code><code class="w"/></pre>

	<p>This method is available only if the elements are cloneable, that is, <code>where T: Clone</code>.<a contenteditable="false" data-primary="" data-startref="C16-collections.html3" data-type="indexterm" id="idm45251591573016"/></p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Iteration"><div class="sect2" id="slice-iteration">
<h2>Iteration</h2>

<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="iteration" data-type="indexterm" id="idm45251591447640"/>Vectors and slices are iterable, either by value or by reference, following the pattern described in <a data-type="xref" href="ch15.xhtml#intoiterator-implementations">“IntoIterator Implementations”</a>:</p>

<ul>
	<li>
	<p>Iterating over a <code>Vec&lt;T&gt;</code> produces items of type <code>T</code>. The elements are moved out of the vector one by one, consuming it.</p>
	</li>
	<li>
	<p>Iterating over a value of type <code>&amp;[T; N]</code>, <code>&amp;[T]</code>, or <code>&amp;Vec&lt;T&gt;</code>—that is, a reference to an array, slice, or vector—produces items of type <code>&amp;T</code>, references to the individual elements, which are not moved.</p>
	</li>
	<li>
	<p>Iterating over a value of type <code>&amp;mut [T; N]</code>, <code>&amp;mut [T]</code>, or <code>&amp;mut Vec&lt;T&gt;</code> produces items of type <code>&amp;mut T</code>.</p>
	</li>
</ul>

<p>Arrays, slices, and vectors also have <code>.iter()</code> and <code>.iter_mut()</code> methods (described in <a data-type="xref" href="ch15.xhtml#iter-and-iter_mut-methods">“iter and iter_mut Methods”</a>) for creating iterators that produce references to their elements.</p>

<p>We’ll cover some fancier ways to iterate over a slice in <a data-type="xref" href="#splitting">“Splitting”</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Growing and Shrinking Vectors"><div class="sect2" id="growing-and-shrinking-vectors">
<h2>Growing and Shrinking Vectors</h2>

<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="growing/shrinking vectors" data-type="indexterm" id="C16-collections.html4"/>The <em>length</em> of an array, slice, or vector is the number of elements it contains.</p>

<ul>
	<li>
	<p><strong><code>slice.len()</code></strong> returns a <code>slice</code>’s length, as a <code>usize</code>.</p>
	</li>
	<li>
	<p><strong><code>slice.is_empty()</code></strong> is true if <code>slice</code> contains no elements (that is, <code>slice.len() == 0</code>).</p>
	</li>
</ul>

<p>The remaining methods in this section are about growing and shrinking vectors. They are not present on arrays and slices, which can’t be resized once created.</p>

<p>All of a vector’s elements are stored in a contiguous, heap-allocated chunk of memory. <a contenteditable="false" data-primary="capacity of a vector" data-type="indexterm" id="idm45251591423592"/>The <em>capacity</em> of a vector is the maximum number of elements that would fit in this chunk. <code>Vec</code> normally manages the capacity for you, automatically allocating a larger buffer and moving the elements into it when more space is needed. There are also a few methods for managing capacity explicitly:</p>

<ul>
	<li>
	<p><strong><code>Vec::with_capacity(n)</code></strong> creates a new, empty vector with capacity <code>n</code>.</p>
	</li>
	<li>
	<p><strong><code>vec.capacity()</code></strong> returns <code>vec</code>’s capacity, as a <code>usize</code>. It’s always true that <code>vec.capacity() &gt;= vec.len()</code>.</p>
	</li>
	<li>
	<p><strong><code>vec.reserve(n)</code></strong> makes sure the vector has at least enough spare capacity for <code>n</code> more elements: that is, <code>vec.capacity()</code> is at least <code>vec.len() + n</code>. If there’s already enough room, this does nothing. If not, this allocates a larger buffer and moves the vector’s contents into it.</p>
	</li>
	<li>
	<p><strong><code>vec.reserve_exact(n)</code></strong> is like <code>vec.reserve(n)</code>, but tells <code>vec</code> not to allocate any extra capacity for future growth, beyond <code>n</code>. Afterward, <code>vec.capacity()</code> is exactly <code>vec.len() + n</code>.</p>
	</li>
	<li>
	<p><strong><code>vec.shrink_to_fit()</code></strong> tries to free up the extra memory if <code>vec.capacity()</code> is greater than <code>vec.len()</code>.</p>
	</li>
</ul>

<p><code>Vec&lt;T&gt;</code> has many methods that add or remove elements, changing the vector’s length. Each of these takes its <code>self</code> argument by <code>mut</code> reference.</p>

<p>These two methods add or remove a single value at the end of a vector:</p>

<ul>
	<li>
	<p><strong><code>vec.push(value)</code></strong> adds the given <code>value</code> to the end of <code>vec</code>.</p>
	</li>
	<li>
	<p><strong><code>vec.pop()</code></strong> removes and returns the last element. The return type is <code>Option&lt;T&gt;</code>. This returns <code>Some(x)</code> if the popped element is <code>x</code> and <code>None</code> if the vector was already empty.</p>
	</li>
</ul>

<p>Note that <code>.push()</code> takes its argument by value, not by reference. Likewise, <code>.pop()</code> returns the popped value, not a reference. The same is true of most of the remaining methods in this section. They move values in and out of vectors.</p>

<p>These two methods add or remove a value anywhere in a vector:</p>

<ul>
	<li>
	<p><strong><code>vec.insert(index, value)</code></strong> inserts the given <code>value</code> at <code>vec[index]</code>, sliding any existing values in <code>vec[index..]</code> one spot to the right to make room.</p>

	<p>Panics if <code>index &gt; vec.len()</code>.</p>
	</li>
	<li>
	<p><strong><code>vec.remove(index)</code></strong> removes and returns <code>vec[index]</code>, sliding any existing values in <code>vec[index+1..]</code> one spot to the left to close the gap.</p>

	<p>Panics if <code>index &gt;= vec.len()</code>, since in that case there is no element <code>vec[index]</code> to remove.</p>

	<p>The longer the vector, the slower this operation gets. If you find yourself doing <code>vec.remove(0)</code> a lot, consider using a <code>VecDeque</code> (explained in <a data-type="xref" href="#vecdequet">“VecDeque&lt;T&gt;”</a>) instead of a <code>Vec</code>.</p>
	</li>
</ul>

<p>Both <code>.insert()</code> and <code>.remove()</code> are slower the more elements have to be shifted.</p>

<p>Three methods change the length of a vector to a specific value:</p>

<ul>
	<li>
	<p><strong><code>vec.resize(new_len, value)</code></strong> sets <code>vec</code>’s length to <code>new_len</code>. If this increases <code>vec</code>’s length, copies of <code>value</code> are added to fill the new space. The element type must implement the <code>Clone</code> trait.</p>
	</li>
	<li>
	<p><strong><code>vec.truncate(new_len)</code></strong> reduces the length of <code>vec</code> to <code>new_len</code>, dropping any elements that were in the range <code>vec[new_len..]</code>.</p>

	<p>If <code>vec.len()</code> is already less than or equal to <code>new_len</code>, nothing happens.</p>
	</li>
	<li>
	<p><strong><code>vec.clear()</code></strong> removes all elements from <code>vec</code>. It’s the same as <code>vec.truncate(0)</code>.</p>
	</li>
</ul>

<p>Four methods add or remove many values at once:</p>

<ul>
	<li>
	<p><strong><code>vec.extend(iterable)</code></strong> adds all items from the given <code>iterable</code> value at the end of <code>vec</code>, in order. It’s like a multivalue version of <code>.push()</code>. The <code>iterable</code> argument can be anything that implements <code>IntoIterator&lt;Item=T&gt;</code>.</p>

	<p>This method is so useful that there’s a standard trait for it, the <code>Extend</code> trait, which all standard collections implement. Unfortunately, this causes <code>rustdoc</code> to lump <code>.extend()</code> with other trait methods in a big pile at the bottom of the generated HTML, so it’s hard to find when you need it. You just have to remember it’s there! See <a data-type="xref" href="ch15.xhtml#the-extend-trait">“The Extend Trait”</a> for more.</p>
	</li>
	<li>
	<p><strong><code>vec.split_off(index)</code></strong> is like <code>vec.truncate(index)</code>, except that it returns a <code>Vec&lt;T&gt;</code> containing the values removed from the end of <code>vec</code>. It’s like a multivalue version of <code>.pop()</code>.</p>
	</li>
	<li>
	<p><strong><code>vec.append(&amp;mut vec2)</code></strong>, where <code>vec2</code> is another vector of type <code>Vec&lt;T&gt;</code>, moves all elements from <code>vec2</code> into <code>vec</code>. Afterward, <code>vec2</code> is empty.</p>

	<p>This is like <code>vec.extend(vec2)</code> except that <code>vec2</code> still exists afterward, with its capacity unaffected.</p>
	</li>
	<li>
	<p><strong><code>vec.drain(range)</code></strong>, where <code>range</code> is a range value, like <code>..</code> or <code>0..4</code>, removes the range <code>vec[range]</code> from <code>vec</code> and returns an iterator over the removed elements.</p>
	</li>
</ul>

<p>There are also a few oddball methods for selectively removing some of a vector’s <span class="keep-together">elements:</span></p>

<ul>
	<li>
	<p><strong><code>vec.retain(test)</code></strong> removes all elements that don’t pass the given test. The <code>test</code> argument is a function or closure that implements <code>FnMut(&amp;T) -&gt; bool</code>. For each element of <code>vec</code>, this calls <code>test(&amp;element)</code>, and if it returns <code>false</code>, the element is removed from the vector and dropped.</p>

	<p>Apart from performance, this is like writing:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="p">.</code><code class="n">into_iter</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="n">test</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"/></pre>
	</li>
	<li>
	<p><strong><code>vec.dedup()</code></strong> drops repeated elements. It’s like the Unix <code>uniq</code> shell utility. It scans <code>vec</code> for places where adjacent elements are equal and drops the extra equal values, so that only one is left:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">byte_vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"Misssssssissippi"</code><code class="p">.</code><code class="n">to_vec</code><code class="p">();</code><code class="w"/>
<code class="n">byte_vec</code><code class="p">.</code><code class="n">dedup</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">byte_vec</code><code class="p">,</code><code class="w"> </code><code class="s">b"Misisipi"</code><code class="p">);</code><code class="w"/></pre>

	<p>Note that there are still two <code>'s'</code>’s in the output. This method only removes <em>adjacent</em> duplicates. To eliminate all duplicates, you have three options: sort the vector before calling <code>.dedup()</code>; move the data into a set; or (to keep the elements in their original order) use this <code>.retain()</code> trick:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">byte_vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"Misssssssissippi"</code><code class="p">.</code><code class="n">to_vec</code><code class="p">();</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">seen</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashSet</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">byte_vec</code><code class="p">.</code><code class="n">retain</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">seen</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="o">*</code><code class="n">r</code><code class="p">));</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">byte_vec</code><code class="p">,</code><code class="w"> </code><code class="s">b"Misp"</code><code class="p">);</code><code class="w"/></pre>

	<p>This works because <code>.insert()</code> returns <code>false</code> when the set already contains the item we’re inserting.</p>
	</li>
	<li>
	<p><strong><code>vec.dedup_by(same)</code></strong> is the same as <code>vec.dedup()</code>, but it uses the function or closure <code>same(&amp;mut elem1, &amp;mut elem2)</code>, instead of the <code>==</code> operator, to check whether two elements should be considered equal.</p>
	</li>
	<li>
	<p><strong><code>vec.dedup_by_key(key)</code></strong> is the same as <code>vec.dedup()</code>, but it treats two elements as equal if <code>key(&amp;mut elem1) == key(&amp;mut elem2)</code>.</p>

	<p>For example, if <code>errors</code> is a <code>Vec&lt;Box&lt;Error&gt;&gt;</code>, you can write:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Remove errors with redundant messages.</code>
<code class="n">errors</code><code class="p">.</code><code class="n">dedup_by_key</code><code class="p">(</code><code class="o">|</code><code class="n">err</code><code class="o">|</code><code class="w"> </code><code class="n">err</code><code class="p">.</code><code class="n">description</code><code class="p">().</code><code class="n">to_string</code><code class="p">());</code><code class="w"/></pre>
	</li>
</ul>

<p>Of all the methods covered in this section, only <code>.resize()</code> ever clones values. The others work by moving values from one place to another.<a contenteditable="false" data-primary="" data-startref="C16-collections.html4" data-type="indexterm" id="idm45251591142232"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Joining"><div class="sect2" id="joining">
<h2>Joining</h2>

<p><a contenteditable="false" data-primary="arrays of arrays" data-type="indexterm" id="idm45251591139816"/><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="joining" data-type="indexterm" id="idm45251591138712"/>Two methods work on <em>arrays of arrays</em>, by which we mean any array, slice, or vector whose elements are themselves arrays, slices, or vectors.</p>

<ul>
	<li>
	<p><strong><code>slices.concat()</code></strong> returns a new vector made by concatenating all the slices.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">],</code><code class="w"> </code><code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">],</code><code class="w"> </code><code class="p">[</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">]].</code><code class="n">concat</code><code class="p">(),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">]);</code><code class="w"/></pre>
	</li>


	<li>
	<p><strong><code>slices.join(&amp;separator)</code></strong> is the same, except a copy of the value <code>separator</code> is inserted between slices:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">],</code><code class="w"> </code><code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">],</code><code class="w"> </code><code class="p">[</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">]].</code><code class="n">join</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">0</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">]);</code><code class="w"/></pre>
	</li>
</ul>
</div></section>

<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Splitting"><div class="sect2" id="splitting">
<h2>Splitting</h2>

<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="splitting" data-type="indexterm" id="C16-collections.html5"/>It’s easy to get many non-<code>mut</code> references into an array, slice, or vector at once:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">[</code><code class="n">j</code><code class="p">];</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">mid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">v</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">front_half</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">[..</code><code class="n">mid</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">back_half</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">[</code><code class="n">mid</code><code class="p">..];</code><code class="w"/></pre>

<p>Getting multiple <code>mut</code> references is not so easy:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="p">[</code><code class="n">j</code><code class="p">];</code><code class="w">  </code><code class="c1">// error: cannot borrow `v` as mutable</code>
<code class="w">                    </code><code class="c1">//        more than once at a time</code></pre>

<p>Rust forbids this because if <code>i == j</code>, then <code>a</code> and <code>b</code> would be two <code>mut</code> references to the same integer, in violation of Rust’s safety rules. (See <a data-type="xref" href="ch05.xhtml#sharing-versus-mutation">“Sharing Versus Mutation”</a>.)</p>

<p>Rust has several methods that can borrow <code>mut</code> references to two or more parts of an array, slice, or vector at once. Unlike the code above, these methods are safe, because by design, they split the data into <em>nonoverlapping</em> regions. Many of these methods are also handy for working with non-<code>mut</code> slices, so there are <code>mut</code> and non-<code>mut</code> versions of each.</p>

<p><a data-type="xref" href="#splitting-method-figure">Figure 16-2</a> illustrates these methods. None of them directly modify an array, slice, or vector; they merely return new references to parts of the data inside.</p>

<ul>
	<li>
	<p><strong><code>slice.iter()</code></strong> and <strong><code>slice.iter_mut()</code></strong> produce a reference to each element of <code>slice</code>. We covered them in <a data-type="xref" href="#slice-iteration">“Iteration”</a>.</p>
	</li>
	<li>
	<p><strong><code>slice.split_at(index)</code></strong> and <strong><code>slice.split_at_mut(index)</code></strong> break a slice in two, returning a pair. <code>slice.split_at(index)</code> is equivalent to <code>(&amp;slice[..index], &amp;slice[index..])</code>. These methods panic if <code>index</code> is out of bounds.</p>
	</li>
	<li>
	<p><strong><code>slice.split_first()</code></strong> and <strong><code>slice.split_first_mut()</code></strong> also return a pair: a reference to the first element (<code>slice[0]</code>) and a slice reference to all the rest (<code>slice[1..]</code>).</p>

	<p>The return type of <code>.split_first()</code> is <code>Option&lt;(&amp;T, &amp;[T])&gt;</code>; the result is <code>None</code> if <code>slice</code> is empty.</p>
	</li>
	<li>
	<p><strong><code>slice.split_last()</code></strong> and <strong><code>slice.split_last_mut()</code></strong> are analogous but split off the last element rather than the first.</p>

	<p>The return type of <code>.split_last()</code> is <code>Option&lt;(&amp;T, &amp;[T])&gt;</code>.</p>
	</li>
	<li>
	<p><strong><code>slice.split(is_sep)</code></strong> and <strong><code>slice.split_mut(is_sep)</code></strong> split <code>slice</code> into one or more subslices, using the function or closure <code>is_sep</code> to figure out where to split. They return an iterator over the subslices.</p>

	<p>As you consume the iterator, it calls <code>is_sep(&amp;element)</code> for each element in the slice. If <code>is_sep(&amp;element)</code> is <code>true</code>, the element is a separator. Separators are not included in any output subslice.</p>

	<p>The output always contains at least one subslice, plus one per separator. Empty subslices are included whenever separators appear adjacent to each other or to the ends of <code>slice</code>.</p>
	</li>
	<li>
	<p><strong><code>slice.splitn(n, is_sep)</code></strong> and <strong><code>slice.splitn_mut(n, is_sep)</code></strong> are the same, but they produce at most <code>n</code> subslices. After the first <code>n-1</code> slices are found, <code>is_sep</code> is not called again. The last subslice contains all the remaining elements.</p>
	</li>
	<li>
	<p><strong><code>slice.rsplitn(n, is_sep)</code></strong> and <strong><code>slice.rsplitn_mut(n, is_sep)</code></strong> are just like <code>.splitn()</code> and <code>.splitn_mut()</code> except that the slice is scanned in reverse order. That is, these methods split on the <em>last</em> <code>n-1</code> separators in the slice, rather than the first, and the subslices are produced starting from the end.</p>
	</li>
	<li>
	<p><strong><code>slice.chunks(n)</code></strong> and <strong><code>slice.chunks_mut(n)</code></strong> return an iterator over non-overlapping subslices of length <code>n</code>.</p>

	<p>If <code>slice.len()</code> is not a multiple of <code>n</code>, then the last subslice will have a length less than <code>n</code>.</p>
	</li>
</ul>

<figure><div id="splitting-method-figure" class="figure"><img src="Images/rust_1602.png" alt="(The illustration shows an array of integers and the output of various split methods,           using long horizontal bars to represent slice references in the output.           The output of the &quot;windows&quot; method looks like steps;           the other methods always produce non-overlapping slices,           so each method's output is shown as a single bar, broken in various places.)" width="1163" height="840"/>
<h6><span class="label">Figure 16-2. </span>Splitting methods illustrated. The little rectangle in the output of slice.split() is an empty slice, caused by the two adjacent separators. Also note that rsplitn produces its output in end-to-start order, unlike all the others.</h6>
</div></figure>

<p class="pagebreak-before">There’s one more method for iterating over subslices:</p>

<ul>
	<li>
	<p><strong><code>slice.windows(n)</code></strong> returns an iterator that behaves like a “sliding window” over the data in <code>slice</code>. It produces subslices that span <code>n</code> consecutive elements of <code>slice</code>. The first value produced is <code>&amp;slice[0..n]</code>; the second is <code>&amp;slice[1..n+1]</code>; and so on.</p>

	<p>If <code>n</code> is greater than the length of <code>slice</code>, then no slices are produced. If <code>n</code> is 0, the method panics.</p>

	<p>For example, if <code>days.len() == 31</code>, then we can produce all seven-day spans in <code>days</code> by calling <code>days.windows(7)</code>.</p>

	<p>A sliding window of size 2 is handy for exploring how a data series changes from one data point to the next:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">changes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">daily_high_temperatures</code><code class="w"/>
<code class="w">                  </code><code class="p">.</code><code class="n">windows</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code class="w">             </code><code class="c1">// get adjacent days' temps</code>
<code class="w">                  </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">w</code><code class="o">|</code><code class="w"> </code><code class="n">w</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">w</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code><code class="w">   </code><code class="c1">// how much did it change?</code>
<code class="w">                  </code><code class="p">.</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">();</code><code class="w"/></pre>

	<p>Because the subslices overlap, there is no variation of this method that returns <code>mut</code> references.<a contenteditable="false" data-primary="" data-startref="C16-collections.html5" data-type="indexterm" id="idm45251590614200"/></p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Swapping"><div class="sect2" id="swapping">
<h2>Swapping</h2>

<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="swapping" data-type="indexterm" id="idm45251590611112"/>There’s a convenience method for swapping two elements:</p>

<ul>
	<li><strong><code>slice.swap(i, j)</code></strong> swaps the two elements <code>slice[i]</code> and <code>slice[j]</code>.</li>
</ul>

<p>Vectors have a related method for efficiently removing any element:</p>

<ul>

	<li><strong><code>vec.swap_remove(i)</code></strong> removes and returns <code>vec[i]</code>. This is like <code>vec.remove(i)</code> except that instead of sliding the rest of the vector’s elements over to close the gap, it simply moves <code>vec</code>’s last element into the gap. It’s useful when you don’t care about the order of the items left in the vector.</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Sorting and Searching"><div class="sect2" id="sorting-and-searching">
<h2>Sorting and Searching</h2>

<p><a contenteditable="false" data-primary="slices" data-secondary="sorting" data-type="indexterm" id="idm45251590602280"/><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="sorting" data-type="indexterm" id="idm45251590600904"/>Slices offer three methods for sorting:</p>

<ul>

	<li>
	<p><strong><code>slice.sort()</code></strong> sorts the elements into increasing order. This method is present only when the element type implements <code>Ord</code>.</p>
	</li>
	<li>
	<p><strong><code>slice.sort_by(cmp)</code></strong> sorts the elements of <code>slice</code> using a function or closure <code>cmp</code> to specify the sort order. <code>cmp</code> must implement <code>Fn(&amp;T, &amp;T) -&gt; std::cmp::Ordering</code>.</p>

	<p>Hand-implementing <code>cmp</code> is a pain, unless you delegate to a <code>.cmp()</code> method:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">students</code><code class="p">.</code><code class="n">sort_by</code><code class="p">(</code><code class="o">|</code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">b</code><code class="o">|</code><code class="w"> </code><code class="n">a</code><code class="p">.</code><code class="n">last_name</code><code class="p">.</code><code class="n">cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="n">b</code><code class="p">.</code><code class="n">last_name</code><code class="p">));</code><code class="w"/></pre>

	<p>To sort by one field, using a second field as a tiebreaker, compare tuples:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">students</code><code class="p">.</code><code class="n">sort_by</code><code class="p">(</code><code class="o">|</code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">b</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">a_key</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="o">&amp;</code><code class="n">a</code><code class="p">.</code><code class="n">last_name</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">a</code><code class="p">.</code><code class="n">first_name</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">b_key</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="o">&amp;</code><code class="n">b</code><code class="p">.</code><code class="n">last_name</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">b</code><code class="p">.</code><code class="n">first_name</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">a_key</code><code class="p">.</code><code class="n">cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="n">b_key</code><code class="p">)</code><code class="w"/>
<code class="p">});</code><code class="w"/></pre>
	</li>
	<li>
	<p><strong><code>slice.sort_by_key(key)</code></strong> sorts the elements of <code>slice</code> into increasing order by a sort key, given by the function or closure <code>key</code>. The type of <code>key</code> must implement <code>Fn(&amp;T) -&gt; K</code> where <code>K: Ord</code>.</p>

	<p>This is useful when <code>T</code> contains one or more ordered fields, so that it could be sorted multiple ways.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Sort by grade point average, lowest first.</code>
<code class="n">students</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="o">|</code><code class="n">s</code><code class="o">|</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">grade_point_average</code><code class="p">());</code><code class="w"/></pre>

	<p>Note that these sort-key values are not cached during sorting, so the <code>key</code> function may be called more than <em>n</em> times.</p>

	<p>For technical reasons, <code>key(element)</code> can’t return any references borrowed from the element. This won’t work:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">students</code><code class="p">.</code><code class="n">sort_by_key</code><code class="p">(</code><code class="o">|</code><code class="n">s</code><code class="o">|</code><code class="w"> </code><code class="o">&amp;</code><code class="n">s</code><code class="p">.</code><code class="n">last_name</code><code class="p">);</code><code class="w">  </code><code class="c1">// error: can't infer lifetime</code></pre>

	<p>Rust can’t figure out the lifetimes. But in these cases, it’s easy enough to fall back on <code>.sort_by()</code>.</p>
	</li>
</ul>

<p>All three methods perform a stable sort.</p>

<p>To sort in reverse order, you can use <code>sort_by</code> with a <code>cmp</code> closure that swaps the two arguments. Taking arguments <code>|b, a|</code> rather than <code>|a, b|</code> effectively produces the opposite order. Or, you can just call the <code>.reverse()</code> method after sorting:</p>

<ul>
	<li><strong><code>slice.reverse()</code></strong> reverses a slice in place.</li>
</ul>

<p><a contenteditable="false" data-primary="slices" data-secondary="searching" data-type="indexterm" id="idm45251590355640"/><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="searching" data-type="indexterm" id="idm45251590354264"/>Once a slice is sorted, it can be efficiently searched:</p>

<ul>
	<li>
	<p><strong><code>slice.binary_search(&amp;value)</code></strong>, <strong><code>slice.binary_search_by(&amp;value, cmp)</code></strong>, and <strong><code>slice.binary_search_by_key(&amp;value, key)</code></strong> all search for <code>value</code> in the given sorted <code>slice</code>. Note that <code>value</code> is passed by reference.</p>

	<p>The return type of these methods is <code>Result&lt;usize, usize&gt;</code>. They return <code>Ok(index)</code> if <code>slice[index]</code> equals <code>value</code> under the specified sort order. If there is no such index, then they return <code>Err(insertion_point)</code> such that inserting <code>value</code> at <code>insertion_point</code> would preserve the order.</p>
	</li>
</ul>

<p>Of course, a binary search only works if the slice is in fact sorted in the specified order. Otherwise, the results are arbitrary—garbage in, garbage out.</p>

<p>Since <code>f32</code> and <code>f64</code> have NaN values, they do not implement <code>Ord</code>, and can’t be used directly as keys with the sorting and binary search methods. To get similar methods that work on floating-point data, use the <code>ord_subset</code> crate.</p>

<p>There’s one method for searching a vector that is not sorted:</p>

<ul>
	<li><strong><code>slice.contains(&amp;value)</code></strong> returns <code>true</code> if any element of <code>slice</code> is equal to <code>value</code>. This simply checks each element of the slice until a match is found. Again, <code>value</code> is passed by reference.</li>
</ul>

<p>To find the location of a value in a slice, like <code>array.indexOf(value)</code> in JavaScript, use an iterator:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">slice</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">position</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/></pre>

<p>This returns an <code>Option&lt;usize&gt;</code>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Comparing Slices"><div class="sect2" id="comparing-slices">
<h2>Comparing Slices</h2>

<p><a contenteditable="false" data-primary="slices" data-secondary="comparing" data-type="indexterm" id="idm45251590311032"/><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="comparing slices" data-type="indexterm" id="idm45251590309432"/>If a type <code>T</code> supports the <code>==</code> and <code>!=</code> operators (the <code>PartialEq</code> trait, described in <a data-type="xref" href="ch12.xhtml#eq">“Equality Tests”</a>), then arrays <code>[T; N]</code>, slices <code>[T]</code>, and vectors <code>Vec&lt;T&gt;</code> support them too. Two slices are equal if they’re the same length and their corresponding elements are equal. The same goes for arrays and vectors.</p>

<p>If <code>T</code> supports the operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> (the <code>PartialOrd</code> trait, described in <a data-type="xref" href="ch12.xhtml#ord">“Ordered Comparisons”</a>), then arrays, slices, and vectors of <code>T</code> do too. Slice comparisons are lexicographical.</p>

<p>Two convenience methods perform common slice comparisons:</p>

<ul>
	<li>
	<p><strong><code>slice.starts_with(other)</code></strong> returns <code>true</code> if <code>slice</code> starts with a sequence of values that are equal to the elements of the slice <code>other</code>:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">].</code><code class="n">starts_with</code><code class="p">(</code><code class="o">&amp;</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">]),</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">].</code><code class="n">starts_with</code><code class="p">(</code><code class="o">&amp;</code><code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">]),</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/></pre>
	</li>
	<li>
	<p><strong><code>slice.ends_with(other)</code></strong> is similar but checks the end of <code>slice</code>:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">].</code><code class="n">ends_with</code><code class="p">(</code><code class="o">&amp;</code><code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">]),</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/></pre>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Random Elements"><div class="sect2" id="random-elements">
<h2>Random Elements</h2>

<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="random elements" data-type="indexterm" id="idm45251590131640"/>Random numbers are not built into the Rust standard library. The <code>rand</code> crate, which provides them, offers these two methods for getting random output from an array, slice, or vector:</p>

<ul>
	<li>
	<p><strong><code>rng.choose(slice)</code></strong> returns a reference to a random element of a slice. Like <code>slice.first()</code> and <code>slice.last()</code>, this returns an <code>Option&lt;&amp;T&gt;</code> that is <code>None</code> only if the slice is empty.</p>
	</li>
	<li>
	<p><strong><code>rng.shuffle(slice)</code></strong> randomly reorders the elements of a slice in place. The slice must be passed by <code>mut</code> reference.</p>
	</li>
</ul>

<p>These are methods of the <code>rand::Rng</code> trait, so you need a <code>Rng</code>, a random number generator, in order to call them. Fortunately it’s easy to get one by calling <code>rand::thread_rng()</code>. To shuffle the vector <code>my_vec</code>, we can write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">rand</code>::<code class="p">{</code><code class="n">Rng</code><code class="p">,</code><code class="w"> </code><code class="n">thread_rng</code><code class="p">};</code><code class="w"/>

<code class="n">thread_rng</code><code class="p">().</code><code class="n">shuffle</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">my_vec</code><code class="p">);</code><code class="w"/></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Rust Rules Out Invalidation Errors"><div class="sect2" id="rust-rules-out-invalidation-errors">
<h2>Rust Rules Out Invalidation Errors</h2>

<p><a contenteditable="false" data-primary="invalidation errors" data-type="indexterm" id="idm45251590097400"/><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-secondary="invalidation errors" data-type="indexterm" id="idm45251590096328"/>Most mainstream programming languages have collections and iterators, and they all have some variation on this rule: don’t modify a collection while you’re iterating over it. For example, the Python equivalent of a vector is a list:</p>

<pre class="python" data-type="programlisting" data-code-language="python"><code class="n">my_list</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">9</code><code class="p">]</code></pre>

<p>Suppose we try to remove all values greater than 4 from <code>my_list</code>:</p>

<pre class="python" data-type="programlisting" data-code-language="python"><code class="k">for</code> <code class="n">index</code><code class="p">,</code> <code class="n">val</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">my_list</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">val</code> <code class="o">&gt;</code> <code class="mi">4</code><code class="p">:</code>
        <code class="k">del</code> <code class="n">my_list</code><code class="p">[</code><code class="n">index</code><code class="p">]</code>  <code class="c1"># bug: modifying list while iterating</code>

<code class="k">print</code><code class="p">(</code><code class="n">my_list</code><code class="p">)</code></pre>

<p>(The <code>enumerate</code> function is Python’s equivalent of Rust’s <code>.enumerate()</code> method, described in <a data-type="xref" href="ch15.xhtml#enumerate">“enumerate”</a>.)</p>

<p>This program, surprisingly, prints <code>[1, 3, 7]</code>. But seven is greater than four. How did that slip through? This is an invalidation error: the program modifies data while iterating over it, <em>invalidating</em> the iterator. In Java, the result would be an exception; in <span class="keep-together">C++</span>, undefined behavior. In Python, while the behavior is well-defined, it’s unintuitive: the iterator skips an element. <code>val</code> is never <code>7</code>.</p>

<p>Let’s try to reproduce this bug in Rust:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">my_vec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">];</code><code class="w"/>

<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">index</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">val</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">my_vec</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">enumerate</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">val</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">4</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">my_vec</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="n">index</code><code class="p">);</code><code class="w">  </code><code class="c1">// error: can't borrow `my_vec` as mutable</code>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">my_vec</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Naturally, Rust rejects this program at compile time. When we call <code>my_vec.iter()</code>, it borrows a shared (non-<code>mut</code>) reference to the vector. The reference lives as long as the iterator, to the end of the <code>for</code> loop. We can’t modify the vector by calling <code>my_vec.remove(index)</code> while a non-<code>mut</code> reference exists.</p>

<p>Having an error pointed out to you is nice, but of course, you still need to find a way to get the desired behavior! The easiest fix here is to write:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="n">my_vec</code><code class="p">.</code><code class="n">retain</code><code class="p">(</code><code class="o">|&amp;</code><code class="n">val</code><code class="o">|</code><code class="w"> </code><code class="n">val</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w"/></pre>

<p>Or, you can do what you’d do in Python or any other language: create a new vector using a <code>filter</code>.<a contenteditable="false" data-primary="" data-startref="C16-collections.html2" data-type="indexterm" id="idm45251589861528"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html1" data-type="indexterm" id="idm45251589860248"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="VecDeque&lt;T&gt;"><div class="sect1" id="vecdequet">
<h1>VecDeque&lt;T&gt;</h1>

<p><a contenteditable="false" data-primary="collections" data-secondary="VecDeque&lt;T&gt;" data-type="indexterm" id="C16-collections.html6"/><a contenteditable="false" data-primary="VecDeque&lt;T&gt; collection type" data-secondary="about" data-type="indexterm" id="C16-collections.html7"/><code>Vec</code> supports efficiently adding and removing elements only at the end. When a program needs a place to store values that are “waiting in line,” <code>Vec</code> can be slow.</p>

<p><a contenteditable="false" data-primary="deque" data-seealso="VecDeque&lt;T&gt; collection type" data-type="indexterm" id="idm45251589840872"/>Rust’s <code>std::collections::VecDeque&lt;T&gt;</code> is a <em>deque</em> (pronounced “deck”), a double-ended queue. It supports efficient add and remove operations at both the front and the back.</p>

<ul>
	<li>
	<p><strong><code>deque.push_front(value)</code></strong> adds a value at the front of the queue.</p>
	</li>
	<li>
	<p><strong><code>deque.push_back(value)</code></strong> adds a value at the end. (This method is used much more than <code>.push_front()</code>, because the usual convention for queues is that values are added at the back and removed at the front, like people waiting in a line.)</p>
	</li>
	<li>
	<p><strong><code>deque.pop_front()</code></strong> removes and returns the front value of the queue, returning an <code>Option&lt;T&gt;</code> that is <code>None</code> if the queue is empty, like <code>vec.pop()</code>.</p>
	</li>
	<li>
	<p><strong><code>deque.pop_back()</code></strong> removes and returns the value at the back, again returning an <code>Option&lt;T&gt;</code>.</p>
	</li>
	<li>
	<p><strong><code>deque.front()</code></strong> and <strong><code>deque.back()</code></strong> work like <code>vec.first()</code> and <code>vec.last()</code>. They return a reference to the front or back element of the queue. The return value is an <code>Option&lt;&amp;T&gt;</code> that is <code>None</code> if the queue is empty.</p>
	</li>
	<li>
	<p><strong><code>deque.front_mut()</code></strong> and <strong><code>deque.back_mut()</code></strong> work like <code>vec.first_mut()</code> and <code>vec.last_mut()</code>, returning <code>Option&lt;&amp;mut T&gt;</code>.</p>
	</li>
</ul>

<p>The implementation of <code>VecDeque</code> is a ring buffer, as shown in <a data-type="xref" href="#vec-deque-layout-figure">Figure 16-3</a>.</p>

<p>Like a <code>Vec</code>, it has a single heap allocation where elements are stored. Unlike <code>Vec</code>, the data does not always start at the beginning of this region, and it can “wrap around” the end, as shown. The elements of this deque, in order, are <code>['A', 'B', 'C', 'D', 'E']</code>. <code>VecDeque</code> has private fields, labeled <code>start</code> and <code>stop</code> in the figure, that it uses to remember where in the buffer the data begins and ends.</p>

<p>Adding a value to the queue, on either end, means claiming one of the unused slots, shown in dark gray, wrapping around or allocating a bigger chunk of memory if needed.</p>

<p><code>VecDeque</code> manages wrapping, so you don’t have to think about it. <a data-type="xref" href="#vec-deque-layout-figure">Figure 16-3</a> is a behind-the-scenes view of how Rust makes <code>.pop_front()</code> fast.</p>

<figure><div id="vec-deque-layout-figure" class="figure"><img src="Images/rust_1603.png" alt="(An illustration of a VecDeque of characters.           The deque's heap storage contains the characters 'D' and 'E',           then a gap of three char-sized slots, then the characters 'A', 'B', and 'C'.           In addition to the buffer pointer and size,           VecDeque has two more integer fields, &quot;start&quot; and &quot;stop&quot;,           that tell where the data is within the buffer.           &quot;start&quot; is the index of the front element, 'A'.           &quot;stop&quot; is the index of the gap immediately following the back element, 'E'.)" width="1050" height="595"/>
<h6><span class="label">Figure 16-3. </span>How a VecDeque is stored in memory</h6>
</div></figure>

<p>Often, when you need a deque, <code>.push_back()</code> and <code>.pop_front()</code> are the only two methods you need. The static methods <code>VecDeque::new()</code> and <code>VecDeque::with​_capacity(n)</code>, for creating queues, are just like their counterparts in <code>Vec</code>. Many <code>Vec</code> methods are also implemented for <code>VecDeque</code>: <code>.len()</code> and <code>.is_empty()</code>, <code>.insert(index, value)</code> and <code>.remove(index)</code>, <code>.extend(iterable)</code>, and so on.</p>

<p>Deques, like vectors, can be iterated by value, by shared reference, or by <code>mut</code> reference. They have the three iterator methods <code>.into_iter()</code>, <code>.iter()</code>, and <code>.iter_mut()</code>. They can be indexed in the usual way: <code>deque[index]</code>.</p>

<p>However, because deques don’t store their elements contiguously in memory, they don’t inherit all the methods of slices. One way to perform vector and slice operations on deque data is to convert the <code>VecDeque</code> to a <code>Vec</code>, do the operation, and then change it back:</p>

<ul>
	<li>
	<p><code>Vec&lt;T&gt;</code> implements <code>From&lt;VecDeque&lt;T&gt;&gt;</code>, so <strong><code>Vec::from(deque)</code></strong> turns a deque into a vector. This costs O(<em>n</em>) time, since it may require rearranging the elements.</p>
	</li>
	<li>
	<p><code>VecDeque&lt;T&gt;</code> implements <code>From&lt;Vec&lt;T&gt;&gt;</code>, so <strong><code>VecDeque::from(vec)</code></strong> turns a vector into a deque. This is also O(<em>n</em>), but it’s usually fast, even if the vector is large, because the vector’s heap allocation can simply be moved to the new deque.</p>

	<p>This method makes it easy to create a deque with specified elements, even though there is no standard <code>vec_deque![]</code> macro:<a contenteditable="false" data-primary="" data-startref="C16-collections.html7" data-type="indexterm" id="idm45251589759320"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html6" data-type="indexterm" id="idm45251589757912"/></p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">VecDeque</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">VecDeque</code>::<code class="n">from</code><code class="p">(</code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">]);</code><code class="w"/></pre>
	</li>
</ul>
</div></section>

<section data-type="sect1" data-pdf-bookmark="LinkedList&lt;T&gt;"><div class="sect1" id="linkedlistt">
<h1>LinkedList&lt;T&gt;</h1>

<p><a contenteditable="false" data-primary="collections" data-secondary="LinkedList&lt;T&gt;" data-type="indexterm" id="idm45251589718008"/><a contenteditable="false" data-primary="LinkedList&lt;T&gt; collection type" data-secondary="about" data-type="indexterm" id="idm45251589716632"/>A <em>linked list</em> is another way to store a sequence of values. Each value is stored in a separate heap allocation, as shown in <a data-type="xref" href="#linked-list-layout-figure">Figure 16-4</a>.</p>

<figure><div id="linked-list-layout-figure" class="figure"><img src="Images/rust_1604.png" alt="(An illustration of a linked list.           Each element is stored in separately-allocated &quot;nodes&quot; in the heap.           In addition to the value itself, each node contains a pointer to its two neighbors:           the previous node and the next node in the list.)" width="1272" height="583"/>
<h6><span class="label">Figure 16-4. </span>A LinkedList&lt;char&gt; in memory</h6>
</div></figure>

<p><code>std::collections::LinkedList&lt;T&gt;</code> is a doubly linked list for Rust. It supports a subset of <code>VecDeque</code>’s methods. The methods that operate on the <code>front</code> and <code>back</code> of the sequence are all there; so are iterator methods, <code>LinkedList::new()</code>, and a few others. Methods that access elements by index, though, are generally omitted, since it’s inherently inefficient to access linked list elements by index.</p>

<p>As of Rust 1.17, Rust’s <code>LinkedList</code> type has no methods for removing a range of elements from a list or inserting elements at specific locations in a list. The API seems incomplete.</p>

<p><a contenteditable="false" data-primary="VecDeque&lt;T&gt; collection type" data-secondary="LinkedList&lt;T&gt; vs." data-type="indexterm" id="idm45251589707752"/>For now, the main advantage of <code>LinkedList</code> over <code>VecDeque</code> is that combining two lists is very fast. <code>list.append(&amp;mut list2)</code>, the method that moves all elements from one list to another, only involves changing a few pointers, which can be done in constant time. The <code>append</code> methods of <code>Vec</code> and <code>VecDeque</code> sometimes have to move many values from one heap array to another.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="BinaryHeap&lt;T&gt;"><div class="sect1" id="binaryheapt">
<h1>BinaryHeap&lt;T&gt;</h1>

<p><a contenteditable="false" data-primary="BinaryHeap&lt;T&gt; collection type" data-secondary="about" data-type="indexterm" id="idm45251589701448"/><a contenteditable="false" data-primary="collections" data-secondary="BinaryHeap&lt;T&gt;" data-type="indexterm" id="idm45251589700104"/>A <code>BinaryHeap</code> is a collection whose elements are kept loosely organized so that the greatest value always bubbles up to the front of the queue. Here are the three most commonly used <code>BinaryHeap</code> methods:</p>

<ul>
	<li>
	<p><strong><code>heap.push(value)</code></strong> adds a value to the heap.</p>
	</li>
	<li>
	<p><strong><code>heap.pop()</code></strong> removes and returns the greatest value from the heap. It returns an <code>Option&lt;T&gt;</code> that is <code>None</code> if the heap was empty.</p>
	</li>
	<li>
	<p><strong><code>heap.peek()</code></strong> returns a reference to the greatest value in the heap. The return type is <code>Option&lt;&amp;T&gt;</code>.</p>
	</li>
</ul>

<p><code>BinaryHeap</code> also supports a subset of the methods on <code>Vec</code>, including <code>BinaryHeap::new()</code>, <code>.len()</code>, <code>.is_empty()</code>, <code>.capacity()</code>, <code>.clear()</code>, and <code>.append(&amp;mut heap2)</code>.</p>



<p>For example, if we populate a <code>BinaryHeap</code> with a bunch of numbers:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">BinaryHeap</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">heap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BinaryHeap</code>::<code class="n">from</code><code class="p">(</code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">]);</code><code class="w"/></pre>

<p>then the value <code>9</code> is at the top of the heap:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">heap</code><code class="p">.</code><code class="n">peek</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">9</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">heap</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">9</code><code class="p">));</code><code class="w"/></pre>

<p>Removing the value <code>9</code> also rearranges the other elements slightly so that <code>8</code> is now at the front, and so on:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">heap</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">8</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">heap</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">6</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">heap</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">5</code><code class="p">));</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre>

<p>Of course, <code>BinaryHeap</code> is not limited to numbers. It can hold any type of value that implements the <code>Ord</code> built-in trait.</p>

<p>This makes <code>BinaryHeap</code> useful as a work queue. You can define a task struct that implements <code>Ord</code> on the basis of priority, so that higher-priority tasks are <code>Greater</code> than lower-priority tasks. Then, create a <code>BinaryHeap</code> to hold all pending tasks. Its <code>.pop()</code> method will always return the most important item, the task your program should work on next.</p>

<p>Note: <code>BinaryHeap</code> is iterable, and it has an <code>.iter()</code> method, but the iterators produce the heap’s elements in an arbitrary order, not from greatest to least. To consume values from a <code>BinaryHeap</code> in order of priority, use a <code>while</code> loop:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">while</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">task</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">heap</code><code class="p">.</code><code class="n">pop</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">handle</code><code class="p">(</code><code class="n">task</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="HashMap&lt;K, V&gt; and BTreeMap&lt;K, V&gt;"><div class="sect1" id="hashmapk-v-and-btreemapk-v">
<h1>HashMap&lt;K, V&gt; and BTreeMap&lt;K, V&gt;</h1>

<p><a contenteditable="false" data-primary="BTreeMap&lt;K, V&gt; collection type" data-secondary="about" data-type="indexterm" id="C16-collections.html8"/><a contenteditable="false" data-primary="collections" data-secondary="BTreeMap&lt;K, V&gt;" data-type="indexterm" id="C16-collections.html9"/><a contenteditable="false" data-primary="collections" data-secondary="HashMap&lt;K, V&gt;" data-type="indexterm" id="C16-collections.html10"/><a contenteditable="false" data-primary="HashMap&lt;K, V&gt; collection type" data-secondary="about" data-type="indexterm" id="C16-collections.html11"/><a contenteditable="false" data-primary="map types" data-secondary="BTreeMap&lt;K, V&gt;" data-type="indexterm" id="C16-collections.html12"/><a contenteditable="false" data-primary="map types" data-secondary="HashMap&lt;K, V&gt;" data-type="indexterm" id="C16-collections.html13"/>A <a contenteditable="false" data-primary="entries, defined" data-type="indexterm" id="idm45251589433800"/><a contenteditable="false" data-primary="map, defined" data-type="indexterm" id="idm45251589432664"/><em>map</em> is a collection of key-value pairs (called <em>entries</em>). No two entries have the same key, and the entries are kept organized so that if you have a key, you can efficiently look up the corresponding value in a map. In short, a map is a lookup table.</p>

<p>Rust offers two map types: <code>HashMap&lt;K, V&gt;</code> and <code>BTreeMap&lt;K, V&gt;</code>. The two share many of the same methods; the difference is in how the two keep entries arranged for fast lookup.</p>

<p>A <code>HashMap</code> stores the keys and values in a hash table, so it requires a key type <code>K</code> that implements <code>Hash</code> and <code>Eq</code>, the standard traits for hashing and equality.</p>

<p><a data-type="xref" href="#hash-map-layout-figure">Figure 16-5</a> shows how a <code>HashMap</code> is arranged in memory. Dark gray regions are unused. All keys, values, and cached hash codes are stored in a single heap-allocated table. Adding entries eventually forces the <code>HashMap</code> to allocate a larger table and move all the data into it.</p>

<figure><div id="hash-map-layout-figure" class="figure"><img src="Images/rust_1605.png" alt="(An illustration of a hash table with 16 slots, 13 of them occupied.)" width="1499" height="631"/>
<h6><span class="label">Figure 16-5. </span>A HashMap in memory</h6>
</div></figure>

<p>A <code>BTreeMap</code> stores the entries in order by key, in a tree structure, so it requires a key type <code>K</code> that implements <code>Ord</code>. <a data-type="xref" href="#btree-map-layout-figure">Figure 16-6</a> shows a <code>BTreeMap</code>. Again, dark gray regions are unused spare capacity.</p>

<figure><div id="btree-map-layout-figure" class="figure"><img src="Images/rust_1606.png" alt="(An illustration of how BTreeMaps are stored in memory.           A `BTreeMap`'s data is stored in nodes.           Each node holds a limited number of key-value pairs.)" width="1556" height="810"/>
<h6><span class="label">Figure 16-6. </span>A BTreeMap in memory</h6>
</div></figure>

<p>A <code>BTreeMap</code> stores its entries in <em>nodes</em>. Most nodes in a <code>BTreeMap</code> contain only key-value pairs. Nonleaf nodes, like the root node shown in this figure, also have room for pointers to child nodes. The pointer between <code>(20, 'q')</code> and <code>(30, 'r')</code> points to a child node containing keys between <code>20</code> and <code>30</code>. Adding entries often requires sliding some of a node’s existing entries to the right, to keep them sorted, and occasionally involves allocating new nodes.</p>

<p>This picture is a bit simplified to fit on the page. For example, real <code>BTreeMap</code> nodes have room for 11 entries, not 4.</p>

<p>The Rust standard library uses B-trees rather than balanced binary trees because B-trees are faster on modern hardware. A binary tree may use fewer comparisons per search than a B-tree, but searching a B-tree has better <em>locality</em>—that is, the memory accesses are grouped together rather than scattered across the whole heap. This makes CPU cache misses rarer. It’s a significant speed boost.</p>

<p>There are several ways to create a map:</p>

<ul>
	<li>
	<p><strong><code>HashMap::new()</code></strong> and <strong><code>BTreeMap::new()</code></strong> create new, empty maps.</p>
	</li>
	<li>
	<p><strong><code>iter.collect()</code></strong> can be used to create and populate a new <code>HashMap</code> or <code>BTreeMap</code> from key-value pairs. <code>iter</code> must be an <code>Iterator&lt;Item=(K, V)&gt;</code>.</p>
	</li>
	<li>
	<p><strong><code>HashMap::with_capacity(n)</code></strong> creates a new, empty hash map with room for at least <em>n</em> entries. <code>HashMap</code>s, like vectors, store their data in a single heap allocation, so they have a capacity and the related methods <code>hash_map.capacity()</code>, <code>hash_map.reserve(additional)</code>, and <code>hash_map.shrink_to_fit()</code>. <code>BTreeMap</code>s do not.</p>
	</li>
</ul>

<p><code>HashMap</code>s and <code>BTreeMap</code>s have the same core methods for working with keys and <span class="keep-together">values:</span></p>

<ul>
	<li>
	<p><strong><code>map.len()</code></strong> returns the number of entries.</p>
	</li>
	<li>
	<p><strong><code>map.is_empty()</code></strong> returns <code>true</code> if <code>map</code> has no entries.</p>
	</li>
	<li>
	<p><strong><code>map.contains_key(&amp;key)</code></strong> returns <code>true</code> if the map has an entry for the given <code>key</code>.</p>
	</li>
	<li>
	<p><strong><code>map.get(&amp;key)</code></strong> searches <code>map</code> for an entry with the given <code>key</code>. If a matching entry is found, this returns <code>Some(r)</code>, where <code>r</code> is a reference to the corresponding value. Otherwise, this returns <code>None</code>.</p>
	</li>
	<li>
	<p><strong><code>map.get_mut(&amp;key)</code></strong> is similar, but it returns a <code>mut</code> reference to the value.</p>

<p>In general, maps let you have <code>mut</code> access to the values stored inside them, but not the keys. The values are yours to modify however you like. The keys belong to the map itself; it needs to ensure that they don’t change, because the entries are organized by their keys. Modifying a key in-place would be a bug.</p>
	</li>
	<li>
	<p><strong><code>map.insert(key, value)</code></strong> inserts the entry <code>(key, value)</code> into <code>map</code>. If there’s already an entry for <code>key</code> in the map, the newly inserted <code>value</code> overwrites the old one.</p>

<p>Returns the old value, if any. The return type is <code>Option&lt;V&gt;</code>.</p>
	</li>
	<li>
	<p><strong><code>map.extend(iterable)</code></strong> iterates over the <code>(K, V)</code> items of <code>iterable</code> and inserts each of those key-value pairs into <code>map</code>.</p>
	</li>
	<li>
	<p><strong><code>map.append(&amp;mut map2)</code></strong> moves all entries from <code>map2</code> into <code>map</code>. Afterward, <code>map2</code> is empty.</p>
	</li>
	<li>
	<p><strong><code>map.remove(&amp;key)</code></strong> finds and removes any entry with the given <code>key</code> from <code>map</code>.</p>

	<p>Returns the removed value, if any. The return type is <code>Option&lt;V&gt;</code>.</p>
	</li>
	<li>
	<p><strong><code>map.clear()</code></strong> removes all entries.</p>
	</li>
</ul>

<p>A map can also be queried using square brackets: <strong><code>map[&amp;key]</code></strong>. That is, maps implement the <code>Index</code> built-in trait. However, this panics if there is not already an entry for the given <code>key</code>, like an out-of-bounds array access, so use this syntax only if the entry you’re looking up is sure to be populated.</p>

<p>The <code>key</code> argument to <code>.contains_key()</code>, <code>.get()</code>, <code>.get_mut()</code>, and <code>.remove()</code> does not have to have the exact type <code>&amp;K</code>. These methods are generic over types that can be borrowed from <code>K</code>. It’s OK to call <code>fish_map.contains_key("conger")</code> on a <code>HashMap&lt;String, Fish&gt;</code>, even though <code>"conger"</code> isn’t exactly a <code>String</code>, because <code>String</code> implements <code>Borrow&lt;&amp;str&gt;</code>. For details, see <a data-type="xref" href="ch13.xhtml#borrow-and-borrowmut">“Borrow and BorrowMut”</a>.</p>

<p>Because a <code>BTreeMap&lt;K, V&gt;</code> keeps its entries sorted by key, it supports an additional operation:</p>

<ul>
	<li><strong><code>btree_map.split_at(&amp;key)</code></strong> splits <code>btree_map</code> in two. Entries with keys less than <code>key</code> are left in <code>btree_map</code>. Returns a new <code>BTreeMap&lt;K, V&gt;</code> containing the other entries.</li>
</ul>

<section data-type="sect2" data-pdf-bookmark="Entries"><div class="sect2" id="entries">
<h2>Entries</h2>

<p><a contenteditable="false" data-primary="BTreeMap&lt;K, V&gt; collection type" data-secondary="entries" data-type="indexterm" id="C16-collections.html14"/><a contenteditable="false" data-primary="Entry type" data-type="indexterm" id="C16-collections.html15"/><a contenteditable="false" data-primary="HashMap&lt;K, V&gt; collection type" data-secondary="entries" data-type="indexterm" id="C16-collections.html16"/>Both <code>HashMap</code> and <code>BTreeMap</code> have a corresponding <code>Entry</code> type. The point of entries is to eliminate redundant map lookups. For example, here’s some code to get or create a student record:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Do we already have a record for this student?</code>
<code class="k">if</code><code class="w"> </code><code class="o">!</code><code class="n">student_map</code><code class="p">.</code><code class="n">contains_key</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// No: create one.</code>
<code class="w">    </code><code class="n">student_map</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">name</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"> </code><code class="n">Student</code>::<code class="n">new</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="c1">// Now a record definitely exists.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">record</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">student_map</code><code class="p">.</code><code class="n">get_mut</code><code class="p">(</code><code class="n">name</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre>

<p>This works fine, but it accesses <code>student_map</code> two or three times, doing the same lookup each time.</p>

<p>The idea with entries is that we do the lookup just once, producing an <code>Entry</code> value that is then used for all subsequent operations. This one-liner is equivalent to all the code above, except that it only does the lookup once:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">record</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">student_map</code><code class="p">.</code><code class="n">entry</code><code class="p">(</code><code class="n">name</code><code class="p">.</code><code class="n">to_string</code><code class="p">()).</code><code class="n">or_insert_with</code><code class="p">(</code><code class="n">Student</code>::<code class="n">new</code><code class="p">);</code><code class="w"/></pre>

<p>The <code>Entry</code> value returned by <code>student_map.entry(name.to_string())</code> acts like a mutable reference to a place within the map that’s either <em>occupied</em> by a key-value pair, or <em>vacant</em>, meaning there’s no entry there yet. If vacant, the entry’s <code>.or_insert_with()</code> method inserts a new <code>Student</code>. Most uses of entries are like this: short and sweet.</p>

<p class="pagebreak-before">All <code>Entry</code> values are created by the same method:</p>

<ul>
	<li>
	<p><a contenteditable="false" data-primary="map.entry(key)" data-type="indexterm" id="idm45251589269736"/><strong><code>map.entry(key)</code></strong> returns an <code>Entry</code> for the given <code>key</code>. If there’s no such key in the map, this returns a vacant <code>Entry</code>.</p>

	<p>This method takes its <code>self</code> argument by <code>mut</code> reference and returns an <code>Entry</code> with a matching lifetime:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">entry</code><code class="o">&lt;</code><code class="na">'a</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="na">'a</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">key</code>: <code class="nc">K</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Entry</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="w"/></pre>

	<p>The <code>Entry</code> type has a lifetime parameter <code>'a</code> because it’s effectively a fancy kind of borrowed <code>mut</code> reference to the map. As long as the <code>Entry</code> exists, it has exclusive access to the map.</p>

	<p>Back in <a data-type="xref" href="ch05.xhtml#structs-containing-references">“Structs Containing References”</a>, we saw how to store references in a type, and how that affects lifetimes. Now we’re seeing what that looks like from a user’s perspective. That’s what’s going on with <code>Entry</code>.</p>

	<p>Unfortunately, it is not possible to pass a reference of type <code>&amp;str</code> to this method if the map has <code>String</code> keys. The <code>.entry()</code> method, in that case, requires a real <code>String</code>.</p>
	</li>
</ul>

<p><code>Entry</code> values provide two methods for filling in vacant entries:</p>

<ul>
	<li>
	<p><strong><code>map.entry(key).or_insert(value)</code></strong> ensures that <code>map</code> contains an entry with the given <code>key</code>, inserting a new entry with the given default <code>value</code> if needed. It returns a <code>mut</code> reference to the new or existing value.</p>

	<p>Suppose we need to count votes. We can write:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">vote_counts</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashMap</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">ballots</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vote_counts</code><code class="p">.</code><code class="n">entry</code><code class="p">(</code><code class="n">name</code><code class="p">).</code><code class="n">or_insert</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="o">*</code><code class="n">count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

	<p><code>.or_insert()</code> returns a <code>mut</code> reference, so the type of <code>count</code> is <code>&amp;mut usize</code>.</p>
	</li>
	<li>
	<p><strong><code>map.entry(key).or_insert_with(default_fn)</code></strong> is the same, except that if it needs to create a new entry, it calls <code>default_fn()</code> to produce the default value. If there’s already an entry for <code>key</code> in the <code>map</code>, then <code>default_fn</code> is not used.</p>

	<p>Suppose we want to know which words appear in which files. We can write:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// This map contains, for each word, the set of files it appears in.</code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">word_occurrence</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">HashSet</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">HashMap</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">files</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">word</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">read_words</code><code class="p">(</code><code class="n">file</code><code class="p">)</code><code class="o">?</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">set</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">word_occurrence</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">entry</code><code class="p">(</code><code class="n">word</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">.</code><code class="n">or_insert_with</code><code class="p">(</code><code class="n">HashSet</code>::<code class="n">new</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">set</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">file</code><code class="p">.</code><code class="n">clone</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
	</li>
</ul>

<p>The <code>Entry</code> type is an enum, defined like this for <code>HashMap</code> (and similarly for <code>BTreeMap</code>):</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// (in std::collections::hash_map)</code>
<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">Entry</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">K</code>: <code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">V</code>: <code class="na">'a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Occupied</code><code class="p">(</code><code class="n">OccupiedEntry</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">Vacant</code><code class="p">(</code><code class="n">VacantEntry</code><code class="o">&lt;</code><code class="na">'a</code><code class="p">,</code><code class="w"> </code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>OccupiedEntry</code> and <code>VacantEntry</code> types have methods for inserting, removing, and accessing entries without repeating the initial lookup. You can find them in the online documentation. The extra methods can occasionally be used to eliminate a redundant lookup or two, but <code>.or_insert()</code> and <code>.or_insert_with()</code> cover the common cases.<a contenteditable="false" data-primary="" data-startref="C16-collections.html16" data-type="indexterm" id="idm45251588815912"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html15" data-type="indexterm" id="idm45251588814536"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html14" data-type="indexterm" id="idm45251588813160"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Map Iteration"><div class="sect2" id="map-iteration">
<h2>Map Iteration</h2>

<p><a contenteditable="false" data-primary="BTreeMap&lt;K, V&gt; collection type" data-secondary="map iteration" data-type="indexterm" id="idm45251588924472"/><a contenteditable="false" data-primary="HashMap&lt;K, V&gt; collection type" data-secondary="map iteration" data-type="indexterm" id="idm45251588923128"/><a contenteditable="false" data-primary="iterating" data-secondary="over a map" data-type="indexterm" id="idm45251588921784"/>There are several ways to iterate over a map:</p>

<ul>
	<li>
	<p>Iterating by value (“<code>for (k, v) in map</code>”) produces <code>(K, V)</code> pairs. This consumes the map.</p>
	</li>
	<li>
	<p>Iterating over a shared reference (“<code>for (k, v) in &amp;map</code>”) produces <code>(&amp;K, &amp;V)</code> pairs.</p>
	</li>
	<li>
	<p>Iterating over a <code>mut</code> reference (“<code>for (k, v) in &amp;mut map</code>”) produces <code>(&amp;K, &amp;mut V)</code> pairs. (Again, there’s no way to get <code>mut</code> access to keys stored in a map, because the entries are organized by their keys.)</p>
	</li>
</ul>

<p>Like vectors, maps have <code>.iter()</code> and <code>.iter_mut()</code> methods which return by-reference iterators, just like iterating over <code>&amp;map</code> or <code>&amp;mut map</code>. In addition:</p>

<ul>
	<li>
	<p><strong><code>map.keys()</code></strong> returns an iterator over just the keys, by reference.</p>
	</li>
	<li>
	<p><strong><code>map.values()</code></strong> returns an iterator over the values, by reference.</p>
	</li>
	<li>
	<p><strong><code>map.values_mut()</code></strong> returns an iterator over the values, by <code>mut</code> reference.</p>
	</li>
</ul>

<p>All <code>HashMap</code> iterators visit the map’s entries in an arbitrary order. <code>BTreeMap</code> iterators visit them in order by key.<a contenteditable="false" data-primary="" data-startref="C16-collections.html13" data-type="indexterm" id="idm45251588905080"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html12" data-type="indexterm" id="idm45251588903704"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html11" data-type="indexterm" id="idm45251588902328"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html10" data-type="indexterm" id="idm45251588900952"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html9" data-type="indexterm" id="idm45251588899576"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html8" data-type="indexterm" id="idm45251588898200"/></p>
</div></section>
</div></section>

<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="HashSet&lt;T&gt; and BTreeSet&lt;T&gt;"><div class="sect1" id="hashsett-and-btreesett">
<h1>HashSet&lt;T&gt; and BTreeSet&lt;T&gt;</h1>

<p><a contenteditable="false" data-primary="BTreeSet&lt;T&gt; collection type" data-type="indexterm" id="C16-collections.html17"/><a contenteditable="false" data-primary="collections" data-secondary="BTreeSet&lt;T&gt;" data-type="indexterm" id="C16-collections.html18"/><a contenteditable="false" data-primary="collections" data-secondary="HashSet&lt;T&gt;" data-type="indexterm" id="C16-collections.html19"/><a contenteditable="false" data-primary="HashSet&lt;T&gt; collection type" data-type="indexterm" id="C16-collections.html20"/><em>Sets</em> <a contenteditable="false" data-primary="sets, defined" data-type="indexterm" id="idm45251588888664"/>are collections of values arranged for fast membership testing.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">b1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">large_vector</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="s">"needle"</code><code class="p">);</code><code class="w">    </code><code class="c1">// slow, checks every element</code>
<code class="kd">let</code><code class="w"> </code><code class="n">b2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">large_hash_set</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="s">"needle"</code><code class="p">);</code><code class="w">  </code><code class="c1">// fast, hash lookup</code></pre>

<p>A set never contains multiple copies of the same value.</p>

<p>Maps and sets have different methods, but behind the scenes, a set is like a map with only keys, rather than key-value pairs. In fact, Rust’s two set types, <code>HashSet&lt;T&gt;</code> and <code>BTreeSet&lt;T&gt;</code>, are implemented as thin wrappers around <code>HashMap&lt;T, ()&gt;</code> and <code>BTreeMap&lt;T, ()&gt;</code>.</p>

<ul>
	<li>
	<p><strong><code>HashSet::new()</code></strong> and <strong><code>BTreeSet::new()</code></strong> create new sets.</p>
	</li>
	<li>
	<p><strong><code>iter.collect()</code></strong> can be used to create a new set from any iterator. If <code>iter</code> produces any values more than once, the duplicates are dropped.</p>
	</li>
	<li>
	<p><strong><code>HashSet::with_capacity(n)</code></strong> creates an empty <code>HashSet</code> with room for at least <code>n</code> values.</p>
	</li>
</ul>

<p><code>HashSet&lt;T&gt;</code> and <code>BTreeSet&lt;T&gt;</code> have all the basic methods in common:</p>

<ul>
	<li>
	<p><strong><code>set.len()</code></strong> returns the number of values in <code>set</code>.</p>
	</li>
	<li>
	<p><strong><code>set.is_empty()</code></strong> returns <code>true</code> if the set contains no elements.</p>
	</li>
	<li>
	<p><strong><code>set.contains(&amp;value)</code></strong> returns <code>true</code> if the set contains the given <code>value</code>.</p>
	</li>
	<li>
	<p><strong><code>set.insert(value)</code></strong> adds a <code>value</code> to the set. Returns <code>true</code> if a value was added, <code>false</code> if it was already a member of the set.</p>
	</li>
	<li>
	<p><strong><code>set.remove(&amp;value)</code></strong> removes a <code>value</code> from the set. Returns <code>true</code> if a value was removed, <code>false</code> if it already wasn’t a member of the set.</p>
	</li>
</ul>

<p>As with maps, the methods that look up a value by reference are generic over types that can be borrowed from <code>T</code>. For details, see <a data-type="xref" href="ch13.xhtml#borrow-and-borrowmut">“Borrow and BorrowMut”</a>.</p>

<section data-type="sect2" data-pdf-bookmark="Set Iteration"><div class="sect2" id="set-iteration">
<h2>Set Iteration</h2>

<p><a contenteditable="false" data-primary="BTreeSet&lt;T&gt; collection type" data-secondary="iteration" data-type="indexterm" id="idm45251588745096"/><a contenteditable="false" data-primary="HashSet&lt;T&gt; collection type" data-secondary="iteration" data-type="indexterm" id="idm45251588743704"/>There are two ways to iterate over sets:</p>

<ul>
	<li>
	<p>Iterating by value (“<code>for v in set</code>”) produces the members of the set (and consumes the set).</p>
	</li>
	<li>
	<p>Iterating by shared reference (“<code>for v in &amp;set</code>”) produces shared references to the members of the set.</p>
	</li>
</ul>

<p>Iterating over a set by <code>mut</code> reference is not supported. There’s no way to get a <code>mut</code> reference to a value stored in a set.</p>

<ul>
	<li><strong><code>set.iter()</code></strong> returns an iterator over the members of <code>set</code> by reference.</li>
</ul>

<p><code>HashSet</code> iterators, like <code>HashMap</code> iterators, produce their values in an arbitrary order. <code>BTreeSet</code> iterators produce values in order, like a sorted vector.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="When Equal Values Are Different"><div class="sect2" id="when-equal-values-are-different">
<h2>When Equal Values Are Different</h2>

<p><a contenteditable="false" data-primary="BTreeSet&lt;T&gt; collection type" data-secondary="methods when &quot;equal&quot; values are different" data-type="indexterm" id="idm45251588702168"/><a contenteditable="false" data-primary="HashSet&lt;T&gt; collection type" data-secondary="methods when &quot;equal&quot; values are different" data-type="indexterm" id="idm45251588700632"/>Sets have a few odd methods that you need to use only if you care about differences between “equal” values.</p>

<p>Such differences do often exist. Two identical <code>String</code> values, for example, store their characters in different locations in memory:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">s1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"hello"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">s2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"hello"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:p}"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">s1</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">&amp;</code><code class="kt">str</code><code class="p">);</code><code class="w">  </code><code class="c1">// 0x7f8b32060008</code>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{:p}"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">s2</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">&amp;</code><code class="kt">str</code><code class="p">);</code><code class="w">  </code><code class="c1">// 0x7f8b32060010</code></pre>

<p>Usually, we don’t care.</p>

<p>But in case you ever do, you can get access to the actual values stored inside a set by using the following methods. Each one returns an <code>Option</code> that’s <code>None</code> if <code>set</code> did not contain a matching value.</p>

<ul>
	<li>
	<p><strong><code>set.get(&amp;value)</code></strong> returns a shared reference to the member of <code>set</code> that’s equal to <code>value</code>, if any. Returns an <code>Option&lt;&amp;T&gt;</code>.</p>
	</li>
	<li>
	<p><strong><code>set.take(&amp;value)</code></strong> is like <code>set.remove(&amp;value)</code>, but it returns the removed value, if any. Returns an <code>Option&lt;T&gt;</code>.</p>
	</li>
	<li>
	<p><strong><code>set.replace(value)</code></strong> is like <code>set.insert(value)</code>, but if <code>set</code> already contains a value that’s equal to <code>value</code>, this replaces and returns the old value. Returns an <code>Option&lt;T&gt;</code>.</p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Whole-Set Operations"><div class="sect2" id="whole-set-operations">
<h2>Whole-Set Operations</h2>

<p><a contenteditable="false" data-primary="BTreeSet&lt;T&gt; collection type" data-secondary="whole-set operations" data-type="indexterm" id="idm45251588643912"/><a contenteditable="false" data-primary="HashSet&lt;T&gt; collection type" data-secondary="whole-set operations" data-type="indexterm" id="idm45251588642568"/>So far, most of the set methods we’ve seen are focused on a single value in a single set. Sets also have methods that operate on whole sets.</p>

<ul>
	<li>
	<p><strong><code>set1.intersection(&amp;set2)</code></strong> returns an iterator over all values that are in both <code>set1</code> and <code>set2</code>.</p>

	<p>For example, if we want to print the names of all students who are taking both brain surgery and rocket science classes, we could write:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">student</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">brain_class</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">rocket_class</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="o">&amp;</code><code class="n">student</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">student</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

	<p>Or, shorter:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">student</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">brain_class</code><code class="p">.</code><code class="n">intersection</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rocket_class</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">student</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

	<p>Amazingly, there’s an operator for this.</p>

	<p><strong><code>&amp;set1 &amp; &amp;set2</code></strong> returns a new set that’s the intersection of <code>set1</code> and <code>set2</code>. This is the binary bitwise AND operator, applied to two references. This finds values that are in both <code>set1</code> <em>AND</em> <code>set2</code>.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">overachievers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">brain_class</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="o">&amp;</code><code class="n">rocket_class</code><code class="p">;</code><code class="w"/></pre>
	</li>
	<li>
	<p><strong><code>set1.union(&amp;set2)</code></strong> returns an iterator over values that are in either <code>set1</code> or <code>set2</code>, or both.</p>

	<p><strong><code>&amp;set1 | &amp;set2</code></strong> returns a new set containing all those values. It finds values that are in either <code>set1</code> <em>OR</em> <code>set2</code>.</p>
	</li>
	<li>
	<p><strong><code>set1.difference(&amp;set2)</code></strong> returns an iterator over values that are in <code>set1</code> but not in <code>set2</code>.</p>

	<p><strong><code>&amp;set1 - &amp;set2</code></strong> returns a new set containing all those values.</p>
	</li>
	<li>
	<p><strong><code>set1.symmetric_difference(&amp;set2)</code></strong> returns an iterator over values that are in either <code>set1</code> or <code>set2</code>, but not both.</p>

	<p><strong><code>&amp;set1 ^ &amp;set2</code></strong> returns a new set containing all those values.</p>
	</li>
</ul>

<p>And there are three methods for testing relationships between sets:</p>

<ul>
	<li>
	<p><strong><code>set1.is_disjoint(set2)</code></strong> is true if <code>set1</code> and <code>set2</code> have no values in common—the intersection between them is empty.</p>
	</li>
	<li>
	<p><strong><code>set1.is_subset(set2)</code></strong> is true if <code>set1</code> is a subset of <code>set2</code>—that is, all values in <code>set1</code> are also in <code>set2</code>.</p>
	</li>
	<li>
	<p><strong><code>set1.is_superset(set2)</code></strong> is the reverse: it’s true if <code>set1</code> is a superset of <code>set2</code>.</p>
	</li>
</ul>

<p>Sets also support equality testing with <code>==</code> and <code>!=</code>; two sets are equal if they contain the same values.<a contenteditable="false" data-primary="" data-startref="C16-collections.html20" data-type="indexterm" id="idm45251588440040"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html19" data-type="indexterm" id="idm45251588438776"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html18" data-type="indexterm" id="idm45251588437400"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html17" data-type="indexterm" id="idm45251588436024"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Hashing"><div class="sect1" id="hashing">
<h1>Hashing</h1>

<p><a contenteditable="false" data-primary="collections" data-secondary="hashing" data-type="indexterm" id="C16-collections.html21"/><a contenteditable="false" data-primary="hashing" data-secondary="collections and" data-type="indexterm" id="C16-collections.html22"/><code>std::hash::Hash</code> is the standard library trait for hashable types. <code>HashMap</code> keys and <code>HashSet</code> elements must implement both <code>Hash</code> and <code>Eq</code>.</p>

<p>Most built-in types that implement <code>Eq</code> also implement <code>Hash</code>. The integer types, <code>char</code>, and <code>String</code> are all hashable; so are tuples, arrays, slices, and vectors, as long as their elements are hashable.</p>

<p>One principle of the standard library is that a value should have the same hash code regardless of where you store it or how you point to it. Therefore, a reference has the same hash code as the value it refers to, and a <code>Box</code> has the same hash code as the boxed value. A vector <code>vec</code> has the same hash code as the slice containing all its data, <code>&amp;vec[..]</code>. A <code>String</code> has the same hash code as a <code>&amp;str</code> with the same characters.</p>

<p><a contenteditable="false" data-primary="enums" data-secondary="hash implementation" data-type="indexterm" id="idm45251588404168"/><a contenteditable="false" data-primary="structs" data-secondary="hash implementation" data-type="indexterm" id="idm45251588402760"/>Structs and enums don’t implement <code>Hash</code> by default, but an implementation can be derived:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// The ID number for an object in the British Museum's collection.</code>
<code class="cp">#[derive(Clone, PartialEq, Eq, Hash)]</code><code class="w"/>
<code class="k">enum</code> <code class="nc">MuseumNumber</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This works as long as the type’s fields are all hashable.</p>

<p>If you implement <code>PartialEq</code> by hand for a type, you should also implement <code>Hash</code> by hand. For example, suppose we have a type that represents priceless historical treasures:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Artifact</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">id</code>: <code class="nc">MuseumNumber</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">cultures</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Culture</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">date</code>: <code class="nc">RoughTime</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Two <code>Artifact</code>s are considered equal if they have the same ID:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="nb">PartialEq</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Artifact</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">eq</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">other</code>: <code class="kp">&amp;</code><code class="nc">Artifact</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">id</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">other</code><code class="p">.</code><code class="n">id</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="nb">Eq</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Artifact</code><code class="w"> </code><code class="p">{}</code><code class="w"/></pre>

<p>Since we compare artifacts purely on the basis of their ID, we must hash them the same way:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">Hash</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Artifact</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">hash</code><code class="o">&lt;</code><code class="n">H</code>: <code class="nc">Hasher</code><code class="o">&gt;</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">hasher</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">H</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Delegate hashing to the MuseumNumber.</code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">hash</code><code class="p">(</code><code class="n">hasher</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>(Otherwise, <code>HashSet&lt;Artifact&gt;</code> would not work properly; like all hash tables, it requires that <code>hash(a) == hash(b)</code> if <code>a == b</code>.)</p>

<p>This allows us to create a <code>HashSet</code> of <code>Artifacts</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashSet</code>::<code class="o">&lt;</code><code class="n">Artifact</code><code class="o">&gt;</code>::<code class="n">new</code><code class="p">();</code><code class="w"/></pre>

<p>As this code shows, even when you implement <code>Hash</code> by hand, you don’t need to know anything about hashing algorithms. <code>.hash()</code> receives a reference to a <code>Hasher</code>, which represents the hashing algorithm. You simply feed this <code>Hasher</code> all the data that’s relevant to the <code>==</code> operator. The <code>Hasher</code> computes a hash code from whatever you give it.</p>

<section data-type="sect2" data-pdf-bookmark="Using a Custom Hashing Algorithm"><div class="sect2" id="using-a-custom-hashing-algorithm">
<h2>Using a Custom Hashing Algorithm</h2>

<p><a contenteditable="false" data-primary="hashing" data-secondary="using a custom algorithm" data-type="indexterm" id="idm45251588147032"/>The <code>hash</code> method is generic, so the <code>Hash</code> implementations shown above can feed data to any type that implements <code>Hasher</code>. This is how Rust supports pluggable hashing algorithms. <code>Hash</code> and <code>Hasher</code> are buddy traits, as explained in <a data-type="xref" href="ch11.xhtml#buddy-traits-or-how-randrandom-works">“Buddy Traits (or How rand::random() Works)”</a>.</p>

<p><a contenteditable="false" data-primary="BuildHasher trait" data-type="indexterm" id="idm45251588142008"/>A third trait, <code>std::hash::BuildHasher</code>, is the trait for types that represent the initial state of a hashing algorithm. Each <code>Hasher</code> is single-use, like an iterator: you use it once and throw it away. A <code>BuildHasher</code> is reusable.</p>

<p>Every <code>HashMap</code> contains a <code>BuildHasher</code> that it uses each time it needs to compute a hash code. The <code>BuildHasher</code> value contains the key, initial state, or other parameters that the hashing algorithm needs every time it runs.</p>

<p>The complete protocol for computing a hash code looks like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">hash</code>::<code class="p">{</code><code class="n">Hash</code><code class="p">,</code><code class="w"> </code><code class="n">Hasher</code><code class="p">,</code><code class="w"> </code><code class="n">BuildHasher</code><code class="p">};</code><code class="w"/>

<code class="k">fn</code> <code class="nf">compute_hash</code><code class="o">&lt;</code><code class="n">B</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">builder</code>: <code class="kp">&amp;</code><code class="nc">B</code><code class="p">,</code><code class="w"> </code><code class="n">value</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code>
    <code class="nc">where</code><code class="w"> </code><code class="n">B</code>: <code class="nc">BuildHasher</code><code class="p">,</code><code class="w"> </code><code class="n">T</code>: <code class="nc">Hash</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">hasher</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">builder</code><code class="p">.</code><code class="n">build_hasher</code><code class="p">();</code><code class="w">  </code><code class="c1">// 1. start the algorithm</code>
<code class="w">    </code><code class="n">value</code><code class="p">.</code><code class="n">hash</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">hasher</code><code class="p">);</code><code class="w">                  </code><code class="c1">// 2. feed it data</code>
<code class="w">    </code><code class="n">hasher</code><code class="p">.</code><code class="n">finish</code><code class="p">()</code><code class="w">                           </code><code class="c1">// 3. finish, producing a u64</code>
<code class="p">}</code><code class="w"/></pre>

<p><code>HashMap</code> calls these three methods every time it needs to compute a hash code. All the methods are inlineable, so it’s very fast.</p>

<p>Rust’s default hashing algorithm is a well-known algorithm called SipHash-1-3. SipHash is fast, and it’s very good at minimizing hash collisions. In fact, it’s a cryptographic algorithm: there’s no known efficient way to generate SipHash-1-3 collisions. As long as a different, unpredictable key is used for each hash table, Rust is secure against a kind of denial-of-service attack called HashDoS, where attackers deliberately use hash collisions to trigger worst-case performance in a server.</p>

<p>But perhaps you don’t need that for your application. If you’re storing many small keys, such as integers or very short strings, it is possible to implement a faster hash function, at the expense of HashDoS security. The <code>fnv</code> crate implements one such algorithm, the Fowler-Noll-Vo hash. To try it out, add this line to your <em>Cargo.toml</em>:</p>

<pre data-type="programlisting">
[dependencies]
fnv = "1.0"</pre>

<p>Then import the map and set types from <code>fnv</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">fnv</code><code class="p">;</code><code class="w"/>

<code class="k">use</code><code class="w"> </code><code class="n">fnv</code>::<code class="p">{</code><code class="n">FnvHashMap</code><code class="p">,</code><code class="w"> </code><code class="n">FnvHashSet</code><code class="p">};</code><code class="w"/></pre>

<p>You can use these two types as drop-in replacements for <code>HashMap</code> and <code>HashSet</code>. A peek inside the <code>fnv</code> source code reveals how they’re defined:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// A `HashMap` using a default FNV hasher.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nc">FnvHashMap</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="p">,</code><code class="w"> </code><code class="n">FnvBuildHasher</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>

<code class="sd">/// A `HashSet` using a default FNV hasher.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nc">FnvHashSet</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HashSet</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">FnvBuildHasher</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/></pre>

<p>The standard <code>HashMap</code> and <code>HashSet</code> collections accept an optional extra type parameter specifying the hashing algorithm; <code>FnvHashMap</code> and <code>FnvHashSet</code> are generic type aliases for <code>HashMap</code> and <code>HashSet</code>, specifying an FNV hasher for that parameter.<a contenteditable="false" data-primary="" data-startref="C16-collections.html22" data-type="indexterm" id="idm45251587881720"/><a contenteditable="false" data-primary="" data-startref="C16-collections.html21" data-type="indexterm" id="idm45251587880344"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Beyond the Standard Collections"><div class="sect1" id="beyond-the-standard-collections">
<h1>Beyond the Standard Collections</h1>

<p>Creating a new, custom collection type in Rust is much the same as in any other language. You arrange data by combining the parts the language provides: structs and enums, standard collections, <code>Option</code>s, <code>Box</code>es, and so on. For an example, see the <code>BinaryTree&lt;T&gt;</code> type defined in <a data-type="xref" href="ch10.xhtml#generic-enums">“Generic Enums”</a>.</p>

<p>If you’re used to implementing data structures in C++, using raw pointers, manual memory management, placement <code>new</code>, and explicit destructor calls to get the best possible performance, you’ll undoubtedly find safe Rust rather limiting. All of those tools are inherently unsafe. They are available in Rust, but only if you opt in to unsafe code. <a data-type="xref" href="ch21.xhtml#unsafe-code">Chapter 21</a> shows how; it includes an example that uses some unsafe code to implement a safe custom collection.</p>

<p>For now, we’ll just bask in the warm glow of the standard collections and their safe, efficient APIs. Like much of the Rust standard library, they’re designed to ensure that the need to write "<code>unsafe</code>" is as rare as possible.<a contenteditable="false" data-primary="" data-startref="C16-collections.html0" data-type="indexterm" id="idm45251587871752"/></p>
</div></section>
</div></section></div></body>
</html>