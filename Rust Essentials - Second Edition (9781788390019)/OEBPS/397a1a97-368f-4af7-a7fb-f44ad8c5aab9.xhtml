<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Structuring Data and Matching Patterns</h1>
                </header>
            
            <article>
                
<p>Until now we only used simple data, but to do real programming, more composite and structured data values are needed. Amongst them are flexible arrays and tuples, enums, and structs to represent more object-like behavior, like in classical object-oriented languages. Options are another important type used to ensure that cases where no value is returned are accounted for. Then we look at pattern matching, another typical functional construct in Rust. But we start by looking more carefully at strings.</p>
<p>We will cover the following topics:</p>
<ul>
<li>Strings</li>
<li>Arrays, vectors and slices</li>
<li>Tuples</li>
<li>Structs</li>
<li>Enums</li>
<li>Getting input from the console</li>
<li>Matching patterns</li>
<li>Program arguments</li>
</ul>


            </article>

            
        </section>
    </div></body>
</html>