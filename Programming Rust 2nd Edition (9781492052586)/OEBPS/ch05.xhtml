<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Expressions"><div class="chapter" id="expressions">
<h1><span class="label">Chapter 5. </span>Expressions</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625513017464"><h5>A note for Early Release readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 6th chapter of the final book.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <em>jimb@red-bean.com</em>.</p>
</div></aside>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>LISP programmers know the value of everything, but the cost of nothing.</p>

<p data-type="attribution">Alan Perlis, epigram #55</p>
</blockquote>

<p><a contenteditable="false" data-primary="expressions" data-type="indexterm" id="C06-expressions.html0"/> In this chapter, we’ll cover the <em>expressions</em> of Rust, the building blocks that make up the body of Rust functions. A few concepts, such as closures and iterators, are deep enough that we will dedicate a whole chapter to them later on. For now, we aim to cover as much syntax as possible in a few pages.</p>

<section data-type="sect1" data-pdf-bookmark="An Expression Language"><div class="sect1" id="an-expression-language">
<h1>An Expression Language</h1>

<p><a contenteditable="false" data-primary="expression language, Rust as" data-type="indexterm" id="idm45625507687992"/> <a contenteditable="false" data-primary="expressions" data-secondary="Rust as expression language" data-type="indexterm" id="idm45625507686696"/> <a contenteditable="false" data-primary="expressions" data-secondary="statements vs." data-type="indexterm" id="idm45625507685144"/> <a contenteditable="false" data-primary="statements, expressions vs." data-type="indexterm" id="idm45625507683608"/> Rust visually resembles the C family of languages, but this is a bit of a ruse. In C, there is a sharp distinction between <em>expressions,</em> bits of code that look something like this:</p>

<pre class="cpp" data-code-language="cpp" data-type="programlisting">
<code class="mi">5</code> <code class="o">*</code> <code class="p">(</code><code class="n">fahr</code><code class="o">-</code><code class="mi">32</code><code class="p">)</code> <code class="o">/</code> <code class="mi">9</code></pre>

<p>and <em>statements,</em> which look more like this:</p>

<pre class="cpp" data-code-language="cpp" data-type="programlisting">
<code class="k">for</code> <code class="p">(;</code> <code class="n">begin</code> <code class="o">!=</code> <code class="n">end</code><code class="p">;</code> <code class="o">++</code><code class="n">begin</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">*</code><code class="n">begin</code> <code class="o">==</code> <code class="n">target</code><code class="p">)</code>
        <code class="k">break</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Expressions have values. Statements don’t.</p>

<p>Rust is what is called an <em>expression language</em>. This means it follows an older tradition, dating back to Lisp, where expressions do all the work.</p>

<p>In C, <code>if</code> and <code>switch</code> are statements. They don’t produce a value, and they can’t be used in the middle of an expression. In Rust, <code>if</code> and <code>match</code> <em>can</em> produce values. We already saw a <code>match</code> expression that produces a numeric value in XREF HERE:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">pixels</code><code class="p">[</code><code class="n">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">c</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">escapes</code><code class="p">(</code><code class="n">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">re</code>: <code class="nc">point</code><code class="p">.</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">im</code>: <code class="nc">point</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="p">},</code><code class="w"> </code><code class="mi">255</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">count</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">255</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u8</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w"/></pre>

<p>An <code>if</code> expression can be used to initialize a variable:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">status</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">cpu</code><code class="p">.</code><code class="n">temperature</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">MAX_TEMP</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">HttpStatus</code>::<code class="nb">Ok</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">HttpStatus</code>::<code class="n">ServerError</code><code class="w">  </code><code class="c1">// server melted</code>
<code class="w">    </code><code class="p">};</code><code class="w"/></pre>

<p>A <code>match</code> expression can be passed as an argument to a function or macro:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Inside the vat, you see {}."</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">vat</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">brain</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">brain</code><code class="p">.</code><code class="n">desc</code><code class="p">(),</code><code class="w"/>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"nothing of interest"</code><code class="w"/>
<code class="w">    </code><code class="p">});</code><code class="w"/></pre>

<p>This explains why Rust does not have C’s ternary operator (<code><var>expr1</var> ? <var>expr2</var> : <var>expr3</var></code>). In C, it is a handy expression-level analogue to the <code>if</code> statement. It would be redundant in Rust: the <code>if</code> expression handles both cases.</p>

<p>Most of the control flow tools in C are statements. In Rust, they are all expressions.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Blocks and Semicolons"><div class="sect1" id="blocks-and-semicolons">
<h1>Blocks and Semicolons</h1>

<p><a contenteditable="false" data-primary="blocks" data-type="indexterm" id="C06-expressions.html1"/> <a contenteditable="false" data-primary="expressions" data-secondary="blocks and semicolons" data-type="indexterm" id="C06-expressions.html2"/> Blocks, too, are expressions. A block produces a value and can be used anywhere a value is needed:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">display_name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">post</code><code class="p">.</code><code class="n">author</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">author</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">author</code><code class="p">.</code><code class="n">name</code><code class="p">(),</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">network_info</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">post</code><code class="p">.</code><code class="n">get_network_metadata</code><code class="p">()</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">ip</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">network_info</code><code class="p">.</code><code class="n">client_address</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">ip</code><code class="p">.</code><code class="n">to_string</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>The code after <code>Some(author) =&gt;</code> is the simple expression <code>author.name()</code>. The code after <code>None =&gt;</code> is a block expression. It makes no difference to Rust. The value of the block is the value of its last expression, <code>ip.to_string()</code>.</p>

<p><a contenteditable="false" data-primary="semicolons" data-type="indexterm" id="idm45625507250616"/> Note that there is no semicolon after that expression. Most lines of Rust code do end with either a semi<span class="keep-together">colon</span> or curly braces, just like C or Java. And if a block looks like C code, with semicolons in all the familiar places, then it will run just like a C block, and its value will be <code>()</code>. As we mentioned in XREF HERE, when you leave the <span class="keep-together">semicolon</span> off the last line of a block, you’re making that block produce a value—the value of the final expression.</p>

<p>In some languages, particularly JavaScript, you’re allowed to omit semicolons, and the language simply fills them in for you—a minor convenience. This is different. In Rust, the semicolon actually means something.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">msg</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// let-declaration: semicolon is always required</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">dandelion_control</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">puffball</code><code class="p">.</code><code class="n">open</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="c1">// expression + semicolon: method is called, return value dropped</code>
<code class="w">    </code><code class="n">dandelion_control</code><code class="p">.</code><code class="n">release_all_seeds</code><code class="p">(</code><code class="n">launch_codes</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="c1">// expression with no semicolon: method is called,</code>
<code class="w">    </code><code class="c1">// return value stored in `msg`</code>
<code class="w">    </code><code class="n">dandelion_control</code><code class="p">.</code><code class="n">get_status</code><code class="p">()</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>This ability of blocks to contain declarations and also produce a value at the end is a neat feature, one that quickly comes to feel natural. The one drawback is that it leads to an odd error message when you leave out a semicolon by accident.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="p">...</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="n">preferences</code><code class="p">.</code><code class="n">changed</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">page</code><code class="p">.</code><code class="n">compute_size</code><code class="p">()</code><code class="w">  </code><code class="c1">// oops, missing semicolon</code>
<code class="p">}</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre>

<p>If you made this mistake in a C or Java program, the compiler would simply point out that you’re missing a semicolon. Here’s what Rust says:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="go">error[E0308]: mismatched types</code>
<code class="go">22 |         page.compute_size()  // oops, missing semicolon</code>
<code class="go">   |         ^^^^^^^^^^^^^^^^^^^- help: try adding a semicolon: `;`</code>
<code class="go">   |         |</code>
<code class="go">   |         expected (), found tuple</code>
<code class="go">   |</code>
<code class="go">   = note: expected type `()`</code>
<code class="go">              found type `(u32, u32)`</code></pre>

<p>With the semicolon missing, the block’s value would be whatever <code>page.compute_size()</code> returns, but an <code>if</code> without an <code>else</code> must always return <code>()</code>. Fortunately, Rust has seen this sort of thing before, and suggests adding the semicolon. <a contenteditable="false" data-primary="" data-startref="C06-expressions.html2" data-type="indexterm" id="idm45625507088200"/> <a contenteditable="false" data-primary="" data-startref="C06-expressions.html1" data-type="indexterm" id="idm45625507086696"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Declarations"><div class="sect1" id="declarations">
<h1>Declarations</h1>

<p><a contenteditable="false" data-primary="blocks" data-secondary="declarations in" data-type="indexterm" id="idm45625507083576"/> <a contenteditable="false" data-primary="declarations" data-type="indexterm" id="idm45625507082072"/> <a contenteditable="false" data-primary="expressions" data-secondary="declarations" data-type="indexterm" id="idm45625507080808"/> In addition to expressions and semicolons, a block may contain any number of declarations. <a contenteditable="false" data-primary="let declarations" data-type="indexterm" id="idm45625507064984"/> The most common are <code>let</code> declarations, which declare local variables:</p>

<pre>
<strong>let</strong> <var>name</var><strong>:</strong> <var>type</var> <strong>=</strong> <var>expr</var><strong>;</strong></pre>

<p>The type and initializer are optional. The semicolon is required.</p>

<p>A <code>let</code> declaration can declare a variable without initializing it. The variable can then be initialized with a later assignment. This is occasionally useful, because sometimes a variable should be initialized from the middle of some sort of control flow construct:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">name</code><code class="p">;</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="n">user</code><code class="p">.</code><code class="n">has_nickname</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">user</code><code class="p">.</code><code class="n">nickname</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">generate_unique_name</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">user</code><code class="p">.</code><code class="n">register</code><code class="p">(</code><code class="o">&amp;</code><code class="n">name</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Here there are two different ways the local variable <code>name</code> might be initialized, but either way it will be initialized exactly once, so <code>name</code> does not need to be declared <code>mut</code>.</p>

<p>It’s an error to use a variable before it’s initialized. (This is closely related to the error of using a value after it’s been moved. Rust really wants you to use values only while they exist!)</p>

<p>You may occasionally see code that seems to redeclare an existing variable, like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">file</code><code class="p">.</code><code class="n">lines</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is equivalent to:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">line_result</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">file</code><code class="p">.</code><code class="n">lines</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line_result</code><code class="o">?</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>let</code> declaration creates a new, second variable, of a different type. The type of <code>line_result</code> is <code>Result&lt;String, io::Error&gt;</code>. The second variable, <code>line</code>, is a <code>String</code>. It’s legal to give the second variable the same name as the first. In this book, we’ll stick to using a <code>_result</code> suffix in such situations, so that all variables have distinct names.</p>

<p><a contenteditable="false" data-primary="item declarations" data-type="indexterm" id="idm45625506881912"/> A block can also contain <em>item declarations</em>. An item is simply any declaration that could appear globally in a program or module, such as a <code>fn</code>, <code>struct</code>, or <code>use</code>.</p>

<p>Later chapters will cover items in detail. <a contenteditable="false" data-primary="fn keyword" data-type="indexterm" id="idm45625506878328"/> For now, <code>fn</code> makes a sufficient example. Any block may contain a <code>fn</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code><code class="p">;</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cmp</code>::<code class="n">Ordering</code><code class="p">;</code><code class="w"/>

<code class="k">fn</code> <code class="nf">show_files</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">io</code>::<code class="nb">Result</code><code class="o">&lt;</code><code class="p">()</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[];</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>

<code class="w">    </code><code class="k">fn</code> <code class="nf">cmp_by_timestamp_then_name</code><code class="p">(</code><code class="n">a</code>: <code class="kp">&amp;</code><code class="nc">FileInfo</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">FileInfo</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Ordering</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">a</code><code class="p">.</code><code class="n">timestamp</code><code class="p">.</code><code class="n">cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="n">b</code><code class="p">.</code><code class="n">timestamp</code><code class="p">)</code><code class="w">   </code><code class="c1">// first, compare timestamps</code>
<code class="w">            </code><code class="p">.</code><code class="n">reverse</code><code class="p">()</code><code class="w">                  </code><code class="c1">// newest file first</code>
<code class="w">            </code><code class="p">.</code><code class="n">then</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="n">path</code><code class="p">.</code><code class="n">cmp</code><code class="p">(</code><code class="o">&amp;</code><code class="n">b</code><code class="p">.</code><code class="n">path</code><code class="p">))</code><code class="w">  </code><code class="c1">// compare paths to break ties</code>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">sort_by</code><code class="p">(</code><code class="n">cmp_by_timestamp_then_name</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When a <code>fn</code> is declared inside a block, its scope is the entire block—that is, it can be <em>used</em> throughout the enclosing block. But a nested <code>fn</code> cannot access local variables or arguments that happen to be in scope. For example, the function <code>cmp_by_timestamp_then_name</code> could not use <code>v</code> directly. (Rust also has closures, which do see into enclosing scopes. See XREF HERE.)</p>

<p>A block can even contain a whole module. This may seem a bit much—do we really need to be able to nest <em>every</em> piece of the language inside every other piece?—but programmers (and particularly programmers using macros) have a way of finding uses for every scrap of orthogonality the language provides.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="if and match"><div class="sect1" id="if-and-match">
<h1>if and match</h1>

<p><a contenteditable="false" data-primary="expressions" data-secondary="if and match" data-type="indexterm" id="C06-expressions.html3"/> <a contenteditable="false" data-primary="if expressions" data-type="indexterm" id="C06-expressions.html4"/> The form of an <code>if</code> expression is familiar:</p>

<pre>
<strong>if</strong> <var>condition1</var> <strong>{</strong>
    <var>block1</var>
<strong>}</strong> <strong>else</strong> <strong>if</strong> <var>condition2</var> <strong>{</strong>
    <var>block2</var>
<strong>}</strong> <strong>else</strong> <strong>{</strong>
    <var>block_n</var>
<strong>}</strong></pre>

<p><a contenteditable="false" data-primary="Boolean type (bool)" data-type="indexterm" id="idm45625506727960"/> <a contenteditable="false" data-primary="condition (with if statement)" data-type="indexterm" id="idm45625506726728"/> Each <code><var>condition</var></code> must be an expression of type <code>bool</code>; true to form, Rust does not implicitly convert numbers or pointers to Boolean values.</p>

<p>Unlike C, parentheses are not required around conditions. In fact, <code>rustc</code> will emit a warning if unnecessary parentheses are present. The curly braces, however, are required.</p>

<p>The <code>else if</code> blocks, as well as the final <code>else</code>, are optional. An <code>if</code> expression with no <code>else</code> block behaves exactly as though it had an empty <code>else</code> block.</p>

<p><a contenteditable="false" data-primary="match expressions" data-type="indexterm" id="idm45625506720488"/> <code>match</code> expressions are something like the C <code>switch</code> statement, but more flexible. A simple example:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">match</code><code class="w"> </code><code class="n">code</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="mi">0</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"OK"</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="mi">1</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Wires Tangled"</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="mi">2</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"User Asleep"</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Unrecognized Error {}"</code><code class="p">,</code><code class="w"> </code><code class="n">code</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is something a <code>switch</code> statement could do. Exactly one of the four arms of this <code>match</code> expression will execute, depending on the value of <code>code</code>. The wildcard pattern <code>_</code> matches everything, so it serves as the <code>default:</code> case.</p>

<p>The compiler can optimize this kind of <code>match</code> using a jump table, just like a <code>switch</code> statement in C++. A similar optimization is applied when each arm of a <code>match</code> produces a constant value. In that case, the compiler builds an array of those values, and the <code>match</code> is compiled into an array access. Apart from a bounds check, there is no branching at all in the compiled code.</p>

<p><a contenteditable="false" data-primary="patterns" data-secondary="match expressions and" data-type="indexterm" id="idm45625506693208"/> The versatility of <code>match</code> stems from the variety of supported <em>patterns</em> that can be used to the left of <code>=&gt;</code> in each arm. Above, each pattern is simply a constant integer. We’ve also shown <code>match</code> expressions that distinguish the two kinds of <code>Option</code> value:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">match</code><code class="w"> </code><code class="n">params</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="s">"name"</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Hello, {}!"</code><code class="p">,</code><code class="w"> </code><code class="n">name</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Greetings, stranger."</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is only a hint of what patterns can do. A pattern can match a range of values. It can unpack tuples. It can match against individual fields of structs. It can chase references, borrow parts of a value, and more. Rust’s patterns are a mini-language of their own. We’ll dedicate several pages to them in <a data-type="xref" href="ch09.xhtml#enums-and-patterns">Chapter 9</a>.</p>

<p>The general form of a <code>match</code> expression is:</p>

<pre>
<strong>match</strong> <var>value</var> <strong>{</strong>
    <var>pattern</var> <strong>=&gt;</strong> <var>expr</var>,
    ...
<strong>}</strong></pre>

<p>The comma after an arm may be dropped if the <code><var>expr</var></code> is a block.</p>

<p>Rust checks the given <code><var>value</var></code> against each pattern in turn, starting with the first. When a pattern matches, the corresponding <code><var>expr</var></code> is evaluated and the <code>match</code> expression is complete; no further patterns are checked. At least one of the patterns must match. Rust prohibits <code>match</code> expressions that do not cover all possible values:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">score</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">card</code><code class="p">.</code><code class="n">rank</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Jack</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">Queen</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">Ace</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">11</code><code class="w"/>
<code class="p">};</code><code class="w">  </code><code class="c1">// error: nonexhaustive patterns</code></pre>

<p>All blocks of an <code>if</code> expression must produce values of the same type:</p>

<pre data-code-language="rust" data-testing-pragma="oneliners" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">suggested_pet</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">with_wings</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">Pet</code>::<code class="n">Buzzard</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">Pet</code>::<code class="n">Hyena</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// ok</code>

<code class="kd">let</code><code class="w"> </code><code class="n">favorite_number</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">user</code><code class="p">.</code><code class="n">is_hobbit</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"eleventy-one"</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="mi">9</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// error</code>

<code class="kd">let</code><code class="w"> </code><code class="n">best_sports_team</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">is_hockey_season</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"Predators"</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// error</code></pre>

<p>(The last example is an error because in July, the result would be <code>()</code>.)</p>

<p>Similarly, all arms of a <code>match</code> expression must have the same type:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">suggested_pet</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">favorites</code><code class="p">.</code><code class="n">element</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Fire</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">Pet</code>::<code class="n">RedPanda</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">Air</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">Pet</code>::<code class="n">Buffalo</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">Water</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">Pet</code>::<code class="n">Orca</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="w">  </code><code class="c1">// error: incompatible types</code>
<code class="w">    </code><code class="p">};</code><code class="w"/></pre>

<section data-type="sect2" data-pdf-bookmark="if let"><div class="sect2" id="if-let">
<h2>if let</h2>

<p><a contenteditable="false" data-primary="expressions" data-secondary="if let" data-type="indexterm" id="idm45625506232568"/> <a contenteditable="false" data-primary="if let expressions" data-type="indexterm" id="idm45625506231064"/> There is one more <code>if</code> form, the <code>if let</code> expression:</p>

<pre>
<strong>if</strong> <strong>let</strong> <var>pattern</var> <strong>=</strong> <var>expr</var> <strong>{</strong>
    <var>block1</var>
<strong>}</strong> <strong>else</strong> <strong>{</strong>
    <var>block2</var>
<strong>}</strong></pre>

<p>The given <code><var>expr</var></code> either matches the <code><var>pattern</var></code>, in which case <code><var>block1</var></code> runs, or it doesn’t, and <code><var>block2</var></code> runs. Sometimes this is a nice way to get data out of an <code>Option</code> or <code>Result</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">cookie</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">request</code><code class="p">.</code><code class="n">session_cookie</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">restore_session</code><code class="p">(</code><code class="n">cookie</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">err</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">present_cheesy_anti_robot_task</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">log_robot_attempt</code><code class="p">(</code><code class="n">err</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">politely_accuse_user_of_being_a_robot</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">session</code><code class="p">.</code><code class="n">mark_as_human</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>It’s never strictly <em>necessary</em> to use <code>if let</code>, because <code>match</code> can do everything <code>if let</code> can do. An <code>if let</code> expression is shorthand for a <code>match</code> with just one pattern: <a contenteditable="false" data-primary="" data-startref="C06-expressions.html4" data-type="indexterm" id="idm45625506164296"/> <a contenteditable="false" data-primary="" data-startref="C06-expressions.html3" data-type="indexterm" id="idm45625506162792"/></p>

<pre>
<strong>match</strong> <var>expr</var> <strong>{</strong>
    <var>pattern</var> <strong>=&gt;</strong> <strong>{</strong> <var>block1</var> <strong>}</strong>
    <strong>_</strong> <strong>=&gt;</strong> <strong>{</strong> <var>block2</var> <strong>}</strong>
<strong>}</strong></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Loops"><div class="sect1" id="loops">
<h1>Loops</h1>

<p><a contenteditable="false" data-primary="expressions" data-secondary="loops" data-type="indexterm" id="C06-expressions.html5"/> <a contenteditable="false" data-primary="looping expressions" data-type="indexterm" id="C06-expressions.html6"/> There are four looping expressions:</p>

<pre>
<strong>while</strong> <var>condition</var> <strong>{</strong>
    <var>block</var>
<strong>}</strong>

<strong>while</strong> <strong>let</strong> <var>pattern</var> <strong>=</strong> <var>expr</var> <strong>{</strong>
    <var>block</var>
<strong>}</strong>

<strong>loop</strong> <strong>{</strong>
    <var>block</var>
<strong>}</strong>

<strong>for</strong> <var>pattern</var> <strong>in</strong> <var>collection</var> <strong>{</strong>
    <var>block</var>
<strong>}</strong></pre>

<p>Loops are expressions in Rust, but the value of a <code>while</code> or <code>for</code> loop is always <code>()</code>, so their value isn’t very useful. A <code>loop</code> expression can produce a value if you specify one.</p>

<p><a contenteditable="false" data-primary="while loop" data-type="indexterm" id="idm45625506136472"/> A <code>while</code> loop behaves exactly like the C equivalent, except that again, the <code><var>condition</var></code> must be of the exact type <code>bool</code>.</p>

<p><a contenteditable="false" data-primary="infinite loops" data-type="indexterm" id="idm45625506133512"/> <a contenteditable="false" data-primary="loop (for infinite loops)" data-type="indexterm" id="idm45625506132056"/> <a contenteditable="false" data-primary="while let loop" data-type="indexterm" id="idm45625506130824"/> The <code>while let</code> loop is analogous to <code>if let</code>. At the beginning of each loop iteration, the value of <code><var>expr</var></code> either matches the given <code><var>pattern</var></code>, in which case the block runs, or it doesn’t, in which case the loop exits.</p>

<p>Use <code>loop</code> to write infinite loops. It executes the <code><var>block</var></code> repeatedly forever (or until a <code>break</code> or <code>return</code> is reached, or the thread panics).</p>

<p><a contenteditable="false" data-primary="for loop" data-type="indexterm" id="C06-expressions.html7"/> A <code>for</code> loop evaluates the <code><var>collection</var></code> expression, then evaluates the <code><var>block</var></code> once for each value in the collection. Many collection types are supported. The standard C <code>for</code> loop:</p>

<pre class="cpp" data-code-language="cpp" data-type="programlisting">
<code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">20</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"%d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">i</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>is written like this in Rust:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="p">..</code><code class="mi">20</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>As in C, the last number printed is <code>19</code>.</p>

<p>The <code>..</code> operator produces a <em>range</em>, a simple struct with two fields: <code>start</code> and <code>end</code>. <code>0..20</code> is the same as <code>std::ops::Range { start: 0, end: 20 }</code>. Ranges can be used with <code>for</code> loops because <code>Range</code> is an iterable type: it implements the <code>std::iter::IntoIterator</code> trait, which we’ll discuss in XREF HERE. The standard collections are all iterable, as are arrays and slices.</p>

<p>In keeping with Rust’s move semantics, a <code>for</code> loop over a value consumes the value:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">strings</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">error_messages</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">strings</code><code class="w"> </code><code class="p">{</code><code class="w">                  </code><code class="c1">// each String is moved into s here...</code>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w">                                   </code><code class="c1">// ...and dropped here</code>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{} error(s)"</code><code class="p">,</code><code class="w"> </code><code class="n">strings</code><code class="p">.</code><code class="n">len</code><code class="p">());</code><code class="w"> </code><code class="c1">// error: use of moved value</code></pre>

<p>This can be inconvenient. The easy remedy is to loop over a reference to the collection instead. The loop variable, then, will be a reference to each item in the collection:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">rs</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">strings</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"String {:?} is at address {:p}."</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">rs</code><code class="p">,</code><code class="w"> </code><code class="n">rs</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Here the type of <code>&amp;strings</code> is <code>&amp;Vec&lt;String&gt;</code> and the type of <code>rs</code> is <code>&amp;String</code>.</p>

<p>Iterating over a <code>mut</code> reference provides a <code>mut</code> reference to each element:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">for</code><code class="w"> </code><code class="n">rs</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">strings</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><code class="c1">// the type of rs is &amp;mut String</code>
<code class="w">    </code><code class="n">rs</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'\n'</code><code class="p">);</code><code class="w">  </code><code class="c1">// add a newline to each string</code>
<code class="p">}</code><code class="w"/></pre>

<p>XREF HERE covers <code>for</code> loops in greater detail and shows many other ways to use <span class="keep-together">iterators.</span></p>

<p><a contenteditable="false" data-primary="break expressions" data-type="indexterm" id="idm45625505891016"/> A <code>break</code> expression exits an enclosing loop. (In Rust, <code>break</code> works only in loops. It is not necessary in <code>match</code> expressions, which are unlike <code>switch</code> statements in this regard.)</p>

<p>Within the body of a <code>loop</code>, you can give <code>break</code> an expression, whose value becomes that of the loop:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Each call to `next_line` returns either `Some(line)`, where</code>
<code class="c1">// `line` is a line of input, or `None`, if we've reached the end of</code>
<code class="c1">// the input. Return the first line that starts with `"answer: "`</code>
<code class="c1">// otherwise, return "answer: nothing".</code>
<code class="kd">let</code><code class="w"> </code><code class="n">answer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">line</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">next_line</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">line</code><code class="p">.</code><code class="n">starts_with</code><code class="p">(</code><code class="s">"answer: "</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">break</code><code class="w"> </code><code class="n">line</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">break</code><code class="w"> </code><code class="s">"answer: nothing"</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>Naturally, all the <code>break</code> expressions within a <code>loop</code> must produce values with the same type, which becomes the type of the <code>loop</code> itself.</p>

<p>A <code>continue</code> expression jumps to the next loop iteration:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Read some data, one line at a time.</code>
<code class="k">for</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">input_lines</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">trimmed</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">trim_comments_and_whitespace</code><code class="p">(</code><code class="n">line</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">trimmed</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Jump back to the top of the loop and</code>
<code class="w">        </code><code class="c1">// move on to the next line of input.</code>
<code class="w">        </code><code class="k">continue</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In a <code>for</code> loop, <code>continue</code> advances to the next value in the collection. If there are no more values, the loop exits. Similarly, in a <code>while</code> loop, <code>continue</code> rechecks the loop condition. If it’s now false, the loop exits.</p>

<p>A loop can be <em>labeled</em> with a lifetime. In the following example, <code>'search:</code> is a label for the outer <code>for</code> loop. Thus <code>break 'search</code> exits that loop, not the inner loop.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="na">'search</code>:
<code class="nc">for</code><code class="w"> </code><code class="n">room</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">apartment</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">spot</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">room</code><code class="p">.</code><code class="n">hiding_spots</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">spot</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="n">keys</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"Your keys are {} in the {}."</code><code class="p">,</code><code class="w"> </code><code class="n">spot</code><code class="p">,</code><code class="w"> </code><code class="n">room</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="k">break</code><code class="w"> </code><code class="nl">'search</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A <code>break</code> can have both a label and a value expression:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Find the square root of the first perfect square</code>
<code class="c1">// in the series.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">sqrt</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="na">'outer</code>: <code class="nc">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">next_number</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">1</code><code class="p">..</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// Found a square root.</code>
<code class="w">            </code><code class="k">break</code><code class="w"> </code><code class="nl">'outer</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// `n` isn't a perfect square, try the next</code>
<code class="w">            </code><code class="k">break</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>Labels can also be used with <code>continue</code>. <a contenteditable="false" data-primary="" data-startref="C06-expressions.html7" data-type="indexterm" id="idm45625505537784"/> <a contenteditable="false" data-primary="" data-startref="C06-expressions.html6" data-type="indexterm" id="idm45625505424456"/> <a contenteditable="false" data-primary="" data-startref="C06-expressions.html5" data-type="indexterm" id="idm45625505422920"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="return Expressions"><div class="sect1" id="return-expressions">
<h1>return Expressions</h1>

<p><a contenteditable="false" data-primary="expressions" data-secondary="return" data-type="indexterm" id="idm45625505420008"/> <a contenteditable="false" data-primary="return expressions" data-type="indexterm" id="idm45625505418504"/> A <code>return</code> expression exits the current function, returning a value to the caller.</p>

<p><code>return</code> without a value is shorthand for <code>return ()</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">f</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w">     </code><code class="c1">// return type omitted: defaults to ()</code>
<code class="w">    </code><code class="k">return</code><code class="p">;</code><code class="w">  </code><code class="c1">// return value omitted: defaults to ()</code>
<code class="p">}</code><code class="w"/></pre>

<p>Like a <code>break</code> expression, <code>return</code> can abandon work in progress. For example, back in XREF HERE, we used the <code>?</code> operator to check for errors after calling a function that can fail:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">File</code>::<code class="n">create</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"/></pre>

<p>and we explained that this is shorthand for a <code>match</code> expression:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">File</code>::<code class="n">create</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nb">Err</code><code class="p">(</code><code class="n">err</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">err</code><code class="p">)</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>This code starts by calling <code>File::create(filename)</code>. If that returns <code>Ok(f)</code>, then the whole <code>match</code> expression evaluates to <code>f</code>, so <code>f</code> is stored in <code>output</code> and we continue with the next line of code following the <code>match</code>.</p>

<p>Otherwise, we’ll match <code>Err(err)</code> and hit the <code>return</code> expression. When that happens, it doesn’t matter that we’re in the middle of evaluating a <code>match</code> expression to determine the value of the variable <code>output</code>. We abandon all of that and exit the enclosing function, returning whatever error we got from <code>File::create()</code>.</p>

<p>We’ll cover the <code>?</code> operator more completely in <a data-type="xref" href="ch06.xhtml#propagating-errors">“Propagating Errors”</a>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Why Rust Has loop"><div class="sect1" id="why-rust-has-loop">
<h1>Why Rust Has loop</h1>

<p><a contenteditable="false" data-primary="flow-sensitive analyses" data-type="indexterm" id="idm45625505231944"/> <a contenteditable="false" data-primary="loop expressions" data-type="indexterm" id="idm45625505230712"/> Several pieces of the Rust compiler analyze the flow of control through your program.</p>

<ul>
	<li>
	<p>Rust checks that every path through a function returns a value of the expected return type. To do this correctly, it needs to know whether or not it’s possible to reach the end of the function.</p>
	</li>
	<li>
	<p>Rust checks that local variables are never used uninitialized. This entails checking every path through a function to make sure there’s no way to reach a place where a variable is used without having already passed through code that initializes it.</p>
	</li>
	<li>
	<p>Rust warns about unreachable code. Code is unreachable if <em>no</em> path through the function reaches it.</p>
	</li>
</ul>

<p>These are called <em>flow-sensitive</em> analyses. They are nothing new; Java has had a “definite assignment” analysis, similar to Rust’s, for years.</p>

<p>When enforcing this sort of rule, a language must strike a balance between simplicity, which makes it easier for programmers to figure out what the compiler is talking about sometimes—and cleverness, which can help eliminate false warnings and cases where the compiler rejects a perfectly safe program. Rust went for simplicity. Its flow-sensitive analyses do not examine loop conditions at all, instead simply assuming that any condition in a program can be either true or false.</p>

<p>This causes Rust to reject some safe programs:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">wait_for_process</code><code class="p">(</code><code class="n">process</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Process</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="kc">true</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">process</code><code class="p">.</code><code class="n">wait</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">process</code><code class="p">.</code><code class="n">exit_code</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w">  </code><code class="c1">// error: mismatched types: expected i32, found ()</code></pre>

<p>The error here is bogus. This function only exits via the <code>return</code> statement, so the fact that the <code>while</code> loop doesn’t produce an <code>i32</code> is irrelevant.</p>

<p>The <code>loop</code> expression is offered as a “say-what-you-mean” solution to this problem.</p>

<p>Rust’s type system is affected by control flow, too. Earlier we said that all branches of an <code>if</code> expression must have the same type. But it would be silly to enforce this rule on blocks that end with a <code>break</code> or <code>return</code> expression, an infinite <code>loop</code>, or a call to <code>panic!()</code> or <code>std::process::exit()</code>. What all those expressions have in common is that they never finish in the usual way, producing a value. A <code>break</code> or <code>return</code> exits the current block abruptly; an infinite <code>loop</code> never finishes at all; and so on.</p>

<p>So in Rust, these expressions don’t have a normal type. <a contenteditable="false" data-primary="! type" data-type="indexterm" id="idm45625505160296"/> Expressions that don’t finish normally are assigned the special type <code>!</code>, and they’re exempt from the rules about types having to match. You can see <code>!</code> in the function signature of <code>std::process::exit()</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">exit</code><code class="p">(</code><code class="n">code</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">!</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="divergent function" data-type="indexterm" id="idm45625505150456"/> The <code>!</code> means that <code>exit()</code> never returns. It’s a <em>divergent function</em>.</p>

<p>You can write divergent functions of your own using the same syntax, and this is perfectly natural in some cases:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">serve_forever</code><code class="p">(</code><code class="n">socket</code>: <code class="nc">ServerSocket</code><code class="p">,</code><code class="w"> </code><code class="n">handler</code>: <code class="nc">ServerHandler</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">!</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">socket</code><code class="p">.</code><code class="n">listen</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">socket</code><code class="p">.</code><code class="n">accept</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">handler</code><code class="p">.</code><code class="n">handle</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Of course, Rust then considers it an error if the function can return normally.</p>

<p>This concludes the part of this chapter that focuses on control flow. The rest covers Rust functions, methods, and operators.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Function and Method Calls"><div class="sect1" id="function-and-method-calls">
<h1>Function and Method Calls</h1>

<p><a contenteditable="false" data-primary="expressions" data-secondary="function/method calls" data-type="indexterm" id="idm45625505026872"/> <a contenteditable="false" data-primary="functions" data-secondary="calling" data-type="indexterm" id="idm45625505025368"/> <a contenteditable="false" data-primary="methods" data-secondary="calling" data-type="indexterm" id="idm45625505023832"/> The syntax for calling functions and methods is the same in Rust as in many other languages:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">gcd</code><code class="p">(</code><code class="mi">1302</code><code class="p">,</code><code class="w"> </code><code class="mi">462</code><code class="p">);</code><code class="w">  </code><code class="c1">// function call</code>

<code class="kd">let</code><code class="w"> </code><code class="n">room</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">player</code><code class="p">.</code><code class="n">location</code><code class="p">();</code><code class="w">  </code><code class="c1">// method call</code></pre>

<p>In the second example here, <code>player</code> is a variable of the made-up type <code>Player</code>, which has a made-up <code>.location()</code> method. (We’ll show how to define your own methods when we start talking about user-defined types in <a data-type="xref" href="ch08.xhtml#structs">Chapter 8</a>.)</p>

<p>Rust usually makes a sharp distinction between references and the values they refer to. If you pass a <code>&amp;i32</code> to a function that expects an <code>i32</code>, that’s a type error. You’ll notice that the <code>.</code> operator relaxes those rules a bit. In the method call <code>player.location()</code>, <code>player</code> might be a <code>Player</code>, a reference of type <code>&amp;Player</code>, or a smart pointer of type <code>Box&lt;Player&gt;</code> or <code>Rc&lt;Player&gt;</code>. The <code>.location()</code> method might take the player either by value or by reference. The same <code>.location()</code> syntax works in all cases, because Rust’s <code>.</code> operator automatically dereferences <code>player</code> or borrows a reference to it as needed.</p>

<p>A third syntax is used for calling static methods, like <code>Vec::new()</code>.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">numbers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w">  </code><code class="c1">// static method call</code></pre>

<p>The difference between static and nonstatic methods is the same as in object-oriented languages: nonstatic methods are called on values (like <code>my_vec.len()</code>), and static methods are called on types (like <code>Vec::new()</code>).</p>

<p>Naturally, method calls can be chained:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// From the Actix-based web server in chapter 2:</code>
<code class="n">server</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">bind</code><code class="p">(</code><code class="s">"127.0.0.1:3000"</code><code class="p">).</code><code class="n">expect</code><code class="p">(</code><code class="s">"error binding server to address"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="n">run</code><code class="p">().</code><code class="n">expect</code><code class="p">(</code><code class="s">"error running server"</code><code class="p">);</code><code class="w"/></pre>

<p>One quirk of Rust syntax is that in a function call or method call, the usual syntax for generic types, <code>Vec&lt;T&gt;</code>, does not work:</p>

<pre data-code-language="rust" data-testing-pragma="oneliners" data-type="programlisting">
<code class="k">return</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code>::<code class="n">with_capacity</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code><code class="w">  </code><code class="c1">// error: something about chained comparisons</code>

<code class="kd">let</code><code class="w"> </code><code class="n">ramp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">n</code><code class="p">).</code><code class="n">collect</code><code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;&gt;</code><code class="p">();</code><code class="w">  </code><code class="c1">// same error</code></pre>

<p>The problem is that in expressions, <code>&lt;</code> is the less-than operator. The Rust compiler helpfully suggests writing <code>::&lt;T&gt;</code> instead of <code>&lt;T&gt;</code> in this case, and that solves the <span class="keep-together">problem:</span></p>

<pre data-code-language="rust" data-testing-pragma="oneliners" data-type="programlisting">
<code class="k">return</code><code class="w"> </code><code class="nb">Vec</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code>::<code class="n">with_capacity</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code><code class="w">  </code><code class="c1">// ok, using ::&lt;</code>

<code class="kd">let</code><code class="w"> </code><code class="n">ramp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">n</code><code class="p">).</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;&gt;</code><code class="p">();</code><code class="w">  </code><code class="c1">// ok, using ::&lt;</code></pre>

<p>The symbol <code>::&lt;...&gt;</code> is affectionately known in the Rust community as the <em class="keep-together">turbofish</em>.</p>

<p>Alternatively, it is often possible to drop the type parameters and let Rust infer them:</p>

<pre data-code-language="rust" data-testing-pragma="oneliners" data-type="programlisting">
<code class="k">return</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">with_capacity</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code><code class="w">  </code><code class="c1">// ok, if the fn return type is Vec&lt;i32&gt;</code>

<code class="kd">let</code><code class="w"> </code><code class="n">ramp</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">n</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w">  </code><code class="c1">// ok, variable's type is given</code></pre>

<p>It’s considered good style to omit the types whenever they can be inferred.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Fields and Elements"><div class="sect1" id="fields-and-elements">
<h1>Fields and Elements</h1>

<p><a contenteditable="false" data-primary="elements, expressions and" data-type="indexterm" id="idm45625504742792"/> <a contenteditable="false" data-primary="expressions" data-secondary="fields and elements" data-type="indexterm" id="idm45625504741592"/> <a contenteditable="false" data-primary="fields, expressions and" data-type="indexterm" id="idm45625504740056"/> <a contenteditable="false" data-primary="tuples" data-type="indexterm" id="idm45625504738792"/> The fields of a struct are accessed using familiar syntax. Tuples are the same except that their fields have numbers rather than names:</p>

<pre data-code-language="rust" data-testing-pragma="oneliners" data-type="programlisting">
<code class="n">game</code><code class="p">.</code><code class="n">black_pawns</code><code class="w">   </code><code class="c1">// struct field</code>
<code class="n">coords</code><code class="p">.</code><code class="mi">1</code><code class="w">           </code><code class="c1">// tuple element</code></pre>

<p>If the value to the left of the dot is a reference or smart pointer type, it is automatically dereferenced, just as for method calls.</p>

<p class="pagebreak-before">Square brackets access the elements of an array, a slice, or a vector:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">pieces</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w">          </code><code class="c1">// array element</code></pre>

<p>The value to the left of the brackets is automatically dereferenced.</p>

<p><a contenteditable="false" data-primary="lvalues" data-type="indexterm" id="idm45625504640040"/> Expressions like these three are called <em>lvalues</em>, because they can appear on the left side of an assignment:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">game</code><code class="p">.</code><code class="n">black_pawns</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mh">0x00ff0000_00000000_</code><code class="k">u64</code><code class="p">;</code><code class="w"/>
<code class="n">coords</code><code class="p">.</code><code class="mi">1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="n">pieces</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Piece</code>::<code class="n">new</code><code class="p">(</code><code class="n">Black</code><code class="p">,</code><code class="w"> </code><code class="n">Knight</code><code class="p">,</code><code class="w"> </code><code class="n">coords</code><code class="p">));</code><code class="w"/></pre>

<p>Of course, this is permitted only if <code>game</code>, <code>coords</code>, and <code>pieces</code> are declared as <code>mut</code> <span class="keep-together">variables.</span></p>

<p>Extracting a slice from an array or vector is straightforward:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">second_half</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">game_moves</code><code class="p">[</code><code class="n">midpoint</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">end</code><code class="p">];</code><code class="w"/></pre>

<p>Here <code>game_moves</code> may be either an array, a slice, or a vector; the result, regardless, is a borrowed slice of length <code>end - midpoint</code>. <code>game_moves</code> is considered borrowed for the lifetime of <code>second_half</code>.</p>

<p><a contenteditable="false" data-primary="half-open ranges" data-type="indexterm" id="idm45625504553320"/> <a contenteditable="false" data-primary="exclusive (half-open) ranges" data-type="indexterm" id="idm45625504552088"/> <a contenteditable="false" data-primary="ranges" data-secondary="half-open" data-type="indexterm" id="idm45625504550856"/> The <code>..</code> operator allows either operand to be omitted; it produces up to four different types of object depending on which operands are present:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="p">..</code><code class="w">      </code><code class="c1">// RangeFull</code>
<code class="n">a</code><code class="w"> </code><code class="p">..</code><code class="w">    </code><code class="c1">// RangeFrom { start: a }</code>
<code class="p">..</code><code class="w"> </code><code class="n">b</code><code class="w">    </code><code class="c1">// RangeTo { end: b }</code>
<code class="n">a</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">b</code><code class="w">  </code><code class="c1">// Range { start: a, end: b }</code></pre>

<p>These ranges are <em>half-open</em>: they include the start value, if any, but not the end value. The range <code>0 .. 3</code> includes the numbers <code>0</code>, <code>1</code>, and <code>2</code>.</p>

<p><a contenteditable="false" data-primary="inclusive (closed) ranges" data-type="indexterm" id="idm45625504471688"/> <a contenteditable="false" data-primary="closed (inclusive) ranges" data-type="indexterm" id="idm45625504470296"/> <a contenteditable="false" data-primary="ranges" data-secondary="closed" data-type="indexterm" id="idm45625504469064"/> <a contenteditable="false" data-primary="ranges" data-secondary="inclusive" data-type="indexterm" id="idm45625504467528"/> The <code>..=</code> operator produces <em>closed</em> ranges, that do include the end value:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="p">..</code><code class="o">=</code><code class="w"> </code><code class="n">b</code><code class="w">    </code><code class="c1">// RangeToInclusive { end: b }</code>
<code class="n">a</code><code class="w"> </code><code class="p">..</code><code class="o">=</code><code class="w"> </code><code class="n">b</code><code class="w">  </code><code class="c1">// RangeInclusive::new(a, b)</code></pre>

<p>For example, the range <code>0 ..= 3</code> includes the numbers <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>.</p>

<p>Only ranges that include a start value are iterable, since a loop must have somewhere to start. But in array slicing, all six forms are useful. If the start or end of the range is omitted, it defaults to the start or end of the data being sliced.</p>

<p>So an implementation of quicksort, the classic divide-and-conquer sorting algorithm, might look, in part, like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">quicksort</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nb">Ord</code><code class="o">&gt;</code><code class="p">(</code><code class="n">slice</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="p">[</code><code class="n">T</code><code class="p">])</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">slice</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="p">;</code><code class="w">  </code><code class="c1">// Nothing to sort.</code>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Partition the slice into two parts, front and back.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">pivot_index</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">partition</code><code class="p">(</code><code class="n">slice</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="c1">// Recursively sort the front half of `slice`.</code>
<code class="w">    </code><code class="n">quicksort</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">slice</code><code class="p">[..</code><code class="w"> </code><code class="n">pivot_index</code><code class="p">]);</code><code class="w"/>

<code class="w">    </code><code class="c1">// And the back half.</code>
<code class="w">    </code><code class="n">quicksort</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">slice</code><code class="p">[</code><code class="n">pivot_index</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="p">..]);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Reference Operators"><div class="sect1" id="reference-operators">
<h1>Reference Operators</h1>

<p><a contenteditable="false" data-primary="* operator" data-type="indexterm" id="idm45625504427672"/> <a contenteditable="false" data-primary="expressions" data-secondary="reference operators" data-type="indexterm" id="idm45625504321928"/> <a contenteditable="false" data-primary="reference operators" data-type="indexterm" id="idm45625504320392"/> The address-of operators, <code>&amp;</code> and <code>&amp;mut</code>, are covered in <a data-type="xref" href="ch04.xhtml#references">Chapter 4</a>.</p>

<p>The unary <code>*</code> operator is used to access the value pointed to by a reference. As we’ve seen, Rust automatically follows references when you use the <code>.</code> operator to access a field or method, so the <code>*</code> operator is necessary only when we want to read or write the entire value that the reference points to.</p>

<p>For example, sometimes an iterator produces references, but the program needs the underlying values:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">padovan</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u64</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">compute_padovan_sequence</code><code class="p">(</code><code class="n">n</code><code class="p">);</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">elem</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">padovan</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">draw_triangle</code><code class="p">(</code><code class="n">turtle</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">elem</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In this example, the type of <code>elem</code> is <code>&amp;u64</code>, so <code>*elem</code> is a <code>u64</code>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Arithmetic, Bitwise, Comparison, and Logical Operators"><div class="sect1" id="arithmetic-bitwise-comparison-and-logical-operators">
<h1>Arithmetic, Bitwise, Comparison, and Logical Operators</h1>

<p><a contenteditable="false" data-primary="binary operators" data-type="indexterm" id="idm45625504191064"/> Rust’s binary operators are like those in many other languages. To save time, we assume familiarity with one of those languages, and focus on the few points where Rust departs from tradition.</p>

<p><a contenteditable="false" data-primary="arithmetic operators" data-type="indexterm" id="idm45625504189336"/> <a contenteditable="false" data-primary="operators" data-secondary="arithmetic" data-type="indexterm" id="idm45625504187880"/> Rust has the usual arithmetic operators, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code>. As mentioned in <a data-type="xref" href="ch02.xhtml#basic-types">Chapter 2</a>, integer overflow is detected, and causes a panic, in debug builds. The standard library provides methods like <code>a.wrapping_add(b)</code> for unchecked arithmetic.</p>

<p>Dividing an integer by zero triggers a panic even in release builds. Integers have a method <code>a.checked_div(b)</code> that returns an <code>Option</code> (<code>None</code> if <code>b</code> is zero) and never <span class="keep-together">panics.</span></p>

<p><a contenteditable="false" data-primary="- operator" data-type="indexterm" id="idm45625504283512"/> Unary <code>-</code> negates a number. It is supported for all the numeric types except unsigned integers. There is no unary <code>+</code> operator.</p>

<pre data-code-language="rust" data-testing-pragma="oneliners" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">100</code><code class="p">);</code><code class="w">     </code><code class="c1">// -100</code>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">100</code><code class="k">u32</code><code class="p">);</code><code class="w">  </code><code class="c1">// error: can't apply unary `-` to type `u32`</code>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="o">+</code><code class="mi">100</code><code class="p">);</code><code class="w">     </code><code class="c1">// error: expected expression, found `+`</code></pre>

<p>As in C, <code>a % b</code> computes the remainder, or modulus, of division. The result has the same sign as the left-hand operand. Note that <code>%</code> can be used on floating-point <span class="keep-together">numbers</span> as well as integers:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1234.567</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mf">10.0</code><code class="p">;</code><code class="w">  </code><code class="c1">// approximately 4.567</code></pre>

<p><a contenteditable="false" data-primary="bitwise integer operators" data-type="indexterm" id="idm45625504149384"/> <a contenteditable="false" data-primary="operators" data-secondary="bitwise" data-type="indexterm" id="idm45625504148168"/> Rust also inherits C’s bitwise integer operators, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>. However, Rust uses <code>!</code> instead of <code>~</code> for bitwise NOT:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">hi</code>: <code class="kt">u8</code> <code class="o">=</code><code class="w"> </code><code class="mh">0xe0</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">lo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">!</code><code class="n">hi</code><code class="p">;</code><code class="w">  </code><code class="c1">// 0x1f</code></pre>

<p>This means that <code>!n</code> can’t be used on an integer <code>n</code> to mean “n is zero.” For that, write <code>n == 0</code>.</p>

<p>Bit shifting is always sign-extending on signed integer types and zero-extending on unsigned integer types. Since Rust has unsigned integers, it does not need Java’s <code>&gt;&gt;&gt;</code> operator.</p>

<p>Bitwise operations have higher precedence than comparisons, unlike C, so if you write <code>x &amp; BIT != 0</code>, that means <code>(x &amp; BIT) != 0</code>, as you probably intended. This is much more useful than C’s interpretation, <code>x &amp; (BIT != 0)</code>, which tests the wrong bit!</p>

<p><a contenteditable="false" data-primary="comparison operators" data-type="indexterm" id="idm45625504068376"/> <a contenteditable="false" data-primary="operators" data-secondary="comparison" data-type="indexterm" id="idm45625504067096"/> Rust’s comparison operators are <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. The two values being compared must have the same type.</p>

<p><a contenteditable="false" data-primary="logical operators" data-type="indexterm" id="idm45625504062744"/> <a contenteditable="false" data-primary="operators" data-secondary="logical" data-type="indexterm" id="idm45625504061512"/> Rust also has the two short-circuiting logical operators <code>&amp;&amp;</code> and <code>||</code>. Both operands must have the exact type <code>bool</code>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Assignment"><div class="sect1" id="assignment">
<h1>Assignment</h1>

<p><a contenteditable="false" data-primary="= operator" data-type="indexterm" id="idm45625504056984"/> <a contenteditable="false" data-primary="assignment" data-secondary="expressions" data-type="indexterm" id="idm45625504055752"/> <a contenteditable="false" data-primary="expressions" data-secondary="assignment" data-type="indexterm" id="idm45625504054216"/> The <code>=</code> operator can be used to assign to <code>mut</code> variables and their fields or elements. But assignment is not as common in Rust as in other languages, since variables are immutable by default.</p>

<p>As described in <a data-type="xref" href="ch03.xhtml#ownership">Chapter 3</a>, if the value has a non-<code>Copy</code> type, assignment <em>moves</em> it into the destination. Ownership of the value is transferred from the source to the destination. The destination’s prior value, if any, is dropped.</p>

<p>Compound assignment is supported:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">total</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">item</code><code class="p">.</code><code class="n">price</code><code class="p">;</code><code class="w"/></pre>

<p>This is equivalent to <code>total = total + item.price;</code>. Other operators are supported too: <code>-=</code>, <code>*=</code>, and so forth. The full list is given in <a data-type="xref" href="#expressions-table">Table 5-1</a>, at the end of this chapter.</p>

<p>Unlike C, Rust doesn’t support chaining assignment: you can’t write <code>a = b = 3</code> to assign the value <code>3</code> to both <code>a</code> and <code>b</code>. Assignment is rare enough in Rust that you won’t miss this shorthand.</p>

<p>Rust does not have C’s increment and decrement operators <code>++</code> and <code>--</code>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Type Casts"><div class="sect1" id="type-casts">
<h1>Type Casts</h1>

<p><a contenteditable="false" data-primary="casts" data-type="indexterm" id="idm45625504011000"/> <a contenteditable="false" data-primary="expressions" data-secondary="type casts" data-type="indexterm" id="idm45625504009768"/> <a contenteditable="false" data-primary="types" data-secondary="casts and" data-type="indexterm" id="idm45625504008232"/> Converting a value from one type to another usually requires an explicit cast in Rust. Casts use the <code>as</code> keyword:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">17</code><code class="p">;</code><code class="w">              </code><code class="c1">// x is type i32</code>
<code class="kd">let</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">usize</code><code class="p">;</code><code class="w">  </code><code class="c1">// convert to usize</code></pre>

<p>Several kinds of casts are permitted:</p>

<ul>
	<li>
	<p>Numbers may be cast from any of the built-in numeric types to any other.</p>

	<p>Casting an integer to another integer type is always well-defined. Converting to a narrower type results in truncation. A signed integer cast to a wider type is sign-extended; an unsigned integer is zero-extended; and so on. In short, there are no surprises.</p>

	<p>Converting from a floating-point type to an integer type rounds towards zero: the value of <code>-1.99 as i32</code> is <code>-1</code>. If the value is too large to fit in the integer type, the cast produces the closest value that the integer type can represent: the value of <code>1e6 as u8</code> is <code>255</code>.</p>
	</li>
	<li>
	<p>Values of type <code>bool</code>, <code>char</code>, or of a C-like <code>enum</code> type, may be cast to any integer type. (We’ll cover enums in <a data-type="xref" href="ch09.xhtml#enums-and-patterns">Chapter 9</a>.)</p>

	<p>Casting in the other direction is not allowed, as <code>bool</code>, <code>char</code>, and <code>enum</code> types all have restrictions on their values that would have to be enforced with run-time checks. For example, casting a <code>u16</code> to type <code>char</code> is banned because some <code>u16</code> values, like <code>0xd800</code>, correspond to Unicode surrogate code points and therefore would not make valid <code>char</code> values. There is a standard method, <code>std::char::from_u32()</code>, which performs the run-time check and returns an <code>Option&lt;char&gt;</code>; but more to the point, the need for this kind of conversion has grown rare. We typically convert whole strings or streams at once, and algorithms on Unicode text are often nontrivial and best left to libraries.</p>

	<p>As an exception, a <code>u8</code> may be cast to type <code>char</code>, since all integers from 0 to 255 are valid Unicode code points for <code>char</code> to hold.</p>
	</li>
	<li>
	<p>Some casts involving unsafe pointer types are also allowed. See XREF HERE.</p>
	</li>
</ul>

<p>We said that a conversion <em>usually</em> requires a cast. A few conversions involving reference types are so straightforward that the language performs them even without a cast. One trivial example is converting a <code>mut</code> reference to a non-<code>mut</code> reference.</p>

<p class="pagebreak-before">Several more significant automatic conversions can happen, though:</p>

<ul>
	<li>
	<p>Values of type <code>&amp;String</code> auto-convert to type <code>&amp;str</code> without a cast.</p>
	</li>
	<li>
	<p>Values of type <code>&amp;Vec&lt;i32&gt;</code> auto-convert to <code>&amp;[i32]</code>.</p>
	</li>
	<li>
	<p>Values of type <code>&amp;Box&lt;Chessboard&gt;</code> auto-convert to <code>&amp;Chessboard</code>.</p>
	</li>
</ul>

<p><a contenteditable="false" data-primary="deref coercions" data-type="indexterm" id="idm45625503936520"/> These are called <em>deref coercions</em>, because they apply to types that implement the <code>Deref</code> built-in trait. The purpose of Deref coercion is to make smart pointer types, like <code>Box</code>, behave as much like the underlying value as possible. Using a <code>Box&lt;Chessboard&gt;</code> is mostly just like using a plain <code>Chessboard</code>, thanks to <code>Deref</code>.</p>

<p>User-defined types can implement the <code>Deref</code> trait, too. When you need to write your own smart pointer type, see XREF HERE.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Closures"><div class="sect1" id="expressions-closures">
<h1>Closures</h1>

<p><a contenteditable="false" data-primary="closures" data-type="indexterm" id="idm45625503908568"/> <a contenteditable="false" data-primary="expressions" data-secondary="closures" data-type="indexterm" id="idm45625503907336"/> Rust has <em>closures</em>, lightweight function-like values. A closure usually consists of an argument list, given between vertical bars, followed by an expression:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">is_even</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/></pre>

<p>Rust infers the argument types and return type. You can also write them out explicitly, as you would for a function. If you do specify a return type, then the body of the closure must be a block, for the sake of syntactic sanity:</p>

<pre data-code-language="rust" data-testing-pragma="oneliners" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">is_even</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">|</code><code class="n">x</code>: <code class="kt">u64</code><code class="o">|</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="nc">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">  </code><code class="c1">// error</code>

<code class="kd">let</code><code class="w"> </code><code class="n">is_even</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">|</code><code class="n">x</code>: <code class="kt">u64</code><code class="o">|</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// ok</code></pre>

<p>Calling a closure uses the same syntax as calling a function:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">is_even</code><code class="p">(</code><code class="mi">14</code><code class="p">),</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/></pre>

<p>Closures are one of Rust’s most delightful features, and there is a great deal more to be said about them. We shall say it in XREF HERE.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Precedence and Associativity"><div class="sect1" id="precedence-and-associativity">
<h1>Precedence and Associativity</h1>

<p><a contenteditable="false" data-primary="expressions" data-secondary="precedence and associativity" data-type="indexterm" id="C06-expressions.html8"/> <a contenteditable="false" data-primary="expressions" data-secondary="syntax" data-type="indexterm" id="C06-expressions.html9"/> <a data-type="xref" href="#expressions-table">Table 5-1</a> gives a summary of Rust expression syntax. Operators are listed in order of precedence, from highest to lowest. (Like most programming languages, <a contenteditable="false" data-primary="operator precedence" data-type="indexterm" id="idm45625503792376"/> Rust has <em>operator precedence</em> to determine the order of operations when an expression contains multiple adjacent operators. For example, in <code>limit &lt; 2 * broom.size + 1</code>, the <code>.</code> operator has the highest precedence, so the field access happens first.)</p>

<table id="expressions-table">
	<caption><span class="label">Table 5-1. </span>Expressions</caption>
	<thead>
		<tr>
			<th>Expression type</th>
			<th>Example</th>
			<th>Related traits</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Array literal</td>
			<td><code>[1, 2, 3]</code></td>
		</tr>
		<tr>
			<td>Repeat array literal</td>
			<td><code>[0; 50]</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Tuple</td>
			<td><code>(6, "crullers")</code></td>
		</tr>
		<tr>
			<td>Grouping</td>
			<td><code>(2 + 2)</code></td>
		</tr>
		<tr>
			<td>Block</td>
			<td><code>{ f(); g() }</code></td>
		</tr>
		<tr>
			<td rowspan="11">Control flow expressions</td>
			<td><code>if ok { f() }</code></td>
		</tr>
		<tr>
			<td><code>if ok { 1 } else { 0 }</code></td>
		</tr>
		<tr>
			<td><code>if let Some(x) = f() { x } else { 0 }</code></td>
		</tr>
		<tr>
			<td><code>match x { None =&gt; 0, _ =&gt; 1 }</code></td>
		</tr>
		<tr>
			<td><code>for v in e { f(v); }</code></td>
			<td><code>std::iter::IntoIterator</code></td>
		</tr>
		<tr>
			<td><code>while ok { ok = f(); }</code></td>
		</tr>
		<tr>
			<td><code>while let Some(x) = it.next() { f(x); }</code></td>
		</tr>
		<tr>
			<td><code>loop { next_event(); }</code></td>
		</tr>
		<tr>
			<td><code>break</code></td>
		</tr>
		<tr>
			<td><code>continue</code></td>
		</tr>
		<tr>
			<td><code>return 0</code></td>
		</tr>
		<tr>
			<td>Macro invocation</td>
			<td><code>println!("ok")</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Path</td>
			<td><code>std::f64::consts::PI</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Struct literal</td>
			<td><code>Point {x: 0, y: 0}</code></td>
		</tr>
		<tr>
			<td>Tuple field access</td>
			<td><code>pair.0</code></td>
			<td><code>Deref</code>, <code>DerefMut</code></td>
		</tr>
		<tr>
			<td>Struct field access</td>
			<td><code>point.x</code></td>
			<td><code>Deref</code>, <code>DerefMut</code></td>
		</tr>
		<tr>
			<td>Method call</td>
			<td><code>point.translate(50, 50)</code></td>
			<td><code>Deref</code>, <code>DerefMut</code></td>
		</tr>
		<tr>
			<td>Function call</td>
			<td><code>stdin()</code></td>
			<td><code>Fn(Arg0, ...) -&gt; T</code>,<br/>
			<code>FnMut(Arg0, ...) -&gt; T</code>,<br/>
<code>FnOnce(Arg0, ...) -&gt; T</code></td>
		</tr>
		<tr>
			<td>Index</td>
			<td><code>arr[0]</code></td>
			<td><code>Index</code>, <code>IndexMut</code><br/>
			<code>Deref</code>, <code>DerefMut</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Error check</td>
			<td><code>create_dir("tmp")?</code></td>
		</tr>
		<tr>
			<td>Logical/bitwise NOT</td>
			<td><code>!ok</code></td>
			<td><code>Not</code></td>
		</tr>
		<tr>
			<td>Negation</td>
			<td><code>-num</code></td>
			<td><code>Neg</code></td>
		</tr>
		<tr>
			<td>Dereference</td>
			<td><code>*ptr</code></td>
			<td><code>Deref</code>, <code>DerefMut</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Borrow</td>
			<td><code>&amp;val</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Type cast</td>
			<td><code>x as u32</code></td>
		</tr>
		<tr>
			<td>Multiplication</td>
			<td><code>n * 2</code></td>
			<td><code>Mul</code></td>
		</tr>
		<tr>
			<td>Division</td>
			<td><code>n / 2</code></td>
			<td><code>Div</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Remainder (modulus)</td>
			<td><code>n % 2</code></td>
			<td><code>Rem</code></td>
		</tr>
		<tr>
			<td>Addition</td>
			<td><code>n + 1</code></td>
			<td><code>Add</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Subtraction</td>
			<td><code>n - 1</code></td>
			<td><code>Sub</code></td>
		</tr>
		<tr>
			<td>Left shift</td>
			<td><code>n &lt;&lt; 1</code></td>
			<td><code>Shl</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Right shift</td>
			<td><code>n &gt;&gt; 1</code></td>
			<td><code>Shr</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Bitwise AND</td>
			<td><code>n &amp; 1</code></td>
			<td><code>BitAnd</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Bitwise exclusive OR</td>
			<td><code>n ^ 1</code></td>
			<td><code>BitXor</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Bitwise OR</td>
			<td><code>n | 1</code></td>
			<td><code>BitOr</code></td>
		</tr>
		<tr>
			<td>Less than</td>
			<td><code>n &lt; 1</code></td>
			<td><code>std::cmp::PartialOrd</code></td>
		</tr>
		<tr>
			<td>Less than or equal</td>
			<td><code>n &lt;= 1</code></td>
			<td><code>std::cmp::PartialOrd</code></td>
		</tr>
		<tr>
			<td>Greater than</td>
			<td><code>n &gt; 1</code></td>
			<td><code>std::cmp::PartialOrd</code></td>
		</tr>
		<tr>
			<td>Greater than or equal</td>
			<td><code>n &gt;= 1</code></td>
			<td><code>std::cmp::PartialOrd</code></td>
		</tr>
		<tr>
			<td>Equal</td>
			<td><code>n == 1</code></td>
			<td><code>std::cmp::PartialEq</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Not equal</td>
			<td><code>n != 1</code></td>
			<td><code>std::cmp::PartialEq</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Logical AND</td>
			<td><code>x.ok &amp;&amp; y.ok</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Logical OR</td>
			<td><code>x.ok || backup.ok</code></td>
		</tr>
		<tr class="border_bottom">
			<td>Range</td>
			<td><code>start .. stop</code></td>
		</tr>
		<tr>
			<td>Assignment</td>
			<td><code>x = val</code></td>
		</tr>
		<tr>
			<td rowspan="10">Compound assignment</td>
			<td><code>x *= 1</code></td>
			<td><code>MulAssign</code></td>
		</tr>
		<tr>
			<td><code>x /= 1</code></td>
			<td><code>DivAssign</code></td>
		</tr>
		<tr>
			<td><code>x %= 1</code></td>
			<td><code>RemAssign</code></td>
		</tr>
		<tr>
			<td><code>x += 1</code></td>
			<td><code>AddAssign</code></td>
		</tr>
		<tr>
			<td><code>x -= 1</code></td>
			<td><code>SubAssign</code></td>
		</tr>
		<tr>
			<td><code>x &lt;&lt;= 1</code></td>
			<td><code>ShlAssign</code></td>
		</tr>
		<tr>
			<td><code>x &gt;&gt;= 1</code></td>
			<td><code>ShrAssign</code></td>
		</tr>
		<tr>
			<td><code>x &amp;= 1</code></td>
			<td><code>BitAndAssign</code></td>
		</tr>
		<tr>
			<td><code>x ^= 1</code></td>
			<td><code>BitXorAssign</code></td>
		</tr>
		<tr class="border_bottom">
			<td><code>x |= 1</code></td>
			<td><code>BitOrAssign</code></td>
		</tr>
		<tr>
			<td>Closure</td>
			<td><code>|x, y| x + y</code></td>
		</tr>
	</tbody>
</table>

<p>All of the operators that can usefully be chained are left-associative. That is, a chain of operations such as <code>a - b - c</code> is grouped as <code>(a - b) - c</code>, not <code>a - (b - c)</code>. The operators that can be chained in this way are all the ones you might expect:</p>

<pre class="ignore" data-type="programlisting">
*   /   %   +   -   &lt;&lt;   &gt;&gt;   &amp;   ^   |   &amp;&amp;   ||   as</pre>

<p>The comparison operators, the assignment operators, and the range operator <code>..</code> can’t be chained at all. <a contenteditable="false" data-primary="" data-startref="C06-expressions.html9" data-type="indexterm" id="idm45625503620424"/> <a contenteditable="false" data-primary="" data-startref="C06-expressions.html8" data-type="indexterm" id="idm45625503618920"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Onward"><div class="sect1" id="onward">
<h1>Onward</h1>

<p>Expressions are what we think of as “running code.” They’re the part of a Rust program that compiles to machine instructions. Yet they are a small fraction of the whole language.</p>

<p>The same is true in most programming languages. The first job of a program is to run, but that’s not its only job. Programs have to communicate. They have to be testable. They have to stay organized and flexible, so that they can continue to evolve. They have to interoperate with code and services built by other teams. And even just to run, programs in a statically typed language like Rust need some more tools for organizing data than just tuples and arrays.</p>

<p>Coming up, we’ll spend several chapters talking about features in this area: modules and crates, which give your program structure, and then structs and enums, which do the same for your data.</p>

<p>First, we’ll dedicate a few pages to the important topic of what to do when things go wrong. <a contenteditable="false" data-primary="" data-startref="C06-expressions.html0" data-type="indexterm" id="idm45625503613352"/></p>
</div></section>
</div></section></div></body>
</html>