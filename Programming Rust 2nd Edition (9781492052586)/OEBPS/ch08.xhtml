<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Structs"><div class="chapter" id="structs">
<h1><span class="label">Chapter 8. </span>Structs</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625496612536"><h5>A note for Early Release readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 9th chapter of the final book.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <em>jimb@red-bean.com</em>.</p>
</div></aside>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>Long ago, when shepherds wanted to see if two herds of sheep were isomorphic, they would look for an explicit isomorphism.</p>

<p data-type="attribution">John C. Baez and James Dolan, <a href="https://arxiv.org/abs/math/9802029">“Categorification”</a></p>
</blockquote>

<p><a contenteditable="false" data-primary="structs" data-type="indexterm" id="C09-structs.html0"/> Rust structs, sometimes called <em>structures</em>, resemble <code>struct</code> types in C and C++, classes in Python, and objects in JavaScript. A struct assembles several values of assorted types together into a single value, so you can deal with them as a unit. Given a struct, you can read and modify its individual components. And a struct can have methods associated with it that operate on its components.</p>

<p>Rust has three kinds of struct types, <em>named-field</em>, <em>tuple-like</em>, and <em>unit-like</em>, which differ in how you refer to their components: a named-field struct gives a name to each component, whereas a tuple-like struct identifies them by the order in which they appear. Unit-like structs have no components at all; these are not common, but more useful than you might think.</p>

<p>In this chapter, we’ll explain each kind in detail, and show what they look like in memory. We’ll cover how to add methods to them, how to define generic struct types that work with many different component types, and how to ask Rust to generate implementations of common handy traits for your structs.</p>

<section data-type="sect1" data-pdf-bookmark="Named-Field Structs"><div class="sect1" id="named-field-structs">
<h1>Named-Field Structs</h1>

<p><a contenteditable="false" data-primary="named-field structs" data-type="indexterm" id="C09-structs.html1"/> <a contenteditable="false" data-primary="structs" data-secondary="named-field" data-type="indexterm" id="C09-structs.html2"/> The definition of a named-field struct type looks like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// A rectangle of eight-bit grayscale pixels.</code>
<code class="k">struct</code> <code class="nc">GrayscaleMap</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">pixels</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">size</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This declares a type <code>GrayscaleMap</code> with two fields named <code>pixels</code> and <code>size</code>, of the given types. The convention in Rust is for all types, structs included, to have names that capitalize the first letter of each word, like <code>GrayscaleMap</code>, a convention called <em>CamelCase</em>. Fields and methods are lowercase, with words separated by underscores. This is called <em>snake_case</em>.</p>

<p><a contenteditable="false" data-primary="struct expression" data-type="indexterm" id="idm45625496534184"/> You can construct a value of this type with a <em>struct expression</em>, like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">width</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1024</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">height</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">576</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">image</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">GrayscaleMap</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">pixels</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">width</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">height</code><code class="p">],</code><code class="w"/>
<code class="w">    </code><code class="n">size</code>: <code class="p">(</code><code class="n">width</code><code class="p">,</code><code class="w"> </code><code class="n">height</code><code class="p">)</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>A struct expression starts with the type name (<code>GrayscaleMap</code>), and lists the name and value of each field, all enclosed in curly braces. There’s also shorthand for populating fields from local variables or arguments with the same name:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">new_map</code><code class="p">(</code><code class="n">size</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">),</code><code class="w"> </code><code class="n">pixels</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">GrayscaleMap</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">pixels</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="n">size</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">size</code><code class="p">.</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">GrayscaleMap</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">pixels</code><code class="p">,</code><code class="w"> </code><code class="n">size</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The struct expression <code>GrayscaleMap { pixels, size }</code> is short for <code>GrayscaleMap { pixels: pixels, size: size }</code>. You can use <code>key: value</code> syntax for some fields and shorthand for others in the same struct expression.</p>

<p>To access a struct’s fields, use the familiar <code>.</code> operator:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">image</code><code class="p">.</code><code class="n">size</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="mi">1024</code><code class="p">,</code><code class="w"> </code><code class="mi">576</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">image</code><code class="p">.</code><code class="n">pixels</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">1024</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">576</code><code class="p">);</code><code class="w"/></pre>

<p>Like all other items, structs are private by default, visible only in the module where they’re declared. You can make a struct visible outside its module by prefixing its definition with <code>pub</code>. The same goes for each of its fields, which are also private by default:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// A rectangle of eight-bit grayscale pixels.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">GrayscaleMap</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">pixels</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">size</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Even if a struct is declared <code>pub</code>, its fields can be private:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// A rectangle of eight-bit grayscale pixels.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">GrayscaleMap</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">pixels</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">size</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Other modules can use this struct and any public methods it might have, but can’t access the private fields by name or use struct expressions to create new <code>GrayscaleMap</code> values. That is, creating a struct value requires all the struct’s fields to be visible. This is why you can’t write a struct expression to create a new <code>String</code> or <code>Vec</code>. These standard types are structs, but all their fields are private. To create one, you must use public methods like <code>Vec::new()</code>.</p>

<p>When creating a named-field struct value, you can use another struct of the same type to supply values for fields you omit. In a struct expression, if the named fields are followed by <code>.. EXPR</code>, then any fields not mentioned take their values from <code>EXPR</code>, which must be another value of the same struct type. Suppose we have a struct representing a monster in a game:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// In this game, brooms are monsters. You'll see.</code>
<code class="k">struct</code> <code class="nc">Broom</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">height</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">health</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">position</code>: <code class="p">(</code><code class="kt">f32</code><code class="p">,</code><code class="w"> </code><code class="kt">f32</code><code class="p">,</code><code class="w"> </code><code class="kt">f32</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">intent</code>: <code class="nc">BroomIntent</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="sd">/// Two possible alternatives for what a `Broom` could be working on.</code>
<code class="cp">#[derive(Copy, Clone)]</code><code class="w"/>
<code class="k">enum</code> <code class="nc">BroomIntent</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">FetchWater</code><code class="p">,</code><code class="w"> </code><code class="n">DumpWater</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>The best fairy tale for programmers is <em>The Sorcerer’s Apprentice</em>: a novice magician enchants a broom to do his work for him, but doesn’t know how to stop it when the job is done. Chopping the broom in half with an axe just produces two brooms, each of half the size, but continuing the task with the same blind dedication as the original:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Receive the input Broom by value, taking ownership.</code>
<code class="k">fn</code> <code class="nf">chop</code><code class="p">(</code><code class="n">b</code>: <code class="nc">Broom</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="n">Broom</code><code class="p">,</code><code class="w"> </code><code class="n">Broom</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Initialize `broom1` mostly from `b`, changing only `height`. Since</code>
<code class="w">    </code><code class="c1">// `String` is not `Copy`, `broom1` takes ownership of `b`'s name.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">broom1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Broom</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">height</code>: <code class="nc">b</code><code class="p">.</code><code class="n">height</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">    </code><code class="c1">// Initialize `broom2` mostly from `broom1`. Since `String` is not</code>
<code class="w">    </code><code class="c1">// `Copy`, we must clone `name` explicitly.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">broom2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Broom</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code>: <code class="nc">broom1</code><code class="p">.</code><code class="n">name</code><code class="p">.</code><code class="n">clone</code><code class="p">(),</code><code class="w"> </code><code class="p">..</code><code class="w"> </code><code class="n">broom1</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="w">    </code><code class="c1">// Give each fragment a distinct name.</code>
<code class="w">    </code><code class="n">broom1</code><code class="p">.</code><code class="n">name</code><code class="p">.</code><code class="n">push_str</code><code class="p">(</code><code class="s">" I"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">broom2</code><code class="p">.</code><code class="n">name</code><code class="p">.</code><code class="n">push_str</code><code class="p">(</code><code class="s">" II"</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="p">(</code><code class="n">broom1</code><code class="p">,</code><code class="w"> </code><code class="n">broom2</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p class="pagebreak-before">With that definition in place, we can create a broom, chop it in two, and see what <span class="keep-together">we get:</span> <a contenteditable="false" data-primary="" data-startref="C09-structs.html2" data-type="indexterm" id="idm45625496091912"/> <a contenteditable="false" data-primary="" data-startref="C09-structs.html1" data-type="indexterm" id="idm45625495946632"/></p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">hokey</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Broom</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">name</code>: <code class="s">"Hokey"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">    </code><code class="n">height</code>: <code class="mi">60</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">health</code>: <code class="mi">100</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">position</code>: <code class="p">(</code><code class="mf">100.0</code><code class="p">,</code><code class="w"> </code><code class="mf">200.0</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">intent</code>: <code class="nc">BroomIntent</code>::<code class="n">FetchWater</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">hokey1</code><code class="p">,</code><code class="w"> </code><code class="n">hokey2</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">chop</code><code class="p">(</code><code class="n">hokey</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">hokey1</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="s">"Hokey I"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">hokey1</code><code class="p">.</code><code class="n">health</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">hokey2</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="s">"Hokey II"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">hokey2</code><code class="p">.</code><code class="n">health</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">);</code><code class="w"/></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Tuple-Like Structs"><div class="sect1" id="tuple-like-structs">
<h1>Tuple-Like Structs</h1>

<p><a contenteditable="false" data-primary="structs" data-secondary="tuple-like" data-type="indexterm" id="idm45625495808472"/> <a contenteditable="false" data-primary="tuple-like structs" data-type="indexterm" id="idm45625495806968"/> The second kind of struct type is called a <em>tuple-like struct</em>, because it resembles a tuple:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Bounds</code><code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">);</code><code class="w"/></pre>

<p>You construct a value of this type much as you would construct a tuple, except that you must include the struct name:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">image_bounds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Bounds</code><code class="p">(</code><code class="mi">1024</code><code class="p">,</code><code class="w"> </code><code class="mi">768</code><code class="p">);</code><code class="w"/></pre>

<p>The values held by a tuple-like struct are called <em>elements</em>, just as the values of a tuple are. You access them just as you would a tuple’s:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">image_bounds</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">image_bounds</code><code class="p">.</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">786432</code><code class="p">);</code><code class="w"/></pre>

<p>Individual elements of a tuple-like struct may be public or not:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Bounds</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="k">pub</code><code class="w"> </code><code class="kt">usize</code><code class="p">);</code><code class="w"/></pre>

<p>The expression <code>Bounds(1024, 768)</code> looks like a function call, and in fact it is: defining the type also implicitly defines a function:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">Bounds</code><code class="p">(</code><code class="n">elem0</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="n">elem1</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Bounds</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>At the most fundamental level, named-field and tuple-like structs are very similar. The choice of which to use comes down to questions of legibility, ambiguity, and brevity. If you will use the <code>.</code> operator to get at a value’s components much at all, identifying fields by name provides the reader more information, and is probably more robust against typos. If you will usually use pattern matching to find the elements, tuple-like structs can work nicely.</p>

<p><a contenteditable="false" data-primary="newtypes" data-type="indexterm" id="idm45625495610936"/> Tuple-like structs are good for <em>newtypes</em>, structs with a single component that you define to get stricter type checking. For example, if you are working with ASCII-only text, you might define a newtype like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Ascii</code><code class="p">(</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">);</code><code class="w"/></pre>

<p>Using this type for your ASCII strings is much better than simply passing around <code>Vec&lt;u8&gt;</code> buffers and explaining what they are in the comments. The newtype helps Rust catch mistakes where some other byte buffer is passed to a function expecting ASCII text. We’ll give an example of using newtypes for efficient type conversions in XREF HERE.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Unit-Like Structs"><div class="sect1" id="unit-like-structs">
<h1>Unit-Like Structs</h1>

<p><a contenteditable="false" data-primary="structs" data-secondary="unit-like" data-type="indexterm" id="idm45625495579272"/> <a contenteditable="false" data-primary="unit-like structs" data-type="indexterm" id="idm45625495577768"/> The third kind of struct is a little obscure: it declares a struct type with no elements <span class="keep-together">at all:</span></p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Onesuch</code><code class="p">;</code><code class="w"/></pre>

<p>A value of such a type occupies no memory, much like the unit type <code>()</code>. Rust doesn’t bother actually storing unit-like struct values in memory or generating code to operate on them, because it can tell everything it might need to know about the value from its type alone. But logically, an empty struct is a type with values like any other—or more precisely, a type of which there is only a single value:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">o</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Onesuch</code><code class="p">;</code><code class="w"/></pre>

<p>You’ve already encountered a unit-like struct when reading about the <code>..</code> range operator in <a data-type="xref" href="ch05.xhtml#fields-and-elements">“Fields and Elements”</a>. Whereas an expression like <code>3..5</code> is shorthand for the struct value <code>Range { start: 3, end: 5 }</code>, the expression <code>..</code>, a range omitting both endpoints, is shorthand for the unit-like struct value <code>RangeFull</code>.</p>

<p>Unit-like structs can also be useful when working with traits, which we’ll describe in <a data-type="xref" href="ch10.xhtml#traits-and-generics">Chapter 10</a>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Struct Layout"><div class="sect1" id="struct-layout">
<h1>Struct Layout</h1>

<p><a contenteditable="false" data-primary="structs" data-secondary="layout" data-type="indexterm" id="idm45625495533768"/> In memory, both named-field and tuple-like structs are the same thing: a collection of values, of possibly mixed types, laid out in a particular way in memory. For example, earlier in the chapter we defined this struct:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">GrayscaleMap</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">pixels</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">size</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A <code>GrayscaleMap</code> value is laid out in memory as diagrammed in <a data-type="xref" href="#fig0901">Figure 8-1</a>.</p>

<figure><div id="fig0901" class="figure"><img alt="" src="Images/rust_09in01.png" width="906" height="531"/>
<h6><span class="label">Figure 8-1. </span>A GrayscaleMap structure in memory</h6>
</div></figure>

<p>Unlike C and C++, Rust doesn’t make specific promises about how it will order a struct’s fields or elements in memory; this diagram shows only one possible arrangement. However, Rust does promise to store fields’ values directly in the struct’s block of memory. Whereas JavaScript, Python, and Java would put the <code>pixels</code> and <code>size</code> values each in their own heap-allocated blocks and have <code>GrayscaleMap</code>’s fields point at them, Rust embeds <code>pixels</code> and <code>size</code> directly in the <code>GrayscaleMap</code> value. Only the heap-allocated buffer owned by the <code>pixels</code> vector remains in its own block.</p>

<p>You can ask Rust to lay out structures in a way compatible with C and C++, using the <code>#[repr(C)]</code> attribute. We’ll cover this in detail in XREF HERE.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Defining Methods with impl"><div class="sect1" id="defining-methods-with-impl">
<h1>Defining Methods with impl</h1>

<p><a contenteditable="false" data-primary="impl block" data-type="indexterm" id="C09-structs.html3"/> <a contenteditable="false" data-primary="methods" data-secondary="defining with impl" data-type="indexterm" id="C09-structs.html4"/> <a contenteditable="false" data-primary="structs" data-secondary="defining methods with impl" data-type="indexterm" id="C09-structs.html5"/> Throughout the book we’ve been calling methods on all sorts of values. We’ve pushed elements onto vectors with <code>v.push(e)</code>, fetched their length with <code>v.len()</code>, checked <code>Result</code> values for errors with <code>r.expect("msg")</code>, and so on.</p>

<p>You can define methods on any struct type you define. Rather than appearing inside the struct definition, as in C++ or Java, Rust methods appear in a separate <code>impl</code> block. For example:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// A first-in, first-out queue of characters.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">older</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">char</code><code class="o">&gt;</code><code class="p">,</code><code class="w">   </code><code class="c1">// older elements, eldest last.</code>
<code class="w">    </code><code class="n">younger</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">char</code><code class="o">&gt;</code><code class="w">  </code><code class="c1">// younger elements, youngest last.</code>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Push a character onto the back of a queue.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">push</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">c</code>: <code class="nc">char</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">younger</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">c</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// Pop a character off the front of a queue. Return `Some(c)` if there</code>
<code class="w">    </code><code class="sd">/// was a character to pop, or `None` if the queue was empty.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">pop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">char</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">older</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">younger</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nb">None</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>

<code class="w">            </code><code class="c1">// Bring the elements in younger over to older, and put them in</code>
<code class="w">            </code><code class="c1">// the promised order.</code>
<code class="w">            </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">swap</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">swap</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">older</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">younger</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">older</code><code class="p">.</code><code class="n">reverse</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="c1">// Now older is guaranteed to have something. Vec's pop method</code>
<code class="w">        </code><code class="c1">// already returns an Option, so we're set.</code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">older</code><code class="p">.</code><code class="n">pop</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>An <code>impl</code> block is simply a collection of <code>fn</code> definitions, each of which becomes a method on the struct type named at the top of the block. Here we’ve defined a public struct <code>Queue</code>, and then given it two public methods, <code>push</code> and <code>pop</code>.</p>

<p><a contenteditable="false" data-primary="associated functions" data-type="indexterm" id="idm45625495231496"/> <a contenteditable="false" data-primary="free functions" data-type="indexterm" id="idm45625495230264"/> Methods are also known as <em>associated functions</em>, since they’re associated with a specific type. The opposite of an associated function is a <em>free function</em>, one that is not defined as an <code>impl</code> block’s item.</p>

<p>Rust passes a method the value it’s being called on as its first argument, which must have the special name <code>self</code>. Since <code>self</code>’s type is obviously the one named at the top of the <code>impl</code> block, or a reference to that, Rust lets you omit the type, and write <code>self</code>, <code>&amp;self</code> or <code>&amp;mut self</code> as shorthand for <code>self: Queue</code>, <code>self: &amp;Queue</code> or <code>self: &amp;mut Queue</code>. You can use the longhand forms if you like, but almost all Rust code uses the shorthand, as shown before.</p>

<p>In our example, the <code>push</code> and <code>pop</code> methods refer to the <code>Queue</code>’s fields as <code>self.older</code> and <code>self.younger</code>. Unlike C++ and Java, where the members of the “this” object are directly visible in method bodies as unqualified identifiers, a Rust method must explicitly use <code>self</code> to refer to the value it was called on, similar to the way Python methods use <code>self</code>, and the way JavaScript methods use <code>this</code>.</p>

<p>Since <code>push</code> and <code>pop</code> need to modify the <code>Queue</code>, they both take <code>&amp;mut self</code>. However, when you call a method, you don’t need to borrow the mutable reference yourself; the ordinary method call syntax takes care of that implicitly. So with these definitions in place, you can use <code>Queue</code> like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">q</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">older</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">(),</code><code class="w"> </code><code class="n">younger</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'0'</code><code class="p">);</code><code class="w"/>
<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'1'</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">q</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'0'</code><code class="p">));</code><code class="w"/>

<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'∞'</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">q</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'1'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">q</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'∞'</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">q</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>

<p>Simply writing <code>q.push(...)</code> borrows a mutable reference to <code>q</code>, as if you had written <code>(&amp;mut q).push(...)</code>, since that’s what the <code>push</code> method’s <code>self</code> requires.</p>

<p>If a method doesn’t need to modify its <code>self</code>, then you can define it to take a shared reference instead. For example:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">is_empty</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">older</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">younger</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Again, the method call expression knows which sort of reference to borrow:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">q</code><code class="p">.</code><code class="n">is_empty</code><code class="p">());</code><code class="w"/>
<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'☉'</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">!</code><code class="n">q</code><code class="p">.</code><code class="n">is_empty</code><code class="p">());</code><code class="w"/></pre>

<p>Or, if a method wants to take ownership of <code>self</code>, it can take <code>self</code> by value:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">split</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">char</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">char</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">older</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">younger</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Calling this <code>split</code> method looks like the other method calls:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">q</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">older</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">(),</code><code class="w"> </code><code class="n">younger</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">};</code><code class="w"/>

<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'P'</code><code class="p">);</code><code class="w"/>
<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'D'</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">q</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'P'</code><code class="p">));</code><code class="w"/>
<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'X'</code><code class="p">);</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">older</code><code class="p">,</code><code class="w"> </code><code class="n">younger</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">q</code><code class="p">.</code><code class="n">split</code><code class="p">();</code><code class="w"/>
<code class="c1">// q is now uninitialized.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">older</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="sc">'D'</code><code class="p">]);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">younger</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="sc">'X'</code><code class="p">]);</code><code class="w"/></pre>

<p>But note that, since <code>split</code> takes its <code>self</code> by value, this <em>moves</em> the <code>Queue</code> out of <code>q</code>, leaving <code>q</code> uninitialized. Since <code>split</code>’s <code>self</code> now owns the queue, it’s able to move the individual vectors out of it, and return them to the caller.</p>

<section data-type="sect2" data-pdf-bookmark="Passing Self as a Box, Rc, or Arc"><div class="sect2" id="passing-self-as-a-box-rc-or-arc">
<h2>Passing Self as a Box, Rc, or Arc</h2>

<p>A method’s <code>self</code> argument can also be a <code>Box&lt;Self&gt;</code>, <code>Rc&lt;Self&gt;</code>, or <code>Arc&lt;Self&gt;</code>. Such a method can only be called on a value of the given pointer type. Calling the method passes ownership of the pointer to it.</p>

<p>You won’t usually need to do this. A method that expects <code>self</code> by reference works fine when called on any of those pointer types:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">bq</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">Queue</code>::<code class="n">new</code><code class="p">());</code><code class="w"/>

<code class="c1">// `Queue::push` expects a `&amp;mut Queue`, but `bq` is a `Box&lt;Queue&gt;`.</code>
<code class="c1">// This is fine: Rust borrows a `&amp;mut Queue` from the `Box` for the</code>
<code class="c1">// duration of the call.</code>
<code class="n">bq</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'■'</code><code class="p">);</code><code class="w"/></pre>

<p>For method calls and field access, Rust automatically borrows a reference from pointer types like <code>Box</code>, <code>Rc</code>, and <code>Arc</code>, so <code>&amp;self</code> and <code>&amp;mut self</code> are almost always the right thing in a method signature, along with the occasional <code>self</code>.</p>

<p>But what if the method’s purpose involves managing ownership of the pointer? Suppose we have a tree of nodes like this, some sort of drastically simplified XML:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">rc</code>::<code class="n">Rc</code><code class="p">;</code><code class="w"/>

<code class="k">struct</code> <code class="nc">Node</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">tag</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">children</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">Node</code><code class="o">&gt;&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">Node</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">new</code><code class="p">(</code><code class="n">tag</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Node</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Node</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">tag</code>: <code class="nc">tag</code><code class="p">.</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="n">children</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[],</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Each node has a tag, to indicate what sort of node it is, and a vector of children, held by reference-counted pointers to permit sharing and make their lifetimes a bit more flexible.</p>

<p>Usually, markup nodes have a method that appends a child to its own list, but for the moment, let’s reverse the roles and give <code>Node</code> a method that appends it to some other <code>Node</code>’s children. We could write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">Node</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">append_to</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">parent</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Node</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">parent</code><code class="p">.</code><code class="n">children</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="bp">self</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>But this is unsatisfying. This method calls <code>Rc::new</code> to allocate a fresh heap location and copy <code>self</code> into it, but if the caller already has an <code>Rc&lt;Node&gt;</code>, all that is unnecessary: we should just increment the reference count and push the pointer onto the vector. Wasn’t the whole point of <code>Rc</code> to enable sharing?</p>

<p>Instead, we can write this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">Node</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">append_to</code><code class="p">(</code><code class="bp">self</code>: <code class="nc">Rc</code><code class="o">&lt;</code><code class="n">Self</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">parent</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Node</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">parent</code><code class="p">.</code><code class="n">children</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="bp">self</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>If the caller has an <code>Rc&lt;Node&gt;</code> at hand, it can call <code>append_to</code> directly, passing the <code>Rc</code> by value:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">shared_node</code><code class="p">.</code><code class="n">append_to</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">parent</code><code class="p">);</code><code class="w"/></pre>

<p>This passes ownership of <code>shared_node</code> to the method: no reference counts are adjusted, and there’s certainly no new allocation.</p>

<p>If the caller needs to retain a pointer to the node for later use, then it can clone the <code>Rc</code> first:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">shared_node</code><code class="p">.</code><code class="n">clone</code><code class="p">().</code><code class="n">append_to</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">parent</code><code class="p">);</code><code class="w"/></pre>

<p>Cloning an <code>Rc</code> just bumps its reference count: there’s still no heap allocation or copying. But when the call returns, both <code>shared_node</code> and <code>parent</code>’s vector of children are pointing to the same <code>Node</code>.</p>

<p>Finally, if the caller actually owns the <code>Node</code> outright, then it must create the <code>Rc</code> itself before passing it:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">owned</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Node</code>::<code class="n">new</code><code class="p">(</code><code class="s">"owned directly"</code><code class="p">);</code><code class="w"/>
<code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="n">owned</code><code class="p">).</code><code class="n">append_to</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">parent</code><code class="p">);</code><code class="w"/></pre>

<p>Putting <code>Rc&lt;Self&gt;</code> into the signature of the <code>append_to</code> method makes the caller aware of <code>Node</code>’s requirements. The caller is then able to minimize allocation and reference-counting activity given its own needs:</p>

<ul>
	<li>
	<p>If it can pass ownership of the <code>Rc</code>, it simply hands over the pointer.</p>
	</li>
	<li>
	<p>If it needs to retain ownership of an <code>Rc</code>, it just bumps the reference count.</p>
	</li>
	<li>
	<p>Only if it owns the <code>Node</code> itself must it call <code>Rc::new</code> to allocate heap space and move the <code>Node</code> into it. Since <code>parent</code> will insist on referring to its children via <code>Rc&lt;Node&gt;</code> pointers, this was going to be necessary eventually.</p>
	</li>
</ul>

<p>Again, for most methods, <code>&amp;self</code>, <code>&amp;mut self</code> and <code>self</code> (by value) are all you need. But if a method’s purpose is to affect the ownership of the value, using other pointer types for <code>self</code> can be just the right thing.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Static Methods"><div class="sect2" id="static-methods">
<h2>Static Methods</h2>

<p class="pagebreak-before"><a contenteditable="false" data-primary="static methods" data-type="indexterm" id="idm45625494274872"/> You can also define methods that don’t take <code>self</code> as an argument at all. These become functions associated with the struct type itself, not with any specific value of the type. Following the tradition established by C++ and Java, Rust calls these <em>static methods</em>. They’re often used to provide constructor functions, like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">older</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">(),</code><code class="w"> </code><code class="n">younger</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>To use this method, we refer to it as <code>Queue::new</code>: the type name, a double colon, and then the method name. Now our example code becomes a bit more svelte:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">q</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Queue</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'*'</code><code class="p">);</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre>

<p>It’s conventional in Rust for constructor functions to be named <code>new</code>; we’ve already seen <code>Vec::new</code>, <code>Box::new</code>, <code>HashMap::new</code>, and others. But there’s nothing special about the name <code>new</code>. It’s not a keyword, and types often have other static methods that serve as constructors, like <code>Vec::with_capacity</code>.</p>

<p>Although you can have many separate <code>impl</code> blocks for a single type, they must all be in the same crate that defines that type. However, Rust does let you attach your own methods to other types; we’ll explain how in <a data-type="xref" href="ch10.xhtml#traits-and-generics">Chapter 10</a>.</p>

<p><a contenteditable="false" data-primary="types" data-secondary="separating methods from definition" data-type="indexterm" id="idm45625494128856"/> If you’re used to C++ or Java, separating a type’s methods from its definition may seem unusual, but there are several advantages to doing so:</p>

<ul>
	<li>
	<p>It’s always easy to find a type’s data members. In large C++ class definitions, you might need to skim hundreds of lines of member function definitions to be sure you haven’t missed any of the class’s data members; in Rust, they’re all in one place.</p>
	</li>
	<li>
	<p>Although one can imagine fitting methods into the syntax for named-field structs, it’s not so neat for tuple-like and unit-like structs. Pulling methods out into an <code>impl</code> block allows a single syntax for all three. In fact, Rust uses this same syntax for defining methods on types that are not structs at all, such as <code>enum</code> types and primitive types like <code>i32</code>. (The fact that any type can have methods is one reason Rust doesn’t use the term <em>object</em> much, preferring to call everything a <em>value</em>.)</p>
	</li>
	<li>
	<p>The same <code>impl</code> syntax also serves neatly for implementing traits, which we’ll go into in <a data-type="xref" href="ch10.xhtml#traits-and-generics">Chapter 10</a>. <a contenteditable="false" data-primary="" data-startref="C09-structs.html5" data-type="indexterm" id="idm45625494183736"/> <a contenteditable="false" data-primary="" data-startref="C09-structs.html4" data-type="indexterm" id="idm45625494182200"/> <a contenteditable="false" data-primary="" data-startref="C09-structs.html3" data-type="indexterm" id="idm45625494180664"/></p>
	</li>
</ul>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Static Values"><div class="sect1" id="static-values">
<h1>Static Values</h1>

<p>Another feature of languages like C# and Java that Rust adopts in its type system is the idea of values associated with a type, rather than a specific instance of that type. In Rust, these are known as <em>associated consts</em>.</p>

<p>As the name implies, associated consts are constant values. They’re often used to specify commonly used values of a type. For instance, you could define a 2-dimensional vector for use in linear algebra with an associated unit vector:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Vector2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">x</code>: <code class="kt">f32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">y</code>: <code class="kt">f32</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">Vector2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="n">ZERO</code>: <code class="nc">Vector2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Vector2</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mf">0.0</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="n">UNIT</code>: <code class="nc">Vector2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Vector2</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mf">0.0</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>These values are associated with the type itself, and you can use them without referring to another instance of <code>Vector2</code>. Much like static methods, they are accessed by naming the type with which they’re associated, followed by their name:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">scaled</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Vector2</code>::<code class="n">UNIT</code><code class="p">.</code><code class="n">scaled_by</code><code class="p">(</code><code class="mf">2.0</code><code class="p">);</code><code class="w"/></pre>

<p>Nor does an associated const have to be of the same type as the type it’s associated with; we could use this feature to add IDs or names to types. For example, if there were several types similar to <code>Vector2</code> that needed to be written to a file and then loaded into memory later, an associated const could be used to add names or numeric ID which could be written next to the data to identify its type.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">Vector2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="n">NAME</code>: <code class="kp">&amp;</code><code class="nb">'static</code><code class="w"> </code><code class="kt">str</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Vector2"</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="n">ID</code>: <code class="kt">u32</code> <code class="o">=</code><code class="w"> </code><code class="mi">18</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Generic Structs"><div class="sect1" id="generic-structs">
<h1>Generic Structs</h1>

<p><a contenteditable="false" data-primary="generic structs" data-type="indexterm" id="idm45625494009096"/> <a contenteditable="false" data-primary="structs" data-secondary="generic" data-type="indexterm" id="idm45625494007640"/> Our earlier definition of <code>Queue</code> is unsatisfying: it is written to store characters, but there’s nothing about its structure or methods that is specific to characters at all. If we were to define another struct that held, say, <code>String</code> values, the code could be identical, except that <code>char</code> would be replaced with <code>String</code>. That would be a waste of time.</p>

<p>Fortunately, Rust structs can be <em>generic</em>, meaning that their definition is a template into which you can plug whatever types you like. For example, here’s a definition for <code>Queue</code> that can hold values of any type:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Queue</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">older</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">younger</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can read the <code>&lt;T&gt;</code> in <code>Queue&lt;T&gt;</code> as “for any element type <code>T</code>...”. So this definition reads, “For any type <code>T</code>, a <code>Queue&lt;T&gt;</code> is two fields of type <code>Vec&lt;T&gt;</code>.” For example, in <code>Queue&lt;String&gt;</code>, <code>T</code> is <code>String</code>, so <code>older</code> and <code>younger</code> have type <code>Vec&lt;String&gt;</code>. In <code>Queue&lt;char&gt;</code>, <code>T</code> is <code>char</code>, and we get a struct identical to the <code>char</code>-specific definition we started with. In fact, <code>Vec</code> itself is a generic struct, defined in just this way.</p>

<p><a contenteditable="false" data-primary="type parameters" data-type="indexterm" id="idm45625493871176"/> In generic struct definitions, the type names used in <code>&lt;</code>angle brackets<code>&gt;</code> are called <em>type parameters</em>. An <code>impl</code> block for a generic struct looks like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Queue</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Queue</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">older</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">(),</code><code class="w"> </code><code class="n">younger</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">push</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">t</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">younger</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">t</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">is_empty</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">older</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">younger</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can read the line <code>impl&lt;T&gt; Queue&lt;T&gt;</code> as something like, “for any type <code>T</code>, here are some methods available on <code>Queue&lt;T&gt;</code>.” Then, you can use the type parameter <code>T</code> as a type in the method definitions.</p>

<p>We’ve used Rust’s shorthand for <code>self</code> parameters in the preceding code; writing out <code>Queue&lt;T&gt;</code> everywhere becomes a mouthful and a distraction. As another shorthand, every <code>impl</code> block, generic or not, defines the special type parameter <code>Self</code> (note the <code>CamelCase</code> name) to be whatever type we’re adding methods to. In the preceding code, <code>Self</code> would be <code>Queue&lt;T&gt;</code>, so we can abbreviate <code>Queue::new</code>’s definition a bit further:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Queue</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">older</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">(),</code><code class="w"> </code><code class="n">younger</code>: <code class="nb">Vec</code>::<code class="n">new</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You might have noticed that, in the body of <code>new</code>, we didn’t need to write the type parameter in the construction expression; simply writing <code>Queue { ... }</code> was good enough. This is Rust’s type inference at work: since there’s only one type that works for that function’s return value—namely, <code>Queue&lt;T&gt;</code>—Rust supplies the parameter for us. However, you’ll always need to supply type parameters in function signatures and type definitions. Rust doesn’t infer those; instead, it uses those explicit types as the basis from which it infers types within function bodies.</p>

<p>For static method calls, you can supply the type parameter explicitly using the turbofish <code>::&lt;&gt;</code> notation:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">q</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Queue</code>::<code class="o">&lt;</code><code class="n">char</code><code class="o">&gt;</code>::<code class="n">new</code><code class="p">();</code><code class="w"/></pre>

<p>But in practice, you can usually just let Rust figure it out for you:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">q</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Queue</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Queue</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>

<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="s">"CAD"</code><code class="p">);</code><code class="w">  </code><code class="c1">// apparently a Queue&lt;&amp;'static str&gt;</code>
<code class="n">r</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mf">0.74</code><code class="p">);</code><code class="w">   </code><code class="c1">// apparently a Queue&lt;f64&gt;</code>

<code class="n">q</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="s">"BTC"</code><code class="p">);</code><code class="w">   </code><code class="c1">// Bitcoins per USD, 2019-6</code>
<code class="n">r</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mf">13764.0</code><code class="p">);</code><code class="w"> </code><code class="c1">// Rust fails to detect irrational exuberance</code></pre>

<p>In fact, this is exactly what we’ve been doing with <code>Vec</code>, another generic struct type, throughout the book.</p>

<p>It’s not just structs that can be generic. Enums can take type parameters as well, with a very similar syntax. We’ll show that in detail in <a data-type="xref" href="ch09.xhtml#enums">“Enums”</a>.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Structs with Lifetime Parameters"><div class="sect1" id="structs-with-lifetime-parameters">
<h1>Structs with Lifetime Parameters</h1>

<p><a contenteditable="false" data-primary="lifetime" data-secondary="structs with" data-type="indexterm" id="idm45625493516920"/> <a contenteditable="false" data-primary="structs" data-secondary="with lifetime parameters" data-type="indexterm" id="idm45625493515416"/> As we discussed in <a data-type="xref" href="ch04.xhtml#structs-containing-references">“Structs Containing References”</a>, if a struct type contains references, you must name those references’ lifetimes. For example, here’s a structure that might hold references to the greatest and least elements of some slice:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Extrema</code><code class="o">&lt;</code><code class="na">'elt</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">greatest</code>: <code class="kp">&amp;</code><code class="na">'elt</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">least</code>: <code class="kp">&amp;</code><code class="na">'elt</code><code class="w"> </code><code class="kt">i32</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Earlier, we invited you to think of a declaration like <code>struct Queue&lt;T&gt;</code> as meaning that, given any specific type <code>T</code>, you can make a <code>Queue&lt;T&gt;</code> that holds that type. Similarly, you can think of <code>struct Extrema&lt;'elt&gt;</code> as meaning that, given any specific lifetime <code>'elt</code>, you can make an <code>Extrema&lt;'elt&gt;</code> that holds references with that lifetime.</p>

<p>Here’s a function to scan a slice and return an <code>Extrema</code> value whose fields refer to its elements:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">find_extrema</code><code class="o">&lt;</code><code class="na">'s</code><code class="o">&gt;</code><code class="p">(</code><code class="n">slice</code>: <code class="kp">&amp;</code><code class="na">'s</code><code class="w"> </code><code class="p">[</code><code class="kt">i32</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nc">Extrema</code><code class="o">&lt;</code><code class="na">'s</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">greatest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">slice</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">least</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">slice</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>

<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">1</code><code class="p">..</code><code class="n">slice</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">slice</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="o">*</code><code class="n">least</code><code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="n">least</code><code class="w">    </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">slice</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">slice</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="o">*</code><code class="n">greatest</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">greatest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">slice</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">Extrema</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">greatest</code><code class="p">,</code><code class="w"> </code><code class="n">least</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Here, since <code>find_extrema</code> borrows elements of <code>slice</code>, which has lifetime <code>'s</code>, the <code>Extrema</code> struct we return also uses <code>'s</code> as the lifetime of its references. Rust always infers lifetime parameters for calls, so calls to <code>find_extrema</code> needn’t mention them:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">15</code><code class="p">,</code><code class="w"> </code><code class="mi">48</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">e</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">find_extrema</code><code class="p">(</code><code class="o">&amp;</code><code class="n">a</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">e</code><code class="p">.</code><code class="n">least</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="o">*</code><code class="n">e</code><code class="p">.</code><code class="n">greatest</code><code class="p">,</code><code class="w"> </code><code class="mi">48</code><code class="p">);</code><code class="w"/></pre>

<p>Because it’s so common for the return type to use the same lifetime as an argument, Rust lets us omit the lifetimes when there’s one obvious candidate. We could also have written <code>find_extrema</code>’s signature like this, with no change in meaning:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">find_extrema</code><code class="p">(</code><code class="n">slice</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">i32</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nc">Extrema</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Granted, we <em>might</em> have meant <code>Extrema&lt;'static&gt;</code>, but that’s pretty unusual. Rust provides a shorthand for the common case.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Deriving Common Traits for Struct Types"><div class="sect1" id="deriving-common-traits-for-struct-types">
<h1>Deriving Common Traits for Struct Types</h1>

<p><a contenteditable="false" data-primary="structs" data-secondary="deriving common traits for struct types" data-type="indexterm" id="idm45625493212680"/> <a contenteditable="false" data-primary="traits" data-secondary="for struct types" data-type="indexterm" id="idm45625493211208"/> Structs can be very easy to write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">struct</code> <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">x</code>: <code class="kt">f64</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">y</code>: <code class="kt">f64</code>
<code class="p">}</code><code class="w"/></pre>

<p>However, if you were to start using this <code>Point</code> type, you would quickly notice that it’s a bit of a pain. As written, <code>Point</code> is not copyable or cloneable. You can’t print it with <code>println!("{:?}", point);</code> and it does not support the <code>==</code> and <code>!=</code> operators.</p>

<p>Each of these features has a name in Rust—<code>Copy</code>, <code>Clone</code>, <code>Debug</code>, and <code>PartialEq</code>. They are called <em>traits</em>. In <a data-type="xref" href="ch10.xhtml#traits-and-generics">Chapter 10</a>, we’ll show how to implement traits by hand for your own structs. But in the case of these standard traits, and several others, you don’t need to implement them by hand unless you want some kind of custom behavior. Rust can automatically implement them for you, with mechanical accuracy. Just add a <code>#[derive]</code> attribute to the struct:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="cp">#[derive(Copy, Clone, Debug, PartialEq)]</code><code class="w"/>
<code class="k">struct</code> <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">x</code>: <code class="kt">f64</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">y</code>: <code class="kt">f64</code>
<code class="p">}</code><code class="w"/></pre>

<p>Each of these traits can be implemented automatically for a struct, provided that each of its fields implements the trait. We can ask Rust to derive <code>PartialEq</code> for <code>Point</code> because its two fields are both of type <code>f64</code>, which already implements <code>PartialEq</code>.</p>

<p>Rust can also derive <code>PartialOrd</code>, which would add support for the comparison operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. We haven’t done so here, because comparing two points to see if one is “less than” the other is actually a pretty weird thing to do. There’s no one conventional order on points. So we choose not to support those operators for <code>Point</code> values. Cases like this are one reason that Rust makes us write the <code>#[derive]</code> attribute rather than automatically deriving every trait it can. Another reason is that implementing a trait is automatically a public feature, so copyability, cloneability, and so forth are all part of your struct’s public API and should be chosen deliberately.</p>

<p>We’ll describe Rust’s standard traits in detail, and tell which ones are <code>#[derive]</code>able, in XREF HERE.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Interior Mutability"><div class="sect1" id="interior-mutability">
<h1>Interior Mutability</h1>

<p><a contenteditable="false" data-primary="interior mutability" data-secondary="structs" data-type="indexterm" id="C09-structs.html6"/> <a contenteditable="false" data-primary="mutability, interior" data-type="indexterm" id="C09-structs.html7"/> <a contenteditable="false" data-primary="structs" data-secondary="interior mutability" data-type="indexterm" id="C09-structs.html8"/> Mutability is like anything else: in excess, it causes problems, but you often want just a little bit of it. For example, say your spider robot control system has a central struct, <code>SpiderRobot</code>, that contains settings and I/O handles. It’s set up when the robot boots, and the values never change:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">SpiderRobot</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">species</code>: <code class="nb">String</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">web_enabled</code>: <code class="kt">bool</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">leg_devices</code>: <code class="p">[</code><code class="n">fd</code>::<code class="n">FileDesc</code><code class="p">;</code><code class="w"> </code><code class="mi">8</code><code class="p">],</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p class="pagebreak-before">Every major system of the robot is handled by a different struct, and each one has a pointer back to the <code>SpiderRobot</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">rc</code>::<code class="n">Rc</code><code class="p">;</code><code class="w"/>

<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">SpiderSenses</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">robot</code>: <code class="nc">Rc</code><code class="o">&lt;</code><code class="n">SpiderRobot</code><code class="o">&gt;</code><code class="p">,</code><code class="w">  </code><code class="c1">// &lt;-- pointer to settings and I/O</code>
<code class="w">    </code><code class="n">eyes</code>: <code class="p">[</code><code class="n">Camera</code><code class="p">;</code><code class="w"> </code><code class="mi">32</code><code class="p">],</code><code class="w"/>
<code class="w">    </code><code class="n">motion</code>: <code class="nc">Accelerometer</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The structs for web construction, predation, venom flow control, and so forth also each have an <code>Rc&lt;SpiderRobot&gt;</code> smart pointer. Recall that <code>Rc</code> stands for <a href="ch03.xhtml#rc">reference counting</a>, and a value in an <code>Rc</code> box is always shared and therefore always immutable.</p>

<p>Now suppose you want to add a little logging to the <code>SpiderRobot</code> struct, using the standard <code>File</code> type. There’s a problem: a <code>File</code> has to be <code>mut</code>. All the methods for writing to it require a <code>mut</code> reference.</p>

<p>This sort of situation comes up fairly often. What we need is a little bit of mutable data (a <code>File</code>) inside an otherwise immutable value (the <code>SpiderRobot</code> struct). This is called <em>interior mutability</em>. Rust offers several flavors of it; in this section, we’ll discuss the two most straightforward types: <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>, both in the <code>std::cell</code> module.</p>

<p><a contenteditable="false" data-primary="Cell&lt;T&gt; struct" data-type="indexterm" id="idm45625492917000"/> <a contenteditable="false" data-primary="Cells" data-type="indexterm" id="idm45625492915544"/> A <code>Cell&lt;T&gt;</code> is a struct that contains a single private value of type <code>T</code>. The only special thing about a <code>Cell</code> is that you can get and set the field even if you don’t have <code>mut</code> access to the <code>Cell</code> itself:</p>

<ul>
	<li>
	<p><strong><code>Cell::new(value)</code></strong> creates a new <code>Cell</code>, moving the given <code>value</code> into it.</p>
	</li>
	<li>
	<p><strong><code>cell.get()</code></strong> returns a copy of the value in the <code>cell</code>.</p>
	</li>
	<li>
	<p><strong><code>cell.set(value)</code></strong> stores the given <code>value</code> in the <code>cell</code>, dropping the previously stored value.</p>

	<p>This method takes <code>self</code> as a non-<code>mut</code> reference:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">set</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">value</code>: <code class="nc">T</code><code class="p">)</code><code class="w">    </code><code class="c1">// note: not `&amp;mut self`</code></pre>

	<p>This is, of course, unusual for methods named <code>set</code>. By now, Rust has trained us to expect that we need <code>mut</code> access if we want to make changes to data. But by the same token, this one unusual detail is the whole point of <code>Cell</code>s. They’re simply a safe way of bending the rules on immutability—no more, no less.</p>
	</li>
</ul>

<p>Cells also have a few other methods, which you can read about <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html">in the documentation</a>.</p>

<p>A <code>Cell</code> would be handy if you were adding a simple counter to your <code>SpiderRobot</code>. You could write:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cell</code>::<code class="n">Cell</code><code class="p">;</code><code class="w"/>

<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">SpiderRobot</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="n">hardware_error_count</code>: <code class="nc">Cell</code><code class="o">&lt;</code><code class="kt">u32</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>and then even non-<code>mut</code> methods of <code>SpiderRobot</code> can access that <code>u32</code>, using the <code>.get()</code> and <code>.set()</code> methods:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">impl</code><code class="w"> </code><code class="n">SpiderRobot</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Increase the error count by 1.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">add_hardware_error</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">hardware_error_count</code><code class="p">.</code><code class="n">get</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">hardware_error_count</code><code class="p">.</code><code class="n">set</code><code class="p">(</code><code class="n">n</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="sd">/// True if any hardware errors have been reported.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">has_hardware_errors</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">hardware_error_count</code><code class="p">.</code><code class="n">get</code><code class="p">()</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is easy enough, but it doesn’t solve our logging problem. <code>Cell</code> does <em>not</em> let you call <code>mut</code> methods on a shared value. The <code>.get()</code> method returns a copy of the value in the cell, so it works only if <code>T</code> implements <a href="ch03.xhtml#copy-types-the-exception-to-moves">the <code>Copy</code> trait</a>. For logging, we need a mutable <code>File</code>, and <code>File</code> isn’t copyable.</p>

<p><a contenteditable="false" data-primary="RefCell&lt;T&gt; struct" data-type="indexterm" id="idm45625492679704"/> The right tool in this case is a <code>RefCell</code>. Like <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is a generic type that contains a single value of type <code>T</code>. Unlike <code>Cell</code>, <code>RefCell</code> supports borrowing references to its <code>T</code> value:</p>

<ul>
	<li>
	<p><strong><code>RefCell::new(value)</code></strong> creates a new <code>RefCell</code>, moving <code>value</code> into it.</p>
	</li>
	<li>
	<p><strong><code>ref_cell.borrow()</code></strong> returns a <code>Ref&lt;T&gt;</code>, which is essentially just a shared reference to the value stored in <code>ref_cell</code>.</p>

	<p>This method panics if the value is already mutably borrowed; see details to follow.</p>
	</li>
	<li>
	<p><strong><code>ref_cell.borrow_mut()</code></strong> returns a <code>RefMut&lt;T&gt;</code>, essentially a mutable reference to the value in <code>ref_cell</code>.</p>

	<p>This method panics if the value is already borrowed; see details to follow.</p>
	</li>
</ul>

<p>Again, <code>RefCell</code> has a few other methods, which you can find <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">in the documentation</a>.</p>

<p>The two <code>borrow</code> methods panic only if you try to break the Rust rule that <code>mut</code> references are exclusive references. For example, this would panic:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">ref_cell</code>: <code class="nc">RefCell</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="s">"hello"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ref_cell</code><code class="p">.</code><code class="n">borrow</code><code class="p">();</code><code class="w">      </code><code class="c1">// ok, returns a Ref&lt;String&gt;</code>
<code class="kd">let</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">len</code><code class="p">();</code><code class="w">            </code><code class="c1">// ok, returns "hello".len()</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">count</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">);</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">w</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ref_cell</code><code class="p">.</code><code class="n">borrow_mut</code><code class="p">();</code><code class="w">  </code><code class="c1">// panic: already borrowed</code>
<code class="n">w</code><code class="p">.</code><code class="n">push_str</code><code class="p">(</code><code class="s">" world"</code><code class="p">);</code><code class="w"/></pre>

<p>To avoid panicking, you could put these two borrows into separate blocks. That way, <code>r</code> would be dropped before you try to borrow <code>w</code>.</p>

<p>This is a lot like how normal references work. The only difference is that normally, when you borrow a reference to a variable, Rust checks <em>at compile time</em> to ensure that you’re using the reference safely. If the checks fail, you get a compiler error. <code>RefCell</code> enforces the same rule using run-time checks. So if you’re breaking the rules, you get a panic.</p>

<p>Now we’re ready to put <code>RefCell</code> to work in our <code>SpiderRobot</code> type:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">SpiderRobot</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="n">log_file</code>: <code class="nc">RefCell</code><code class="o">&lt;</code><code class="n">File</code><code class="o">&gt;</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">impl</code><code class="w"> </code><code class="n">SpiderRobot</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="sd">/// Write a line to the log file.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">log</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">message</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">log_file</code><code class="p">.</code><code class="n">borrow_mut</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="c1">// `writeln!` is like `println!`, but sends</code>
<code class="w">        </code><code class="c1">// output to the given file.</code>
<code class="w">        </code><code class="n">writeln</code><code class="o">!</code><code class="p">(</code><code class="n">file</code><code class="p">,</code><code class="w"> </code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">message</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The variable <code>file</code> has type <code>RefMut&lt;File&gt;</code>. It can be used just like a mutable reference to a <code>File</code>. For details about writing to files, see XREF HERE.</p>

<p>Cells are easy to use. Having to call <code>.get()</code> and <code>.set()</code> or <code>.borrow()</code> and <span class="keep-together"><code>.borrow_mut()</code></span> is slightly awkward, but that’s just the price we pay for bending the rules. The other drawback is less obvious and more serious: cells—and any types that contain them—are not thread-safe. Rust therefore will not allow multiple threads to access them at once. We’ll describe thread-safe flavors of interior mutability in XREF HERE, when we discuss mutex in Rust, atomics, and global variables. <a contenteditable="false" data-primary="" data-startref="C09-structs.html8" data-type="indexterm" id="idm45625492441672"/></p>

<p>Whether a struct has named fields or is tuple-like, it is an aggregation of other values: if I have a <code>SpiderSenses</code> struct, then I have an <code>Rc</code> pointer to a shared <code>SpiderRobot</code> struct, and I have eyes, and I have an accelerometer, and so on. So the essence of a struct is the word “and”: I have an X <em>and</em> a Y. But what if there were another kind of type built around the word “or”? That is, when you have a value of such a type, you’d have <em>either</em> an X <em>or</em> a Y? Such types turn out to be so useful that they’re ubiquitous in Rust, and they are the subject of the next chapter. <a contenteditable="false" data-primary="" data-startref="C09-structs.html7" data-type="indexterm" id="idm45625492436568"/> <a contenteditable="false" data-primary="" data-startref="C09-structs.html6" data-type="indexterm" id="idm45625492435064"/> <a contenteditable="false" data-primary="" data-startref="C09-structs.html0" data-type="indexterm" id="idm45625492433528"/></p>
</div></section>
</div></section></div></body>
</html>