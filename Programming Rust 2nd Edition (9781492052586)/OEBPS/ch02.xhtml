<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Basic Types"><div class="chapter" id="basic-types">
<h1><span class="label">Chapter 2. </span>Basic Types</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625525462808"><h5>A note for Early Release readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 3rd chapter of the final book.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <em>jimb@red-bean.com</em>.</p>
</div></aside>

<blockquote data-type="epigraph" epub:type="epigraph">
<p><a contenteditable="false" data-primary="types" data-type="indexterm" id="C03-types.html0"/> There are many, many types of books in the world, which makes good sense, because there are many, many types of people, and everybody wants to read something different.</p>

<p data-type="attribution">Lemony Snicket</p>
</blockquote>

<p>To a great extent, the Rust language is designed around its types. Its memory and thread safety guarantees rest on the soundness of its type system. Its flexibility stems from its generic types and traits. And its performance arises from letting developers choose representations for their data with the right balance between flexibility and cost.</p>

<p>This chapter is about that third aspect: Rust’s fundamental types for representing values. These source-level types have concrete machine-level counterparts with predictable costs and performance. Although Rust doesn’t promise it will represent things exactly as you’ve requested, it takes care to deviate from your requests only when it’s a reliable improvement.</p>

<p>Compared to a dynamically typed language like JavaScript or Python, Rust requires more planning from you up front: you must spell out the types of functions’ parameters and return values, members of struct types, and a few other constructs. However, two features of Rust make this less trouble than you might expect:</p>

<ul>
	<li>
	<p><a contenteditable="false" data-primary="type inference" data-type="indexterm" id="idm45625525452888"/> Given the types that you did spell out, Rust will <em>infer</em> most of the rest for you. In practice, there’s often only one type that will work for a given variable or expression; when this is the case, Rust lets you leave out the type. For example, you could spell out every type in a function, like this:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">build_vector</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i16</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i16</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="o">&lt;</code><code class="kt">i16</code><code class="o">&gt;</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">10</code><code class="k">i16</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">20</code><code class="k">i16</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">v</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

	<p>But this is cluttered and repetitive. Given the function’s return type, it’s obvious that <code>v</code> must be a <code>Vec&lt;i16&gt;</code>, a vector of 16-bit signed integers; no other type would work. And from that it follows that each element of the vector must be an <code>i16</code>. This is exactly the sort of reasoning Rust’s type inference applies, allowing you to instead write:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">build_vector</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i16</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">20</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">v</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

	<p>These two definitions are exactly equivalent; Rust will generate the same machine code either way. Type inference gives back much of the legibility of dynamically typed languages, while still catching type errors at compile time.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="generic functions" data-type="indexterm" id="idm45625525340328"/></p>

	<p>Functions can be <em>generic</em>: a single function can work on values of many different types.</p>

	<p>In Python and JavaScript, all functions work this way naturally: a function can operate on any value that has the properties and methods the function will need. (This is the characteristic often called <em>duck typing</em>: if it quacks like a duck, it’s a duck.) But it’s exactly this flexibility that makes it so difficult for those languages to detect type errors early; testing is often the only way to catch such mistakes. Rust’s generic functions give the language a degree of the same flexibility, while still catching all type errors at compile time.</p>

	<p>Despite their flexibility, generic functions are just as efficient as their nongeneric counterparts. We’ll discuss generic functions in detail in <a data-type="xref" href="ch10.xhtml#traits-and-generics">Chapter 10</a>.</p>
	</li>
</ul>

<p>The rest of this chapter covers Rust’s types from the bottom up, starting with simple machine types like integers and floating-point values, then moving on to types that hold more data: boxes, tuples, arrays, and strings.</p>

<p>Here’s a summary of the sorts of types you’ll see in Rust. This table shows Rust’s primitive types, some very common types from the standard library, and some examples of user-defined types:</p>

<table class="tallrow" id="types-in-rust">
	<thead>
		<tr>
			<th>Type</th>
			<th>Description</th>
			<th>Values</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code><br/>
			<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></td>
			<td>Signed and unsigned integers,<br/>
			of given bit width</td>
			<td><code>42</code>,<br/>
			<code>-5i8</code>, <code>0x400u16</code>, <code>0o100i16</code>,<br/>
			<code>20_922_789_888_000u64</code>,<br/>
			<code>b'*'</code> (<code>u8</code> byte literal)</td>
		</tr>
		<tr>
			<td><code>isize</code>, <code>usize</code></td>
			<td>Signed and unsigned integers,<br/>
			the same size as an address on the machine (32 or 64 bits)</td>
			<td><code>137</code>,<br/>
			<code>-0b0101_0010isize</code>,<br/>
			<code>0xffff_fc00usize</code></td>
		</tr>
		<tr>
			<td><code>f32</code>, <code>f64</code></td>
			<td>IEEE floating-point numbers,<br/>
			single and double precision</td>
			<td><code>1.61803</code>, <code>3.14f32</code>, <code>6.0221e23f64</code></td>
		</tr>
		<tr>
			<td><code>bool</code></td>
			<td>Boolean</td>
			<td><code>true</code>, <code>false</code></td>
		</tr>
		<tr>
			<td><code>char</code></td>
			<td>Unicode character, 32 bits wide</td>
			<td><code>'*'</code>, <code>'\n'</code>, <code>'字'</code>, <code>'\x7f'</code>, <code>'\u{CA0}'</code></td>
		</tr>
		<tr>
			<td><code>(char, u8, i32)</code></td>
			<td>Tuple: mixed types allowed</td>
			<td><code>('%', 0x7f, -1)</code></td>
		</tr>
		<tr>
			<td><code>()</code></td>
			<td>“unit” (empty tuple)</td>
			<td><code>()</code></td>
		</tr>
		<tr>
			<td><code>struct S { x: f32, y: f32 }</code></td>
			<td>Named-field struct</td>
			<td><code>S { x: 120.0, y: 209.0 }</code></td>
		</tr>
		<tr>
			<td><code>struct T(i32, char);</code></td>
			<td>Tuple-like struct</td>
			<td><code>T(120, 'X')</code></td>
		</tr>
		<tr>
			<td><code>struct E;</code></td>
			<td>Unit-like struct; has no fields</td>
			<td><code>E</code></td>
		</tr>
		<tr>
			<td><code>enum Attend { OnTime, Late(u32) }</code></td>
			<td>Enumeration, algebraic data type</td>
			<td><code>Attend::Late(5)</code>, <code>Attend::OnTime</code></td>
		</tr>
		<tr>
			<td><code>Box&lt;Attend&gt;</code></td>
			<td>Box: owning pointer to value in heap</td>
			<td><code>Box::new(Late(15))</code></td>
		</tr>
		<tr>
			<td><code>&amp;i32</code>, <code>&amp;mut i32</code></td>
			<td>Shared and mutable references: nonowning pointers that must not outlive their referent</td>
			<td><code>&amp;s.y</code>, <code>&amp;mut v</code></td>
		</tr>
		<tr>
			<td><code>String</code></td>
			<td>UTF-8 string, dynamically sized</td>
			<td><code>"ラーメン: ramen".to_string()</code></td>
		</tr>
		<tr>
			<td><code>&amp;str</code></td>
			<td>Reference to <code>str</code>: nonowning pointer to UTF-8 text</td>
			<td><code>"そば: soba"</code>, <code>&amp;s[0..12]</code></td>
		</tr>
		<tr>
			<td><code>[f64; 4]</code>, <code>[u8; 256]</code></td>
			<td>Array, fixed length; elements all of same type</td>
			<td><code>[1.0, 0.0, 0.0, 1.0]</code>,<br/>
			<code>[b' '; 256]</code></td>
		</tr>
		<tr>
			<td><code>Vec&lt;f64&gt;</code></td>
			<td>Vector, varying length; elements all of same type</td>
			<td><code>vec![0.367, 2.718, 7.389]</code></td>
		</tr>
		<tr>
			<td><code>&amp;[u8]</code>, <code>&amp;mut [u8]</code></td>
			<td>Reference to slice: reference to a portion of an array or vector, comprising pointer and length</td>
			<td><code>&amp;v[10..20]</code>, <code>&amp;mut a[..]</code></td>
		</tr>
		<tr>
			<td><code>Option&lt;&amp;str&gt;</code></td>
			<td>Optional value: either <code>None</code> (absent) or <code>Some(v)</code> (present, with value <code>v</code>)</td>
			<td><code>Some("Dr.")</code>, <code>None</code></td>
		</tr>
		<tr>
			<td><code>Result&lt;u64, Error&gt;</code></td>
			<td>Result of operation that may fail: either a success value <code>Ok(v)</code>, or an error <code>Err(e)</code></td>
			<td><code>Ok(4096)</code>, <code>Err(Error::last_os_error())</code></td>
		</tr>
		<tr>
			<td><code>&amp;dyn Any</code>, <code>&amp;mut dyn Read</code></td>
			<td>Trait object: reference to any value that implements a given set of methods</td>
			<td><code>value as &amp;dyn Any</code>,<br/>
			<code>&amp;mut file as &amp;mut dyn Read</code></td>
		</tr>
		<tr>
			<td><code>fn(&amp;str) -&gt; bool</code></td>
			<td>Pointer to function</td>
			<td><code>str::is_empty</code></td>
		</tr>
		<tr>
			<td>(Closure types have no written form)</td>
			<td>Closure</td>
			<td><code>|a, b| { a*a + b*b }</code></td>
		</tr>
	</tbody>
</table>

<p>Most of these types are covered in this chapter, except for the following:</p>

<ul>
	<li>
	<p>We give <code>struct</code> types their own chapter, <a data-type="xref" href="ch08.xhtml#structs">Chapter 8</a>.</p>
	</li>
	<li>
	<p>We give enumerated types their own chapter, <a data-type="xref" href="ch09.xhtml#enums-and-patterns">Chapter 9</a>.</p>
	</li>
	<li>
	<p>We describe trait objects in <a data-type="xref" href="ch10.xhtml#traits-and-generics">Chapter 10</a>.</p>
	</li>
	<li>
	<p>We describe the essentials of <code>String</code> and <code>&amp;str</code> here, but provide more detail in XREF HERE.</p>
	</li>
	<li>
	<p>We cover function and closure types in XREF HERE.</p>
	</li>
</ul>

<section data-type="sect1" data-pdf-bookmark="Machine Types"><div class="sect1" id="machine-types">
<h1>Machine Types</h1>

<p><a contenteditable="false" data-primary="machine types" data-type="indexterm" id="C03-types.html1"/> <a contenteditable="false" data-primary="numeric types" data-type="indexterm" id="C03-types.html2"/> <a contenteditable="false" data-primary="types" data-secondary="machine" data-type="indexterm" id="C03-types.html3"/> The footing of Rust’s type system is a collection of fixed-width numeric types, chosen to match the types that almost all modern processors implement directly in hardware, and the Boolean and character types.</p>

<p>The names of Rust’s numeric types follow a regular pattern, spelling out their width in bits, and the representation they use:</p>

<table>
	<thead>
		<tr class="header">
			<th>Size (bits)</th>
			<th>Unsigned integer</th>
			<th>Signed integer</th>
			<th>Floating-point</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td>8</td>
			<td><code>u8</code></td>
			<td><code>i8</code></td>
			<td> </td>
		</tr>
		<tr class="even">
			<td>16</td>
			<td><code>u16</code></td>
			<td><code>i16</code></td>
			<td> </td>
		</tr>
		<tr class="odd">
			<td>32</td>
			<td><code>u32</code></td>
			<td><code>i32</code></td>
			<td><code>f32</code></td>
		</tr>
		<tr class="even">
			<td>64</td>
			<td><code>u64</code></td>
			<td><code>i64</code></td>
			<td><code>f64</code></td>
		</tr>
		<tr class="odd">
			<td>128</td>
			<td><code>u128</code></td>
			<td><code>i128</code></td>
			<td> </td>
		</tr>
		<tr class="even">
			<td>Machine word</td>
			<td><code>usize</code></td>
			<td><code>isize</code></td>
			<td> </td>
		</tr>
	</tbody>
</table>

<p>Here, a <em>machine word</em> is a value the size of an address on the machine the code runs on, 32 or 64 bits.</p>

<p>Fixed-width machine types can overflow or lose precision, but they are adequate for most applications, and can be thousands of times faster than representations like arbitrary-precision integers and exact rationals. If you need those sorts of numeric representations, they are supported in the <code>num</code> crate.</p>

<section data-type="sect2" data-pdf-bookmark="Integer Types"><div class="sect2" id="integer-types">
<h2>Integer Types</h2>

<p><a contenteditable="false" data-primary="integer types" data-type="indexterm" id="C03-types.html4"/> <a contenteditable="false" data-primary="machine types" data-secondary="integer types" data-type="indexterm" id="C03-types.html5"/> <a contenteditable="false" data-primary="numeric types" data-secondary="integer types" data-type="indexterm" id="C03-types.html6"/> Rust’s unsigned integer types use their full range to represent positive values and zero:</p>

<table>
	<thead>
		<tr class="header">
			<th>Type</th>
			<th>Range</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td><code>u8</code></td>
			<td>0 to 2<sup>8</sup>–1 (0 to 255)</td>
		</tr>
		<tr class="even">
			<td><code>u16</code></td>
			<td>0 to 2<sup>16</sup>−1 (0 to 65,535)</td>
		</tr>
		<tr class="odd">
			<td><code>u32</code></td>
			<td>0 to 2<sup>32</sup>−1 (0 to 4,294,967,295)</td>
		</tr>
		<tr class="even">
			<td><code>u64</code></td>
			<td>0 to 2<sup>64</sup>−1 (0 to 18,446,744,073,709,551,615, or 18 quintillion)</td>
		</tr>
		<tr class="odd">
			<td><code>u128</code></td>
			<td>0 to 2<sup>128</sup>−1 (0 to around 3.4✕10<sup>38</sup>)</td>
		</tr>
		<tr class="even">
			<td><code>usize</code></td>
			<td>0 to either 2<sup>32</sup>−1 or 2<sup>64</sup>−1</td>
		</tr>
	</tbody>
</table>

<p>Rust’s signed integer types use the two’s complement representation, using the same bit patterns as the corresponding unsigned type to cover a range of positive and negative values:</p>

<table>
	<thead>
		<tr class="header">
			<th>Type</th>
			<th>Range</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td><code>i8</code></td>
			<td>−2<sup>7</sup> to 2<sup>7</sup>−1 (−128 to 127)</td>
		</tr>
		<tr class="even">
			<td><code>i16</code></td>
			<td>−2<sup>15</sup> to 2<sup>15</sup>−1 (−32,768 to 32,767)</td>
		</tr>
		<tr class="odd">
			<td><code>i32</code></td>
			<td>−2<sup>31</sup> to 2<sup>31</sup>−1 (−2,147,483,648 to 2,147,483,647)</td>
		</tr>
		<tr class="even">
			<td><code>i64</code></td>
			<td>−2<sup>63</sup> to 2<sup>63</sup>−1 (−9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)</td>
		</tr>
		<tr class="odd">
			<td><code>i128</code></td>
			<td>−2<sup>127</sup> to 2<sup>127</sup>−1 (roughly -1.7✕10<sup>38</sup> to +1.7✕10<sup>38</sup>)</td>
		</tr>
		<tr class="even">
			<td><code>isize</code></td>
			<td>Either −2<sup>31</sup> to 2<sup>31</sup>−1, or −2<sup>63</sup> to 2<sup>63</sup>−1</td>
		</tr>
	</tbody>
</table>

<p>Rust uses the <code>u8</code> type for byte values. For example, reading data from a binary file or socket yields a stream of <code>u8</code> values.</p>

<p><a contenteditable="false" data-primary="characters (char)" data-secondary="numeric types vs." data-type="indexterm" id="idm45625525112008"/> Unlike C and C++, Rust treats characters as distinct from the numeric types; a <code>char</code> is neither a <code>u8</code> nor an <code>i8</code>. We describe Rust’s <code>char</code> type in <a data-type="xref" href="#characters">“Characters”</a>.</p>

<p><a contenteditable="false" data-primary="isize type" data-type="indexterm" id="idm45625525107368"/> <a contenteditable="false" data-primary="usize type" data-type="indexterm" id="idm45625525105912"/> The <code>usize</code> and <code>isize</code> types are analogous to <code>size_t</code> and <code>ptrdiff_t</code> in C and C++. Their precision matches the size of the address space on the target machine: they are 32 bits long on 32-bit architectures, and 64 bits long on 64-bit architectures. Rust requires array indices to be <code>usize</code> values. Values representing the sizes of arrays or vectors or counts of the number of elements in some data structure also generally have the <code>usize</code> type.</p>

<p>In debug builds, Rust checks for integer overflow in arithmetic:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">i</code><code class="w"> </code><code class="o">*=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="c1">// panic: arithmetic operation overflowed</code>
<code class="p">}</code><code class="w"/></pre>

<p>In a release build, this addition would wrap to a negative number (unlike C++, where signed integer overflow is undefined behavior). But unless you want to give up debug builds forever, it’s a bad idea to count on it. When you want wrapping arithmetic, use the methods:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">big_val</code><code class="p">.</code><code class="n">wrapping_add</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w">  </code><code class="c1">// ok</code></pre>

<p><a contenteditable="false" data-primary="integer literals" data-type="indexterm" id="idm45625525020760"/> Integer literals in Rust can take a suffix indicating their type: <code>42u8</code> is a <code>u8</code> value, and <code>1729isize</code> is an <code>isize</code>. If an integer literal lacks a type suffix, Rust puts off determining its type until it finds the value being used in a way that pins it down: stored in a variable of a particular type, passed to a function that expects a particular type, compared with another value of a particular type, or something like that. In the end, if multiple types could work, Rust defaults to <code>i32</code> if that is among the possibilities. Otherwise, Rust reports the ambiguity as an error.</p>

<p>The prefixes <code>0x</code>, <code>0o</code>, and <code>0b</code> designate hexadecimal, octal, and binary literals.</p>

<p>To make long numbers more legible, you can insert underscores among the digits. For example, you can write the largest <code>u32</code> value as <code>4_294_967_295</code>. The exact placement of the underscores is not significant, so you can break hexadecimal or binary numbers into groups of four digits rather than three, as in <code>0xffff_ffff</code>, or set off the type suffix from the digits, as in <code>127_u8</code>.</p>

<p>Some examples of integer literals:</p>

<table>
	<thead>
		<tr class="header">
			<th>Literal</th>
			<th>Type</th>
			<th>Decimal value</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td><code>116i8</code></td>
			<td><code>i8</code></td>
			<td>116</td>
		</tr>
		<tr class="even">
			<td><code>0xcafeu32</code></td>
			<td><code>u32</code></td>
			<td>51966</td>
		</tr>
		<tr class="odd">
			<td><code>0b0010_1010</code></td>
			<td>Inferred</td>
			<td>42</td>
		</tr>
		<tr class="even">
			<td><code>0o106</code></td>
			<td>Inferred</td>
			<td>70</td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="byte literals" data-type="indexterm" id="idm45625525063896"/> Although numeric types and the <code>char</code> type are distinct, Rust does provide <em>byte literals</em>, character-like literals for <code>u8</code> values: <code>b'X'</code> represents the ASCII code for the character <code>X</code>, as a <code>u8</code> value. For example, since the ASCII code for <code>A</code> is 65, the literals <code>b'A'</code> and <code>65u8</code> are exactly equivalent. Only ASCII characters may appear in byte literals.</p>

<p>There are a few characters that you cannot simply place after the single quote, because that would be either syntactically ambiguous or hard to read. The following characters can only be written using a stand-in notation, introduced by a backslash:</p>

<table>
	<thead>
		<tr class="header">
			<th>Character</th>
			<th>Byte literal</th>
			<th>Numeric equivalent</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td>Single quote, <code>'</code></td>
			<td><code>b'\''</code></td>
			<td><code>39u8</code></td>
		</tr>
		<tr class="even">
			<td>Backslash, <code>\</code></td>
			<td><code>b'\\'</code></td>
			<td><code>92u8</code></td>
		</tr>
		<tr class="odd">
			<td>Newline</td>
			<td><code>b'\n'</code></td>
			<td><code>10u8</code></td>
		</tr>
		<tr class="even">
			<td>Carriage return</td>
			<td><code>b'\r'</code></td>
			<td><code>13u8</code></td>
		</tr>
		<tr class="odd">
			<td>Tab</td>
			<td><code>b'\t'</code></td>
			<td><code>9u8</code></td>
		</tr>
	</tbody>
</table>

<p>For characters that are hard to write or read, you can write their code in hexadecimal instead. A byte literal of the form <code>b'\xHH'</code>, where <code>HH</code> is any two-digit hexadecimal number, represents the byte whose value is <code>HH</code>. For example, you can write a byte literal for the ASCII “escape” control character as <code>b'\x1b'</code>, since the ASCII code for “escape” is 27, or 1B in hexadecimal. Since byte literals are just another notation for <code>u8</code> values, consider whether a simple numeric literal might be more legible: it probably makes sense to use <code>b'\x1b'</code> instead of simply <code>27</code> only when you want to emphasize that the value represents an ASCII code.</p>

<p><a contenteditable="false" data-primary="as operator" data-type="indexterm" id="idm45625524968744"/> You can convert from one integer type to another using the <code>as</code> operator. We explain how conversions work in <a data-type="xref" href="ch05.xhtml#type-casts">“Type Casts”</a>, but here are some examples:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="w">   </code><code class="mi">10_</code><code class="k">i8</code><code class="w">  </code><code class="k">as</code><code class="w"> </code><code class="kt">u16</code><code class="p">,</code><code class="w">    </code><code class="mi">10_</code><code class="k">u16</code><code class="p">);</code><code class="w"> </code><code class="c1">// in range</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="w"> </code><code class="mi">2525_</code><code class="k">u16</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i16</code><code class="p">,</code><code class="w">  </code><code class="mi">2525_</code><code class="k">i16</code><code class="p">);</code><code class="w"> </code><code class="c1">// in range</code>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="w">   </code><code class="o">-</code><code class="mi">1_</code><code class="k">i16</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w">    </code><code class="o">-</code><code class="mi">1_</code><code class="k">i32</code><code class="p">);</code><code class="w"> </code><code class="c1">// sign-extended</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">65535_</code><code class="k">u16</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="mi">65535_</code><code class="k">i32</code><code class="p">);</code><code class="w"> </code><code class="c1">// zero-extended</code>

<code class="c1">// Conversions that are out of range for the destination</code>
<code class="c1">// produce values that are equivalent to the original modulo 2^N,</code>
<code class="c1">// where N is the width of the destination in bits. This</code>
<code class="c1">// is sometimes called "truncation".</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="w"> </code><code class="mi">1000_</code><code class="k">i16</code><code class="w"> </code><code class="k">as</code><code class="w">  </code><code class="kt">u8</code><code class="p">,</code><code class="w">   </code><code class="mi">232_</code><code class="k">u8</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">65535_</code><code class="k">u32</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i16</code><code class="p">,</code><code class="w">    </code><code class="o">-</code><code class="mi">1_</code><code class="k">i16</code><code class="p">);</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="w">   </code><code class="o">-</code><code class="mi">1_</code><code class="k">i8</code><code class="w">  </code><code class="k">as</code><code class="w"> </code><code class="kt">u8</code><code class="p">,</code><code class="w">    </code><code class="mi">255_</code><code class="k">u8</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="w">  </code><code class="mi">255_</code><code class="k">u8</code><code class="w">  </code><code class="k">as</code><code class="w"> </code><code class="kt">i8</code><code class="p">,</code><code class="w">     </code><code class="o">-</code><code class="mi">1_</code><code class="k">i8</code><code class="p">);</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="methods" data-secondary="on integers" data-type="indexterm" id="idm45625524963448"/> <a contenteditable="false" data-primary="integer methods" data-type="indexterm" id="idm45625519432840"/> Like any other sort of value, integers can have methods. The standard library provides some basic operations, which you can look up in the online documentation. Note that the documentation contains separate pages for the type itself (search for “<code>i32</code> (primitive type)”, say), and for the module dedicated to that type (search for “<code>std::i32</code>”). For example:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">2</code><code class="k">u16</code><code class="p">.</code><code class="n">pow</code><code class="p">(</code><code class="mi">4</code><code class="p">),</code><code class="w"> </code><code class="mi">16</code><code class="p">);</code><code class="w">            </code><code class="c1">// exponentiation</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">((</code><code class="o">-</code><code class="mi">4</code><code class="k">i32</code><code class="p">).</code><code class="n">abs</code><code class="p">(),</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w">           </code><code class="c1">// absolute value</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mb">0b101101</code><code class="k">u8</code><code class="p">.</code><code class="n">count_ones</code><code class="p">(),</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w"> </code><code class="c1">// population count</code></pre>

<p>In real code, you usually won’t need to write out the type suffixes like this, because the context will determine the type. When it doesn’t, however, the error messages can be surprising. For example, the following doesn’t compile:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="o">-</code><code class="mi">4</code><code class="p">).</code><code class="n">abs</code><code class="p">());</code><code class="w"/></pre>

<p>Rust complains:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="go">error: no method named `abs` found for type `{integer}` in the current scope</code></pre>

<p>This can be a little bewildering: all the signed integer types have an <code>abs</code> method, so what’s the problem? For technical reasons, Rust wants to know <em>which</em> integer type a value has before it will call the type’s own methods. The default of <code>i32</code> applies only if the type is still ambiguous after all method calls have been resolved, so that’s too late to help here. The solution is to spell out which type you intend, either with a suffix, or by using a specific type’s function:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="o">-</code><code class="mi">4</code><code class="k">i32</code><code class="p">).</code><code class="n">abs</code><code class="p">());</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="kt">i32</code>::<code class="n">abs</code><code class="p">(</code><code class="o">-</code><code class="mi">4</code><code class="p">));</code><code class="w"/></pre>

<p>Note that method calls have a higher precedence than unary prefix operators, so be careful when applying methods to negated values. Without the parentheses around <code>-4i32</code> in the second assertion, <code>-4i32.abs()</code> would apply the <code>abs</code> method to the positive value <code>4</code>, producing positive <code>4</code>, and then negate that, producing <code>-4</code>. <a contenteditable="false" data-primary="" data-startref="C03-types.html6" data-type="indexterm" id="idm45625519246920"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html5" data-type="indexterm" id="idm45625519245384"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html4" data-type="indexterm" id="idm45625519243848"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Checked, Wrapping, and Saturating Arithmetic"><div class="sect2" id="checked-wrapping-and-saturating-arithmetic">
<h2>Checked, Wrapping, and Saturating Arithmetic</h2>

<p>Sometimes Rust’s default rules for dealing with arithmetic overflow aren’t what you need. For such cases, the integer types provide methods that let you spell out exactly how you want overflows handled. These methods fall in three general categories:</p>

<ul>
	<li>
	<p><em>Checked</em> operations return an <code>Option</code> of the result: <code>Some(v)</code> if the mathematically correct result can be represented as a value of that type, or <code>None</code> if it cannot. For example:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// The sum of 10 and 20 can be represented as a u8.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">10_</code><code class="k">u8</code><code class="p">.</code><code class="n">checked_add</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">30</code><code class="p">));</code><code class="w"/>

<code class="c1">// Unfortunately, the sum of 100 and 200 cannot.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">100_</code><code class="k">u8</code><code class="p">.</code><code class="n">checked_add</code><code class="p">(</code><code class="mi">200</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/>

<code class="c1">// Do the addition; panic if it overflows.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="n">checked_add</code><code class="p">(</code><code class="n">y</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"/>

<code class="c1">// Oddly, signed division can overflow too, in one particular case.</code>
<code class="c1">// A signed n-bit type can represent -2ⁿ⁻¹, but not 2ⁿ⁻¹.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">((</code><code class="o">-</code><code class="mi">128_</code><code class="k">i8</code><code class="p">).</code><code class="n">checked_div</code><code class="p">(</code><code class="o">-</code><code class="mi">1</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>
	</li>
	<li>
	<p><em>Wrapping</em> operations return the value equivalent to the mathematically correct result modulo the range of the value, in both debug and release builds:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// The first product can be represented as a u16;</code>
<code class="c1">// the second cannot, so we get 250000 modulo 2¹⁶.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">100_</code><code class="k">u16</code><code class="p">.</code><code class="n">wrapping_mul</code><code class="p">(</code><code class="mi">200</code><code class="p">),</code><code class="w"> </code><code class="mi">20000</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">500_</code><code class="k">u16</code><code class="p">.</code><code class="n">wrapping_mul</code><code class="p">(</code><code class="mi">500</code><code class="p">),</code><code class="w"> </code><code class="mi">53392</code><code class="p">);</code><code class="w"/>

<code class="c1">// Operations on signed types may wrap to negative values.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">500_</code><code class="k">i16</code><code class="p">.</code><code class="n">wrapping_mul</code><code class="p">(</code><code class="mi">500</code><code class="p">),</code><code class="w"> </code><code class="o">-</code><code class="mi">12144</code><code class="p">);</code><code class="w"/>

<code class="c1">// In bitwise shift operations, the shift distance is wrapped to fall within</code>
<code class="c1">// the size of the value. So a shift of 17 bits in a 16-bit type is a shift</code>
<code class="c1">// of 1.</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">5_</code><code class="k">i16</code><code class="p">.</code><code class="n">wrapping_shl</code><code class="p">(</code><code class="mi">17</code><code class="p">),</code><code class="w"> </code><code class="mi">10</code><code class="p">);</code><code class="w"/></pre>
	</li>
	<li>
	<p><em>Saturating</em> operations return the representable value that is closest to the mathematically correct result:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">32760_</code><code class="k">i16</code><code class="p">.</code><code class="n">saturating_add</code><code class="p">(</code><code class="mi">10</code><code class="p">),</code><code class="w"> </code><code class="mi">32767</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">((</code><code class="o">-</code><code class="mi">32760_</code><code class="k">i16</code><code class="p">).</code><code class="n">saturating_sub</code><code class="p">(</code><code class="mi">10</code><code class="p">),</code><code class="w"> </code><code class="o">-</code><code class="mi">32768</code><code class="p">);</code><code class="w"/></pre>
	</li>
</ul>

<p>The operation names that follow the <code>checked_</code>, <code>wrapping_</code>, or <code>saturating_</code> prefix are as follows:</p>

<table>
	<thead>
		<tr class="header">
			<th>Operation</th>
			<th>Name Suffix</th>
			<th>Example</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td>addition</td>
			<td><code>add</code></td>
			<td><code>100_i8.checked_add(27) == Some(127)</code></td>
		</tr>
		<tr class="even">
			<td>Subtraction</td>
			<td><code>sub</code></td>
			<td><code>10_u8.checked_sub(11) == None</code></td>
		</tr>
		<tr class="odd">
			<td>Multiplication</td>
			<td><code>mul</code></td>
			<td><code>128_u8.saturating_mul(3) == 255</code></td>
		</tr>
		<tr class="even">
			<td>Division</td>
			<td><code>div</code></td>
			<td><code>64_u16.wrapping_div(8) == 8</code></td>
		</tr>
		<tr class="odd">
			<td>Remainder</td>
			<td><code>rem</code></td>
			<td><code>(-32768_i16).wrapping_rem(-1) == 0</code></td>
		</tr>
		<tr class="even">
			<td>Negation</td>
			<td><code>neg</code></td>
			<td><code>(-128_i8).checked_neg() == None</code></td>
		</tr>
		<tr class="odd">
			<td>Absolute value</td>
			<td><code>abs</code></td>
			<td><code>(-32768_i16).wrapping_abs() == -32768</code></td>
		</tr>
		<tr class="even">
			<td>Exponentiation</td>
			<td><code>pow</code></td>
			<td><code>3_u8.checked_pow(4) == Some(81)</code></td>
		</tr>
		<tr class="odd">
			<td>Bitwise left shift</td>
			<td><code>shl</code></td>
			<td><code>10_u32.wrapping_shl(34) == 40</code></td>
		</tr>
		<tr class="even">
			<td>Bitwise right shift</td>
			<td><code>shr</code></td>
			<td><code>40_u64.wrapping_shr(66) == 10</code></td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Floating-Point Types"><div class="sect2" id="floating-point-types">
<h2>Floating-Point Types</h2>

<p><a contenteditable="false" data-primary="floating-point types" data-type="indexterm" id="C03-types.html7"/> <a contenteditable="false" data-primary="machine types" data-secondary="floating-point types" data-type="indexterm" id="C03-types.html8"/> <a contenteditable="false" data-primary="numeric types" data-secondary="floating-point types" data-type="indexterm" id="C03-types.html9"/> Rust provides IEEE single- and double-precision floating-point types. These types include positive and negative infinities, distinct positive and negative zero values, and a <em>not-a-number</em> value:</p>

<table>
	<thead>
		<tr class="header">
			<th>Type</th>
			<th>Precision</th>
			<th>Range</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td><code>f32</code></td>
			<td>IEEE single precision (at least 6 decimal digits)</td>
			<td>Roughly –3.4 × 10<sup>38</sup> to +3.4 × 10<sup>38</sup></td>
		</tr>
		<tr class="even">
			<td><code>f64</code></td>
			<td>IEEE double precision (at least 15 decimal digits)</td>
			<td>Roughly –1.8 × 10<sup>308</sup> to +1.8 × 10<sup>308</sup></td>
		</tr>
	</tbody>
</table>

<p>Rust’s <code>f32</code> and <code>f64</code> correspond to the <code>float</code> and <code>double</code> types in C and C++ implementations that support IEEE floating point, and in Java, which always uses IEEE floating point.</p>

<p><a contenteditable="false" data-primary="floating-point literals" data-type="indexterm" id="idm45625518916856"/> Floating-point literals have the general form diagrammed in <a data-type="xref" href="#fig0301">Figure 2-1</a>.</p>

<figure><div id="fig0301" class="figure"><img alt="(Diagram of a floating-point literal, showing integer part, fractional part,            exponent, and type suffix.)" src="Images/rust_0301.png" width="381" height="266"/>
<h6><span class="label">Figure 2-1. </span>A floating-point literal</h6>
</div></figure>

<p>Every part of a floating-point number after the integer part is optional, but at least one of the fractional part, exponent, or type suffix must be present, to distinguish it from an integer literal. The fractional part may consist of a lone decimal point, so <code>5.</code> is a valid floating-point constant.</p>

<p>If a floating-point literal lacks a type suffix, Rust checks the context to see how the values are used, much as it does for integer literals. If it ultimately finds that either floating-point type could fit, it chooses <code>f64</code> by default.</p>

<p>For the purposes of type inference, Rust treats integer literals and floating-point literals as distinct classes: it will never infer a floating-point type for an integer literal, or vice versa.</p>

<p>Some examples of floating-point literals:</p>

<table class="pagebreak-before">
	<thead>
		<tr class="header">
			<th>Literal</th>
			<th>Type</th>
			<th>Mathematical value</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td><code>-1.5625</code></td>
			<td>Inferred</td>
			<td>−(1 <sup>9</sup>⁄<sub>16</sub>)</td>
		</tr>
		<tr class="even">
			<td><code>2.</code></td>
			<td>Inferred</td>
			<td>2</td>
		</tr>
		<tr class="odd">
			<td><code>0.25</code></td>
			<td>Inferred</td>
			<td>¼</td>
		</tr>
		<tr class="even">
			<td><code>1e4</code></td>
			<td>Inferred</td>
			<td>10,000</td>
		</tr>
		<tr class="odd">
			<td><code>40f32</code></td>
			<td><code>f32</code></td>
			<td>40</td>
		</tr>
		<tr class="even">
			<td><code>9.109_383_56e-31f64</code></td>
			<td><code>f64</code></td>
			<td>Roughly 9.10938356 × 10<sup>–31</sup></td>
		</tr>
	</tbody>
</table>

<p>The standard library’s <code>std::f32</code> and <code>std::f64</code> modules define constants for the IEEE-required special values like <code>INFINITY</code>, <code>NEG_INFINITY</code> (negative infinity), <code>NAN</code> (the not-a-number value), and <code>MIN</code> and <code>MAX</code> (the largest and smallest finite values). The <code>std::f32::consts</code> and <code>std::f64::consts</code> modules provide various commonly used mathematical constants like <code>E</code>, <code>PI</code>, and the square root of two.</p>

<p>The <code>f32</code> and <code>f64</code> types provide a full complement of methods for mathematical calculations; for example, <code>2f64.sqrt()</code> is the double-precision square root of two. The standard library documentation describes these under the names “<code>f32</code> (primitive type)” and “<code>f64</code> (primitive type)”. Some examples:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="mi">5</code><code class="k">f32</code><code class="p">.</code><code class="n">sqrt</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">5</code><code class="k">f32</code><code class="p">.</code><code class="n">sqrt</code><code class="p">(),</code><code class="w"> </code><code class="mf">5.</code><code class="p">);</code><code class="w"> </code><code class="c1">// exactly 5.0, per IEEE</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">((</code><code class="o">-</code><code class="mf">1.01</code><code class="k">f64</code><code class="p">).</code><code class="n">floor</code><code class="p">(),</code><code class="w"> </code><code class="o">-</code><code class="mf">2.0</code><code class="p">);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">((</code><code class="o">-</code><code class="mf">1.</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">std</code>::<code class="kt">f32</code>::<code class="n">INFINITY</code><code class="p">).</code><code class="n">is_sign_negative</code><code class="p">());</code><code class="w"/></pre>

<p>Again, method calls have a higher precedence than prefix operators, so be sure to correctly parenthesize method calls on negated values.</p>

<p>As with integers, you usually won’t need to write out type suffixes on floating-point literals in real code, but when you do, putting a type on either the literal or the function will suffice:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="mf">2.0_</code><code class="k">f64</code><code class="p">).</code><code class="n">sqrt</code><code class="p">());</code><code class="w"/>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">sqrt</code><code class="p">(</code><code class="mf">2.0</code><code class="p">));</code><code class="w"/></pre>

<p>Unlike C and C++, Rust performs almost no numeric conversions implicitly. If a function expects an <code>f64</code> argument, it’s an error to pass an <code>i32</code> value as the argument. In fact, Rust won’t even implicitly convert an <code>i16</code> value to an <code>i32</code> value, even though every <code>i16</code> value is also an <code>i32</code> value. But you can always write out <em>explicit</em> conversions using the <code>as</code> operator: <code>i as f64</code>, or <code>x as i32</code>.</p>

<p>The lack of implicit conversions sometimes makes a Rust expression more verbose than the analogous C or C++ code would be. However, implicit integer conversions have a well-established record of causing bugs and security holes, especially when the integers in question represent the size of something in memory, and an unanticipated overflow occurs. In our experience, the act of writing out numeric conversions in Rust has alerted us to problems we would otherwise have missed.</p>

<p>We explain exactly how conversions behave in <a data-type="xref" href="ch05.xhtml#type-casts">“Type Casts”</a>. <a contenteditable="false" data-primary="" data-startref="C03-types.html9" data-type="indexterm" id="idm45625518806264"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html8" data-type="indexterm" id="idm45625518804728"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html7" data-type="indexterm" id="idm45625518803192"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="The bool Type"><div class="sect2" id="the-bool-type">
<h2>The bool Type</h2>

<p><a contenteditable="false" data-primary="Boolean type (bool)" data-type="indexterm" id="idm45625518800456"/> <a contenteditable="false" data-primary="machine types" data-secondary="Boolean" data-type="indexterm" id="idm45625518799000"/> Rust’s Boolean type, <code>bool</code>, has the usual two values for such types, <code>true</code> and <code>false</code>. Comparison operators like <code>==</code> and <code>&lt;</code> produce <code>bool</code> results: the value of <code>2 &lt; 5</code> is <code>true</code>.</p>

<p>Many languages are lenient about using values of other types in contexts that require a Boolean value: C and C++ implicitly convert characters, integers, floating-point numbers, and pointers to Boolean values, so they can be used directly as the condition in an <code>if</code> or <code>while</code> statement. Python permits strings, lists, dictionaries, and even sets in Boolean contexts, treating such values as true if they’re nonempty. Rust, however, is very strict: control structures like <code>if</code> and <code>while</code> require their conditions to be <code>bool</code> expressions, as do the short-circuiting logical operators <code>&amp;&amp;</code> and <code>||</code>. You must write <code>if x != 0 { ... }</code>, not simply <code>if x { ... }</code>.</p>

<p>Rust’s <code>as</code> operator can convert <code>bool</code> values to integer types:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="kc">false</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="kc">true</code><code class="w">  </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/></pre>

<p>However, <code>as</code> won’t convert in the other direction, from numeric types to <code>bool</code>. Instead, you must write out an explicit comparison like <code>x != 0</code>.</p>

<p>Although a <code>bool</code> only needs a single bit to represent it, Rust uses an entire byte for a <code>bool</code> value in memory, so you can create a pointer to it.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Characters"><div class="sect2" id="characters">
<h2>Characters</h2>

<p><a contenteditable="false" data-primary="char type" data-type="indexterm" id="idm45625518702552"/> <a contenteditable="false" data-primary="machine types" data-secondary="characters" data-type="indexterm" id="idm45625518701320"/> Rust’s character type <code>char</code> represents a single Unicode character, as a 32-bit value.</p>

<p><a contenteditable="false" data-primary="UTF-8" data-secondary="char type and" data-type="indexterm" id="idm45625518699080"/> Rust uses the <code>char</code> type for single characters in isolation, but uses the UTF-8 encoding for strings and streams of text. <a contenteditable="false" data-primary="String types" data-secondary="UTF-8 and" data-type="indexterm" id="idm45625518697016"/> So, a <code>String</code> represents its text as a sequence of UTF-8 bytes, not as an array of characters.</p>

<p><a contenteditable="false" data-primary="character literals" data-type="indexterm" id="idm45625518694776"/> <a contenteditable="false" data-primary="Unicode" data-secondary="character literals" data-type="indexterm" id="idm45625518693320"/> Character literals are characters enclosed in single quotes, like <code>'8'</code> or <code>'!'</code>. You can use the full breadth of Unicode: <code>'錆'</code> is a <code>char</code> literal representing the Japanese kanji for <em>sabi</em> (rust).</p>

<p>As with byte literals, backslash escapes are required for a few characters:</p>

<table>
	<thead>
		<tr class="header">
			<th>Character</th>
			<th>Rust character literal</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td>Single quote, <code>'</code></td>
			<td><code>'\''</code></td>
		</tr>
		<tr class="even">
			<td>Backslash, <code>\</code></td>
			<td><code>'\\'</code></td>
		</tr>
		<tr class="odd">
			<td>Newline</td>
			<td><code>'\n'</code></td>
		</tr>
		<tr class="even">
			<td>Carriage return</td>
			<td><code>'\r'</code></td>
		</tr>
		<tr class="odd">
			<td>Tab</td>
			<td><code>'\t'</code></td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="hexadecimals" data-type="indexterm" id="idm45625518650248"/> If you prefer, you can write out a character’s Unicode code point in hexadecimal:</p>

<ul>
	<li>
	<p>If the character’s code point is in the range U+0000 to U+007F (that is, if it is drawn from the ASCII character set), then you can write the character as <code>'\xHH'</code>, where <code>HH</code> is a two-digit hexadecimal number. For example, the character literals <code>'*'</code> and <code>'\x2A'</code> are equivalent, because the code point of the character <code>*</code> is 42, or 2A in hexadecimal.</p>
	</li>
	<li>
	<p>You can write any Unicode character as <code>'\u{HHHHHH}'</code>, where <code>HHHHHH</code> is a hexadecimal number up to six digits long, with underscores allowed for grouping as usual. For example, the character literal <code>'\u{CA0}'</code> represents the character “ಠ”, a Kannada character used in the Unicode Look of Disapproval, “ಠ_ಠ”. The same literal could also be simply written as <code>'ಠ'</code>.</p>
	</li>
</ul>

<p>A <code>char</code> always holds a Unicode code point in the range 0x0000 to 0xD7FF, or 0xE000 to 0x10FFFF. A <code>char</code> is never a surrogate pair half (that is, a code point in the range 0xD800 to 0xDFFF), or a value outside the Unicode codespace (that is, greater than 0x10FFFF). Rust uses the type system and dynamic checks to ensure <code>char</code> values are always in the permitted range.</p>

<p>Rust never implicitly converts between <code>char</code> and any other type. You can use the <code>as</code> conversion operator to convert a <code>char</code> to an integer type; for types smaller than 32 bits, the upper bits of the character’s value are truncated:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'*'</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'ಠ'</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u16</code><code class="p">,</code><code class="w"> </code><code class="mh">0xca0</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'ಠ'</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i8</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mh">0x60</code><code class="p">);</code><code class="w"> </code><code class="c1">// U+0CA0 truncated to eight bits, signed</code></pre>

<p>Going in the other direction, <code>u8</code> is the only type the <code>as</code> operator will convert to <code>char</code>: Rust intends the <code>as</code> operator to perform only cheap, infallible conversions, but every integer type other than <code>u8</code> includes values that are not permitted Unicode code points, so those conversions would require run-time checks. Instead, the standard library function <code>std::char::from_u32</code> takes any <code>u32</code> value and returns an <code>Option&lt;char&gt;</code>: if the <code>u32</code> is not a permitted Unicode code point, then <code>from_u32</code> returns <code>None</code>; otherwise, it returns <code>Some(c)</code>, where <code>c</code> is the <code>char</code> result.</p>

<p>The standard library provides some useful methods on characters, which you can look up in the online documentation by searching for “<code>char</code> (primitive type)”, and for the module “<code>std::char</code>”. For example:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'*'</code><code class="p">.</code><code class="n">is_alphabetic</code><code class="p">(),</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'β'</code><code class="p">.</code><code class="n">is_alphabetic</code><code class="p">(),</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'8'</code><code class="p">.</code><code class="n">to_digit</code><code class="p">(</code><code class="mi">10</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="mi">8</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="sc">'ಠ'</code><code class="p">.</code><code class="n">len_utf8</code><code class="p">(),</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="n">char</code>::<code class="n">from_digit</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="sc">'2'</code><code class="p">));</code><code class="w"/></pre>

<p>Naturally, single characters in isolation are not as interesting as strings and streams of text. We’ll describe Rust’s standard <code>String</code> type and text handling in general in <a data-type="xref" href="#string-types">“String Types”</a>. <a contenteditable="false" data-primary="" data-startref="C03-types.html3" data-type="indexterm" id="idm45625518496488"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html2" data-type="indexterm" id="idm45625518494984"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html1" data-type="indexterm" id="idm45625518493448"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Tuples"><div class="sect1" id="tuples">
<h1>Tuples</h1>

<p><a contenteditable="false" data-primary="tuples" data-type="indexterm" id="C03-types.html10"/> <a contenteditable="false" data-primary="types" data-secondary="tuples" data-type="indexterm" id="C03-types.html11"/> A <em>tuple</em> is a pair, or triple, or quadruple, ... of values of assorted types. You can write a tuple as a sequence of elements, separated by commas and surrounded by parentheses. For example, <code>("Brazil", 1985)</code> is a tuple whose first element is a statically allocated string, and whose second is an integer; its type is <code>(&amp;str, i32)</code> (or whatever integer type Rust infers for <code>1985</code>). Given a tuple value <code>t</code>, you can access its elements as <code>t.0</code>, <code>t.1</code>, and so on.</p>

<p><a contenteditable="false" data-primary="arrays" data-secondary="tuples vs." data-type="indexterm" id="idm45625518483096"/> Tuples aren’t much like arrays: for one thing, each element of a tuple can have a different type, whereas an array’s elements must be all the same type. Further, tuples allow only constants as indices, like <code>t.4</code>. You can’t write <code>t.i</code> or <code>t[i]</code> to get the <code>i</code>‘th element.</p>

<p>Rust code often uses tuple types to return multiple values from a function. For example, the <code>split_at</code> method on string slices, which divides a string into two halves and returns them both, is declared like this:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">split_at</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">mid</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="o">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="kt">str</code><code class="p">);</code><code class="w"/></pre>

<p>The return type <code>(&amp;str, &amp;str)</code> is a tuple of two string slices. You can use pattern-matching syntax to assign each element of the return value to a different variable:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"I see the eigenvalue in thine eye"</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">head</code><code class="p">,</code><code class="w"> </code><code class="n">tail</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="n">split_at</code><code class="p">(</code><code class="mi">21</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">head</code><code class="p">,</code><code class="w"> </code><code class="s">"I see the eigenvalue "</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">tail</code><code class="p">,</code><code class="w"> </code><code class="s">"in thine eye"</code><code class="p">);</code><code class="w"/></pre>

<p>This is more legible than the equivalent:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"I see the eigenvalue in thine eye"</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">temp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="n">split_at</code><code class="p">(</code><code class="mi">21</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">head</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">temp</code><code class="p">.</code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">tail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">temp</code><code class="p">.</code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">head</code><code class="p">,</code><code class="w"> </code><code class="s">"I see the eigenvalue "</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">tail</code><code class="p">,</code><code class="w"> </code><code class="s">"in thine eye"</code><code class="p">);</code><code class="w"/></pre>

<p>You’ll also see tuples used as a sort of minimal-drama struct type. For example, in the Mandelbrot program in XREF HERE, we needed to pass the width and height of the image to the functions that plot it and write it to disk. We could declare a struct with <code>width</code> and <code>height</code> members, but that’s pretty heavy notation for something so obvious, so we just used a tuple:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="sd">/// Write the buffer `pixels`, whose dimensions are given by `bounds`, to the</code>
<code class="sd">/// file named `filename`.</code>
<code class="k">fn</code> <code class="nf">write_image</code><code class="p">(</code><code class="n">filename</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">pixels</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">],</code><code class="w"> </code><code class="n">bounds</code>: <code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="p">))</code><code class="w"/>
<code class="w">    </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"/>
<code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>The type of the <code>bounds</code> parameter is <code>(usize, usize)</code>, a tuple of two <code>usize</code> values. Admittedly, we could just as well write out separate <code>width</code> and <code>height</code> parameters, and the machine code would be about the same either way. It’s a matter of clarity. We think of the size as one value, not two, and using a tuple lets us write what we mean.</p>

<p>The other commonly used tuple type is the zero-tuple <code>()</code>. This is traditionally called the <em>unit type</em> because it has only one value, also written <code>()</code>. Rust uses the unit type where there’s no meaningful value to carry, but context requires some sort of type nonetheless.</p>

<p>For example, a function that returns no value has a return type of <code>()</code>. The standard library’s <code>std::mem::swap</code> function has no meaningful return value; it just exchanges the values of its two arguments. The declaration for <code>std::mem::swap</code> reads:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">swap</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">x</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">T</code><code class="p">);</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="&lt;T&gt;" data-type="indexterm" id="idm45625518183336"/> <a contenteditable="false" data-primary="generic swaps" data-type="indexterm" id="idm45625518173864"/> The <code>&lt;T&gt;</code> means that <code>swap</code> is <em>generic</em>: you can use it on references to values of any type <code>T</code>. But the signature omits the <code>swap</code>’s return type altogether, which is shorthand for returning the unit type:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">swap</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">x</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">();</code><code class="w"/></pre>

<p>Similarly, the <code>write_image</code> example we mentioned before has a return type of <code>Result&lt;(), std::io::Error&gt;</code>, meaning that the function returns a <code>std::io::Error</code> value if something goes wrong, but returns no value on success.</p>

<p>If you like, you may include a comma after a tuple’s last element: the types <code>(&amp;str, i32,)</code> and <code>(&amp;str, i32)</code> are equivalent, as are the expressions <code>("Brazil", 1985,)</code> and <code>("Brazil", 1985)</code>. Rust consistently permits an extra trailing comma everywhere commas are used: function arguments, arrays, struct and enum definitions, and so on. This may look odd to human readers, but it can make diffs easier to read when entries are added and removed at the end of a list.</p>

<p>For consistency’s sake, there are even tuples that contain a single value. The literal <code>("lonely hearts",)</code> is a tuple containing a single string; its type is <code>(&amp;str,)</code>. Here, the comma after the value is necessary to distinguish the singleton tuple from a simple parenthetic expression. <a contenteditable="false" data-primary="" data-startref="C03-types.html11" data-type="indexterm" id="idm45625518085016"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html10" data-type="indexterm" id="idm45625518083512"/></p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Pointer Types"><div class="sect1" id="pointer-types">
<h1>Pointer Types</h1>

<p><a contenteditable="false" data-primary="pointer types" data-type="indexterm" id="C03-types.html12"/> <a contenteditable="false" data-primary="types" data-secondary="pointer types" data-type="indexterm" id="C03-types.html13"/> Rust has several types that represent memory addresses.</p>

<p><a contenteditable="false" data-primary="garbage collection" data-secondary="pointers and" data-type="indexterm" id="idm45625518077000"/> This is a big difference between Rust and most languages with garbage collection. In Java, if <code>class Rectangle</code> contains a field <code>Point upperLeft;</code>, then <code>upperLeft</code> is a reference to another separately created <code>Point</code> object. Objects never physically contain other objects in Java.</p>

<p>Rust is different. The language is designed to help keep allocations to a minimum. Values nest by default. The value <code>((0, 0), (1440, 900))</code> is stored as four adjacent integers. If you store it in a local variable, you’ve got a local variable four integers wide. Nothing is allocated in the heap.</p>

<p>This is great for memory efficiency, but as a consequence, when a Rust program needs values to point to other values, it must use pointer types explicitly. The good news is that the pointer types used in safe Rust are constrained to eliminate undefined behavior, so pointers are much easier to use correctly in Rust than in C++.</p>

<p>We’ll discuss three pointer types here: references, boxes, and unsafe pointers.</p>

<section data-type="sect2" data-pdf-bookmark="References"><div class="sect2" id="pointers-references">
<h2>References</h2>

<p><a contenteditable="false" data-primary="pointer types" data-secondary="references" data-type="indexterm" id="idm45625518069432"/> <a contenteditable="false" data-primary="references (pointer type)" data-type="indexterm" id="idm45625518067704"/> A value of type <code>&amp;String</code> (pronounced “ref String”) is a reference to a <code>String</code> value, a <code>&amp;i32</code> is a reference to an <code>i32</code>, and so on.</p>

<p>It’s easiest to get started by thinking of references as Rust’s basic pointer type. At run time, a reference to an <code>i32</code> is a single machine word holding the address of the <code>i32</code>, which may be on the stack or in the heap. The expression <code>&amp;x</code> produces a reference to <code>x</code>; in Rust terminology, we say that it <em>borrows a reference to <code>x</code></em>. Given a reference <code>r</code>, the expression <code>*r</code> refers to the value <code>r</code> points to. These are very much like the <code>&amp;</code> and <code>*</code> operators in C and C++. And like a C pointer, a reference does not automatically free any resources when it goes out of scope.</p>

<p><a contenteditable="false" data-primary="null references" data-type="indexterm" id="idm45625518038872"/> Unlike C pointers, however, Rust references are never null: there is simply no way to produce a null reference in safe Rust. And unlike C, Rust tracks the ownership and lifetimes of values, so mistakes like dangling pointers, double frees, and pointer invalidation are ruled out at compile time.</p>

<p><a contenteditable="false" data-primary="shared references" data-type="indexterm" id="idm45625518037032"/> <a contenteditable="false" data-primary="immutable references" data-type="indexterm" id="idm45625518035800"/> <a contenteditable="false" data-primary="references, shared" data-type="indexterm" id="idm45625518034536"/> <a contenteditable="false" data-primary="references, immutable" data-type="indexterm" id="idm45625518033272"/> Rust references come in two flavors:</p>

<dl>
	<dt><code>&amp;T</code></dt>
	<dd>
	<p>A shared reference. You can have many shared references to a given value at a time, but they are read-only: modifying the value they point to is forbidden, as with <code>const T*</code> in C.</p>
	</dd>
	<dt><code>&amp;mut T</code></dt>
	<dd>
	<p>A mutable reference. You can read and modify the value it points to, as with a <code>T*</code> in C. But for as long as the reference exists, you may not have any other references of any kind to that value. In fact, the only way you may access the value at all is through the mutable reference.</p>
	</dd>
</dl>

<p><a contenteditable="false" data-primary="single writer or multiple readers rule" data-type="indexterm" id="idm45625518026936"/> <a contenteditable="false" data-primary="multiple readers or single writer rule" data-type="indexterm" id="idm45625518025736"/> Rust uses this dichotomy between shared and mutable references to enforce a “single writer <em>or</em> multiple readers” rule: either you can read and write the value, or it can be shared by any number of readers, but never both at the same time. This separation, enforced by compile-time checks, is central to Rust’s safety guarantees. <a data-type="xref" href="ch04.xhtml#references">Chapter 4</a> explains Rust’s rules for safe reference use.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Boxes"><div class="sect2" id="boxes">
<h2>Boxes</h2>

<p><a contenteditable="false" data-primary="boxes" data-type="indexterm" id="idm45625518020920"/> <a contenteditable="false" data-primary="pointer types" data-secondary="boxes" data-type="indexterm" id="idm45625518019688"/> The simplest way to allocate a value in the heap is to use <code>Box::new</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">12</code><code class="p">,</code><code class="w"> </code><code class="s">"eggs"</code><code class="p">);</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">t</code><code class="p">);</code><code class="w">  </code><code class="c1">// allocate a tuple in the heap</code></pre>

<p>The type of <code>t</code> is <code>(i32, &amp;str)</code>, so the type of <code>b</code> is <code>Box&lt;(i32, &amp;str)&gt;</code>. <code>Box::new()</code> allocates enough memory to contain the tuple on the heap. When <code>b</code> goes out of scope, the memory is freed immediately, unless <code>b</code> has been <em>moved</em>—by returning it, for example. Moves are essential to the way Rust handles heap-allocated values; we explain all this in detail in <a data-type="xref" href="ch03.xhtml#ownership">Chapter 3</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Raw Pointers"><div class="sect2" id="raw-pointers">
<h2>Raw Pointers</h2>

<p><a contenteditable="false" data-primary="*const T" data-type="indexterm" id="idm45625517988696"/> <a contenteditable="false" data-primary="*mut T" data-type="indexterm" id="idm45625517987240"/> <a contenteditable="false" data-primary="pointer types" data-secondary="raw pointers" data-type="indexterm" id="idm45625517985976"/> <a contenteditable="false" data-primary="raw pointers" data-type="indexterm" id="idm45625517984440"/> Rust also has the raw pointer types <code>*mut T</code> and <code>*const T</code>. Raw pointers really are just like pointers in C++. Using a raw pointer is unsafe, because Rust makes no effort to track what it points to. For example, raw pointers may be null, or they may point to memory that has been freed or that now contains a value of a different type. All the classic pointer mistakes of C++ are offered for your enjoyment.</p>

<p><a contenteditable="false" data-primary="dereferencing" data-secondary="raw pointers" data-type="indexterm" id="idm45625517981784"/> <a contenteditable="false" data-primary="unsafe blocks" data-secondary="dereferencing raw pointers with" data-type="indexterm" id="idm45625517980056"/> However, you may only dereference raw pointers within an <code>unsafe</code> block. An <code>unsafe</code> block is Rust’s opt-in mechanism for advanced language features whose safety is up to you. If your code has no <code>unsafe</code> blocks (or if those it does are written correctly), then the safety guarantees we emphasize throughout this book still hold. For details, see XREF HERE. <a contenteditable="false" data-primary="" data-startref="C03-types.html13" data-type="indexterm" id="idm45625517976968"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html12" data-type="indexterm" id="idm45625517975464"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Arrays, Vectors, and Slices"><div class="sect1" id="arrays-vectors-and-slices">
<h1>Arrays, Vectors, and Slices</h1>

<p><a contenteditable="false" data-primary="memory" data-secondary="types for representing sequence of values in" data-type="indexterm" id="C03-types.html14"/> <a contenteditable="false" data-primary="types" data-secondary="for representing sequence of values in memory" data-type="indexterm" id="C03-types.html15"/> Rust has three types for representing a sequence of values in memory:</p>

<ul>
	<li>
	<p><a contenteditable="false" data-primary="[T; N] type" data-type="indexterm" id="idm45625517967992"/> The type <code>[T; N]</code> represents an array of <code>N</code> values, each of type <code>T</code>. An array’s size is a constant determined at compile time, and is part of the type; you can’t append new elements, or shrink an array.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-type="indexterm" id="idm45625517936952"/> The type <code>Vec&lt;T&gt;</code>, called a <em>vector of <code>T</code>s</em>, is a dynamically allocated, growable sequence of values of type <code>T</code>. A vector’s elements live on the heap, so you can resize vectors at will: push new elements onto them, append other vectors to them, delete elements, and so on.</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="&amp;[T] type" data-type="indexterm" id="idm45625517933176"/> <a contenteditable="false" data-primary="&amp;mut [T] type" data-type="indexterm" id="idm45625517931720"/> The types <code>&amp;[T]</code> and <code>&amp;mut [T]</code>, called a <em>shared slice of <code>T</code>s</em> and <em>mutable slice of <code>T</code>s</em>, are references to a series of elements that are a part of some other value, like an array or vector. You can think of a slice as a pointer to its first element, together with a count of the number of elements you can access starting at that point. A mutable slice <code>&amp;mut [T]</code> lets you read and modify elements, but can’t be shared; a shared slice <code>&amp;[T]</code> lets you share access among several readers, but doesn’t let you modify elements.</p>
	</li>
</ul>

<p>Given a value <code>v</code> of any of these three types, the expression <code>v.len()</code> gives the number of elements in <code>v</code>, and <code>v[i]</code> refers to the <code>i</code>‘th element of <code>v</code>. The first element is <code>v[0]</code>, and the last element is <code>v[v.len() - 1]</code>. Rust checks that <code>i</code> always falls within this range; if it doesn’t, the expression panics. The length of <code>v</code> may be zero, in which case any attempt to index it will panic. <code>i</code> must be a <code>usize</code> value; you can’t use any other integer type as an index.</p>

<section data-type="sect2" data-pdf-bookmark="Arrays"><div class="sect2" id="arrays">
<h2>Arrays</h2>

<p><a contenteditable="false" data-primary="arrays" data-secondary="basics" data-type="indexterm" id="idm45625517918728"/> <a contenteditable="false" data-primary="types" data-secondary="arrays" data-type="indexterm" id="idm45625517917224"/> There are several ways to write array values. The simplest is to write a series of values within square brackets:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">lazy_caterer</code>: <code class="p">[</code><code class="kt">u32</code><code class="p">;</code><code class="w"> </code><code class="mi">6</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">11</code><code class="p">,</code><code class="w"> </code><code class="mi">16</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">taxonomy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s">"Animalia"</code><code class="p">,</code><code class="w"> </code><code class="s">"Arthropoda"</code><code class="p">,</code><code class="w"> </code><code class="s">"Insecta"</code><code class="p">];</code><code class="w"/>

<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">lazy_caterer</code><code class="p">[</code><code class="mi">3</code><code class="p">],</code><code class="w"> </code><code class="mi">7</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">taxonomy</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/></pre>

<p>For the common case of a long array filled with some value, you can write <code>[<em>V</em>; <em>N</em>]</code>, where <code><em>V</em></code> is the value each element should have, and <code><em>N</em></code> is the length. For example, <code>[true; 10000]</code> is an array of 10,000 <code>bool</code> elements, all set to <code>true</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">sieve</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="kc">true</code><code class="p">;</code><code class="w"> </code><code class="mi">10000</code><code class="p">];</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">2</code><code class="p">..</code><code class="mi">100</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">sieve</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">j</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">while</code><code class="w"> </code><code class="n">j</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10000</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">sieve</code><code class="p">[</code><code class="n">j</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">j</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">sieve</code><code class="p">[</code><code class="mi">211</code><code class="p">]);</code><code class="w"/>
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="o">!</code><code class="n">sieve</code><code class="p">[</code><code class="mi">9876</code><code class="p">]);</code><code class="w"/></pre>

<p>You’ll see this syntax used for fixed-size buffers: <code>[0u8; 1024]</code> can be a one-kilobyte buffer, filled with zero bytes. Rust has no notation for an uninitialized array. (In general, Rust ensures that code can never access any sort of uninitialized value.)</p>

<p>An array’s length is part of its type and fixed at compile time. If <code>n</code> is a variable, you can’t write <code>[true; n]</code> to get an array of <code>n</code> elements. When you need an array whose length varies at run time (and you usually do), use a vector instead.</p>

<p>The useful methods you’d like to see on arrays—iterating over elements, searching, sorting, filling, filtering, and so on—are all provided as methods on slices, not arrays. But Rust implicitly converts a reference to an array to a slice when searching for methods, so you can call any slice method on an array directly:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">chaos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">];</code><code class="w"/>
<code class="n">chaos</code><code class="p">.</code><code class="n">sort</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">chaos</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">]);</code><code class="w"/></pre>

<p>Here, the <code>sort</code> method is actually defined on slices, but since it takes its operand by reference, Rust implicitly produces a <code>&amp;mut [i32]</code> slice referring to the entire array, and passes that to <code>sort</code> to operate on. In fact, the <code>len</code> method we mentioned earlier is a slice method as well. We cover slices in more detail in <a data-type="xref" href="#slices">“Slices”</a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Vectors"><div class="sect2" id="vectors">
<h2>Vectors</h2>

<p><a contenteditable="false" data-primary="types" data-secondary="vectors" data-type="indexterm" id="C03-types.html16"/> <a contenteditable="false" data-primary="vectors" data-type="indexterm" id="C03-types.html17"/> <a contenteditable="false" data-primary="vectors" data-secondary="basics" data-type="indexterm" id="C03-types.html18"/> A vector <code>Vec&lt;T&gt;</code> is a resizable array of elements of type <code>T</code>, allocated on the heap.</p>

<p>There are several ways to create vectors. The simplest is to use the <code>vec!</code> macro, which gives us a syntax for vectors that looks very much like an array literal:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">primes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">primes</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">product</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="mi">210</code><code class="p">);</code><code class="w"/></pre>

<p>But of course, this is a vector, not an array, so we can add elements to it dynamically:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">primes</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">11</code><code class="p">);</code><code class="w"/>
<code class="n">primes</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">13</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">primes</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">product</code>::<code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">(),</code><code class="w"> </code><code class="mi">30030</code><code class="p">);</code><code class="w"/></pre>

<p>You can also build a vector by repeating a given value a certain number of times, again using a syntax that imitates array literals:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">new_pixel_buffer</code><code class="p">(</code><code class="n">rows</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="n">cols</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">rows</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">cols</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>vec!</code> macro is equivalent to calling <code>Vec::new</code> to create a new, empty vector, and then pushing the elements onto it, which is another idiom:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">pal</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"/>
<code class="n">pal</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="s">"step"</code><code class="p">);</code><code class="w"/>
<code class="n">pal</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="s">"on"</code><code class="p">);</code><code class="w"/>
<code class="n">pal</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="s">"no"</code><code class="p">);</code><code class="w"/>
<code class="n">pal</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="s">"pets"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">pal</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"step"</code><code class="p">,</code><code class="w"> </code><code class="s">"on"</code><code class="p">,</code><code class="w"> </code><code class="s">"no"</code><code class="p">,</code><code class="w"> </code><code class="s">"pets"</code><code class="p">]);</code><code class="w"/></pre>

<p>Another possibility is to build a vector from the values produced by an iterator:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="p">..</code><code class="mi">5</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">]);</code><code class="w"/></pre>

<p>You’ll often need to supply the type when using <code>collect</code> (as we’ve done here), because it can build many different sorts of collections, not just vectors. By specifying the type of <code>v</code>, we’ve made it unambiguous which sort of collection we want.</p>

<p>As with arrays, you can use slice methods on vectors:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// A palindrome!</code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">palindrome</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"a man"</code><code class="p">,</code><code class="w"> </code><code class="s">"a plan"</code><code class="p">,</code><code class="w"> </code><code class="s">"a canal"</code><code class="p">,</code><code class="w"> </code><code class="s">"panama"</code><code class="p">];</code><code class="w"/>
<code class="n">palindrome</code><code class="p">.</code><code class="n">reverse</code><code class="p">();</code><code class="w"/>
<code class="c1">// Reasonable yet disappointing:</code>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">palindrome</code><code class="p">,</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"panama"</code><code class="p">,</code><code class="w"> </code><code class="s">"a canal"</code><code class="p">,</code><code class="w"> </code><code class="s">"a plan"</code><code class="p">,</code><code class="w"> </code><code class="s">"a man"</code><code class="p">]);</code><code class="w"/></pre>

<p>Here, the <code>reverse</code> method is actually defined on slices, but the call implicitly borrows a <code>&amp;mut [&amp;str]</code> slice from the vector, and invokes <code>reverse</code> on that.</p>

<p><code>Vec</code> is an essential type to Rust—it’s used almost anywhere one needs a list of dynamic size—so there are many other methods that construct new vectors or extend existing ones. We’ll cover them in XREF HERE.</p>

<p><a contenteditable="false" data-primary="Vec&lt;T&gt; collection type" data-type="indexterm" id="idm45625517188280"/> A <code>Vec&lt;T&gt;</code> consists of three values: a pointer to the heap-allocated buffer allocated to hold the elements; the number of elements that buffer has the capacity to store; and the number it actually contains now (in other words, its length). When the buffer has reached its capacity, adding another element to the vector entails allocating a larger buffer, copying the present contents into it, updating the vector’s pointer and capacity to describe the new buffer, and finally freeing the old one.</p>

<p>If you know the number of elements a vector will need in advance, instead of <code>Vec::new</code> you can call <code>Vec::with_capacity</code> to create a vector with a buffer large enough to hold them all, right from the start; then, you can add the elements to the vector one at a time without causing any reallocation. The <code>vec!</code> macro uses a trick like this, since it knows how many elements the final vector will have. Note that this only establishes the vector’s initial size; if you exceed your estimate, the vector simply enlarges its storage as usual.</p>

<p>Many library functions look for the opportunity to use <code>Vec::with_capacity</code> instead of <code>Vec::new</code>. For example, in the <code>collect</code> example, the iterator <code>0..5</code> knows in advance that it will yield five values, and the <code>collect</code> function takes advantage of this to pre-allocate the vector it returns with the correct capacity. We’ll see how this works in XREF HERE.</p>

<p>Just as a vector’s <code>len</code> method returns the number of elements it contains now, its <code>capacity</code> method returns the number of elements it could hold without reallocation:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">with_capacity</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">capacity</code><code class="p">(),</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/>

<code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">capacity</code><code class="p">(),</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/>

<code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="c1">// Typically prints "capacity is now 4":</code>
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"capacity is now {}"</code><code class="p">,</code><code class="w"> </code><code class="n">v</code><code class="p">.</code><code class="n">capacity</code><code class="p">());</code><code class="w"/></pre>

<p>The capacity printed at the end isn’t guaranteed to be exactly 4, but it will be at least 3, since the vector is holding three values.</p>

<p>You can insert and remove elements wherever you like in a vector, although these operations shift all the elements after the insertion point forward or backward, so they may be slow if the vector is long:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">];</code><code class="w"/>

<code class="c1">// Make the element at index 3 be 35.</code>
<code class="n">v</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">35</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">35</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">]);</code><code class="w"/>

<code class="c1">// Remove the element at index 1.</code>
<code class="n">v</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">35</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">]);</code><code class="w"/></pre>

<p>You can use the <code>pop</code> method to remove the last element and return it. More precisely, popping a value from a <code>Vec&lt;T&gt;</code> returns an <code>Option&lt;T&gt;</code>: <code>None</code> if the vector was already empty, or <code>Some(v)</code> if its last element had been <code>v</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"Snow Puff"</code><code class="p">,</code><code class="w"> </code><code class="s">"Glass Gem"</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"Glass Gem"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="s">"Snow Puff"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">pop</code><code class="p">(),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"/></pre>

<p>You can use a <code>for</code> loop to iterate over a vector:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="c1">// Get our command-line arguments as a vector of Strings.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">languages</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">args</code><code class="p">().</code><code class="n">skip</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">languages</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">l</code><code class="p">,</code><code class="w"/>
<code class="w">             </code><code class="k">if</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                 </code><code class="s">"functional"</code><code class="w"/>
<code class="w">             </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                 </code><code class="s">"imperative"</code><code class="w"/>
<code class="w">             </code><code class="p">});</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Running this program with a list of programming languages is illuminating:</p>

<pre class="console" data-code-language="console" data-type="programlisting">
<code class="gp">$</code> cargo run Lisp Scheme C C++ Fortran
<code class="go">   Compiling proglangs v0.1.0 (/home/jimb/rust/proglangs)</code>
<code class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.36s</code>
<code class="go">     Running `target/debug/proglangs Lisp Scheme C C++ Fortran`</code>
<code class="go">Lisp: functional</code>
<code class="go">Scheme: functional</code>
<code class="go">C: imperative</code>
<code class="go">C++: imperative</code>
<code class="go">Fortran: imperative</code>
<code class="gp">$</code></pre>

<p>Finally, a satisfying definition for the term <em>functional language</em>.</p>

<p>Despite its fundamental role, <code>Vec</code> is an ordinary type defined in Rust, not built into the language. We’ll cover the techniques needed to implement such types in XREF HERE. <a contenteditable="false" data-primary="" data-startref="C03-types.html18" data-type="indexterm" id="idm45625516699608"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html17" data-type="indexterm" id="idm45625516698360"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html16" data-type="indexterm" id="idm45625516696824"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Slices"><div class="sect2" id="slices">
<h2>Slices</h2>

<p><a contenteditable="false" data-primary="[t] slices" data-seealso="slices" data-type="indexterm" id="idm45625516647576"/> <a contenteditable="false" data-primary="arrays" data-secondary="slices and" data-type="indexterm" id="idm45625516645848"/> <a contenteditable="false" data-primary="slices" data-type="indexterm" id="idm45625516644312"/> <a contenteditable="false" data-primary="types" data-secondary="slices" data-type="indexterm" id="idm45625516643048"/> <a contenteditable="false" data-primary="vectors" data-secondary="slices and" data-type="indexterm" id="idm45625516641512"/> A slice, written <code>[T]</code> without specifying the length, is a region of an array or vector. Since a slice can be any length, slices can’t be stored directly in variables or passed as function arguments. Slices are always passed by reference.</p>

<p><a contenteditable="false" data-primary="fat pointer" data-type="indexterm" id="idm45625516639128"/> A reference to a slice is a <em>fat pointer</em>: a two-word value comprising a pointer to the slice’s first element, and the number of elements in the slice.</p>

<p>Suppose you run the following code:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">v</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">f64</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="mf">0.0</code><code class="p">,</code><code class="w">  </code><code class="mf">0.707</code><code class="p">,</code><code class="w">  </code><code class="mf">1.0</code><code class="p">,</code><code class="w">  </code><code class="mf">0.707</code><code class="p">];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">a</code>: <code class="p">[</code><code class="kt">f64</code><code class="p">;</code><code class="w"> </code><code class="mi">4</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w">     </code><code class="p">[</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">0.707</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">0.707</code><code class="p">];</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">sv</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">f64</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">v</code><code class="p">;</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">sa</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">f64</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">a</code><code class="p">;</code><code class="w"/></pre>

<p>On the last two lines, Rust automatically converts the <code>&amp;Vec&lt;f64&gt;</code> reference and the <code>&amp;[f64; 4]</code> reference to slice references that point directly to the data.</p>

<p>By the end, memory looks like <a data-type="xref" href="#fig0302">Figure 2-2</a>.</p>

<figure><div id="fig0302" class="figure"><img alt="borrowing a slice of a vector" src="Images/rust_03in01.png" width="1366" height="527"/>
<h6><span class="label">Figure 2-2. </span>A vector v and an array a in memory, with slices sa and sv referring to each</h6>
</div></figure>

<p>Whereas an ordinary reference is a non-owning pointer to a single value, a reference to a slice is a non-owning pointer to a range of consecutive values in memory. This makes slice references a good choice when you want to write a function that operates on either an array or a vector. For example, here’s a function that prints a slice of numbers, one per line:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="k">fn</code> <code class="nf">print</code><code class="p">(</code><code class="n">n</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">f64</code><code class="p">])</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">elt</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">elt</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">print</code><code class="p">(</code><code class="o">&amp;</code><code class="n">a</code><code class="p">);</code><code class="w">  </code><code class="c1">// works on arrays</code>
<code class="n">print</code><code class="p">(</code><code class="o">&amp;</code><code class="n">v</code><code class="p">);</code><code class="w">  </code><code class="c1">// works on vectors</code></pre>

<p>Because this function takes a slice reference as an argument, you can apply it to either a vector or an array, as shown. In fact, many methods you might think of as belonging to vectors or arrays are methods defined on slices: for example, the <code>sort</code> and <code>reverse</code> methods, which sort or reverse a sequence of elements in place, are actually methods on the slice type <code>[T]</code>.</p>

<p>You can get a reference to a slice of an array or vector, or a slice of an existing slice, by indexing it with a range:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">print</code><code class="p">(</code><code class="o">&amp;</code><code class="n">v</code><code class="p">[</code><code class="mi">0</code><code class="p">..</code><code class="mi">2</code><code class="p">]);</code><code class="w">    </code><code class="c1">// print the first two elements of v</code>
<code class="n">print</code><code class="p">(</code><code class="o">&amp;</code><code class="n">a</code><code class="p">[</code><code class="mi">2</code><code class="p">..]);</code><code class="w">     </code><code class="c1">// print elements of a starting with a[2]</code>
<code class="n">print</code><code class="p">(</code><code class="o">&amp;</code><code class="n">sv</code><code class="p">[</code><code class="mi">1</code><code class="p">..</code><code class="mi">3</code><code class="p">]);</code><code class="w">   </code><code class="c1">// print v[1] and v[2]</code></pre>

<p>As with ordinary array accesses, Rust checks that the indices are valid. Trying to borrow a slice that extends past the end of the data results in a panic.</p>

<p>Since slices almost always appear behind references, we often just refer to types like <code>&amp;[T]</code> or <code>&amp;str</code> as ’slices', using the shorter name for the more common concept. <a contenteditable="false" data-primary="" data-startref="C03-types.html15" data-type="indexterm" id="idm45625516479416"/> <a contenteditable="false" data-primary="" data-startref="C03-types.html14" data-type="indexterm" id="idm45625516477944"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="String Types"><div class="sect1" id="string-types">
<h1>String Types</h1>

<p><a contenteditable="false" data-primary="String types" data-type="indexterm" id="C03-types.html19"/> Programmers familiar with C++ will recall that there are two string types in the language. String literals have the pointer type <code>const char *</code>. The standard library also offers a class, <code>std::string</code>, for dynamically creating strings at run time.</p>

<p>Rust has a similar design. In this section, we’ll show all the ways to write string literals, then introduce Rust’s two string types. We provide more detail about strings and text handling in XREF HERE.</p>

<section data-type="sect2" data-pdf-bookmark="String Literals"><div class="sect2" id="string-literals">
<h2>String Literals</h2>

<p><a contenteditable="false" data-primary="string literals" data-type="indexterm" id="idm45625516363928"/> <a contenteditable="false" data-primary="String types" data-secondary="string literals" data-type="indexterm" id="idm45625516362696"/> String literals are enclosed in double quotes. They use the same backslash escape sequences as <code>char</code> literals:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">speech</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"</code><code class="se">\"</code><code class="s">Ouch!</code><code class="se">\"</code><code class="s"> said the well.</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"/></pre>

<p>In string literals, unlike <code>char</code> literals, single quotes don’t need a backslash escape, and double quotes do.</p>

<p>A string may span multiple lines:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"In the room the women come and go,</code>
<code class="s">    Singing of Mount Abora"</code><code class="p">);</code><code class="w"/></pre>

<p>The newline character in that string literal is included in the string, and therefore in the output. So are the spaces at the beginning of the second line.</p>

<p>If one line of a string ends with a backslash, then the newline character and the leading whitespace on the next line are dropped:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="s">"It was a bright, cold day in April, and \</code>
<code class="s">    there were four of us—\</code>
<code class="s">    more or less."</code><code class="p">);</code><code class="w"/></pre>

<p>This prints a single line of text. The string contains a single space between “and” and “there”, because there is a space before the backslash in the program, and no space after the dash.</p>

<p>In a few cases, the need to double every backslash in a string is a nuisance. (The classic examples are regular expressions and Windows paths.) <a contenteditable="false" data-primary="raw strings" data-type="indexterm" id="idm45625516342600"/> For these cases, Rust offers <em>raw strings</em>. A raw string is tagged with the lowercase letter <code>r</code>. All backslashes and whitespace characters inside a raw string are included verbatim in the string. No escape sequences are recognized.</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">default_win_install_path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">r"C:\Program Files\Gorillas"</code><code class="p">;</code><code class="w"/>

<code class="kd">let</code><code class="w"> </code><code class="n">pattern</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Regex</code>::<code class="n">new</code><code class="p">(</code><code class="s">r"\d+(\.\d+)*"</code><code class="p">);</code><code class="w"/></pre>

<p>You can’t include a double-quote character in a raw string simply by putting a backslash in front of it—remember, we said <em>no</em> escape sequences are recognized. However, there is a cure for that too. The start and end of a raw string can be marked with pound signs:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">println</code><code class="o">!</code><code class="p">(</code><code class="n">r</code><code class="err">###</code><code class="s">"</code>
<code class="s">    This raw string started with 'r###"</code><code class="err">'</code><code class="p">.</code><code class="w"/>
<code class="w">    </code><code class="n">Therefore</code><code class="w"> </code><code class="n">it</code><code class="w"> </code><code class="n">does</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">end</code><code class="w"> </code><code class="n">until</code><code class="w"> </code><code class="n">we</code><code class="w"> </code><code class="n">reach</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="n">quote</code><code class="w"> </code><code class="n">mark</code><code class="w"> </code><code class="p">(</code><code class="sc">'"'</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="n">followed</code><code class="w"> </code><code class="n">immediately</code><code class="w"> </code><code class="n">by</code><code class="w"> </code><code class="n">three</code><code class="w"> </code><code class="n">pound</code><code class="w"> </code><code class="n">signs</code><code class="w"> </code><code class="p">(</code><code class="err">'###'</code><code class="p">)</code>:
<code class="s">"###);</code></pre>

<p>You can add as few or as many pound signs as needed to make it clear where the raw string ends.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Byte Strings"><div class="sect2" id="byte-strings">
<h2>Byte Strings</h2>

<p><a contenteditable="false" data-primary="byte strings" data-type="indexterm" id="idm45625516144024"/> <a contenteditable="false" data-primary="string literals" data-secondary="byte strings" data-type="indexterm" id="idm45625516142568"/> <a contenteditable="false" data-primary="String types" data-secondary="byte strings" data-type="indexterm" id="idm45625516141032"/> A string literal with the <code>b</code> prefix is a <em>byte string</em>. Such a string is a slice of <code>u8</code> values—that is, bytes—rather than Unicode text:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">method</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"GET"</code><code class="p">;</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">method</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="sc">b'G'</code><code class="p">,</code><code class="w"> </code><code class="sc">b'E'</code><code class="p">,</code><code class="w"> </code><code class="sc">b'T'</code><code class="p">]);</code><code class="w"/></pre>

<p>This combines with all the other string syntax we’ve shown: byte strings can span multiple lines, use escape sequences, and use backslashes to join lines. Raw byte strings start with <code>br"</code>.</p>

<p>Byte strings can’t contain arbitrary Unicode characters. They must make do with ASCII and <code>\xHH</code> escape sequences.</p>

<p>The type of <code>method</code> shown here is <code>&amp;[u8; 3]</code>: it’s a reference to an array of three bytes. It doesn’t have any of the string methods we’ll discuss in a minute. The most string-like thing about it is the syntax we used to write it.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Strings in Memory"><div class="sect2" id="strings-in-memory">
<h2>Strings in Memory</h2>

<p><a contenteditable="false" data-primary="memory" data-secondary="strings in" data-type="indexterm" id="idm45625516122728"/> <a contenteditable="false" data-primary="String types" data-secondary="strings in memory" data-type="indexterm" id="idm45625516121224"/> <a contenteditable="false" data-primary="strings and text" data-secondary="in memory" data-type="indexterm" id="idm45625516119688"/> <a contenteditable="false" data-primary="UTF-8" data-secondary="strings in memory" data-type="indexterm" id="idm45625516067816"/> Rust strings are sequences of Unicode characters, but they are not stored in memory as arrays of <code>char</code>s. Instead, they are stored using UTF-8, a variable-width encoding. Each ASCII character in a string is stored in one byte. Other characters take up multiple bytes.</p>

<p><a data-type="xref" href="#string-layout-figure">Figure 2-3</a> shows the <code>String</code> and <code>&amp;str</code> values created by the code:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">noodles</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"noodles"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">oodles</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">noodles</code><code class="p">[</code><code class="mi">1</code><code class="p">..];</code><code class="w"/>
<code class="kd">let</code><code class="w"> </code><code class="n">poodles</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"ಠ_ಠ"</code><code class="p">;</code><code class="w"/></pre>

<figure><div id="string-layout-figure" class="figure"><img alt="(A String owns its buffer. A &amp;str is a fat pointer to someone else's characters.)" src="Images/rust_0302.png" width="1565" height="913"/>
<h6><span class="label">Figure 2-3. </span>String, &amp;str, and str</h6>
</div></figure>

<p>A <code>String</code> has a resizable buffer holding UTF-8 text. The buffer is allocated on the heap, so it can resize its buffer as needed or requested. In the example, <code>noodles</code> is a <code>String</code> that owns an eight-byte buffer, of which seven are in use. You can think of a <code>String</code> as a <code>Vec&lt;u8&gt;</code> that is guaranteed to hold well-formed UTF-8; in fact, this is how <code>String</code> is implemented.</p>

<p><a contenteditable="false" data-primary="&amp;str (string slice)" data-type="indexterm" id="idm45625516012152"/> <a contenteditable="false" data-primary="string slice (&amp;str)" data-type="indexterm" id="idm45625516010696"/> A <code>&amp;str</code> (pronounced “stir” or “string slice”) is a reference to a run of UTF-8 text owned by someone else: it “borrows” the text. In the example, <code>oodles</code> is a <code>&amp;str</code> referring to the last six bytes of the text belonging to <code>noodles</code>, so it represents the text “oodles”. Like other slice references, a <code>&amp;str</code> is a fat pointer, containing both the address of the actual data and its length. You can think of a <code>&amp;str</code> as being nothing more than a <code>&amp;[u8]</code> that is guaranteed to hold well-formed UTF-8.</p>

<p><a contenteditable="false" data-primary="string literals" data-secondary="defined" data-type="indexterm" id="idm45625516006024"/> A string literal is a <code>&amp;str</code> that refers to preallocated text, typically stored in read-only memory along with the program’s machine code. In the preceding example, <code>poodles</code> is a string literal, pointing to seven bytes that are created when the program begins execution, and that last until it exits.</p>

<p>A <code>String</code> or <code>&amp;str</code>’s <code>.len()</code> method returns its length. The length is measured in bytes, not characters:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"ಠ_ಠ"</code><code class="p">.</code><code class="n">len</code><code class="p">(),</code><code class="w"> </code><code class="mi">7</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"ಠ_ಠ"</code><code class="p">.</code><code class="n">chars</code><code class="p">().</code><code class="n">count</code><code class="p">(),</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/></pre>

<p class="pagebreak-before">It is impossible to modify a <code>&amp;str</code>:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"hello"</code><code class="p">;</code><code class="w"/>
<code class="n">s</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'c'</code><code class="p">;</code><code class="w">    </code><code class="c1">// error: `&amp;str` cannot be modified, and other reasons</code>
<code class="n">s</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="sc">'\n'</code><code class="p">);</code><code class="w">  </code><code class="c1">// error: no method named `push` found for reference `&amp;str`</code></pre>

<p>For creating new strings at run time, use <code>String</code>.</p>

<p>The type <code>&amp;mut str</code> does exist, but it is not very useful, since almost any operation on UTF-8 can change its overall byte length, and a slice cannot reallocate its referent. In fact, the only operations available on <code>&amp;mut str</code> are <code>make_ascii_uppercase</code> and <code>make_ascii_lowercase</code>, which modify the text in place and affect only single-byte characters, by definition.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="String"><div class="sect2" id="string">
<h2>String</h2>

<p><a contenteditable="false" data-primary="String (type)" data-type="indexterm" id="idm45625515896264"/> <code>&amp;str</code> is very much like <code>&amp;[T]</code>: a fat pointer to some data. <code>String</code> is analogous to <code>Vec&lt;T&gt;</code>:</p>

<table>
	<thead>
		<tr class="header">
			<th> </th>
			<th>Vec&lt;T&gt;</th>
			<th>String</th>
		</tr>
	</thead>
	<tbody>
		<tr class="odd">
			<td>Automatically frees buffers</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr class="even">
			<td>Growable</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr class="odd">
			<td><code>::new()</code> and <code>::with_capacity()</code> static methods</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr class="even">
			<td><code>.reserve()</code> and <code>.capacity()</code> methods</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr class="odd">
			<td><code>.push()</code> and <code>.pop()</code> methods</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr class="even">
			<td>Range syntax <code>v[start..stop]</code></td>
			<td>Yes, returns <code>&amp;[T]</code></td>
			<td>Yes, returns <code>&amp;str</code></td>
		</tr>
		<tr class="odd">
			<td>Automatic conversion</td>
			<td><code>&amp;Vec&lt;T&gt;</code> to <code>&amp;[T]</code></td>
			<td><code>&amp;String</code> to <code>&amp;str</code></td>
		</tr>
		<tr class="even">
			<td>Inherits methods</td>
			<td>From <code>&amp;[T]</code></td>
			<td>From <code>&amp;str</code></td>
		</tr>
	</tbody>
</table>

<p>Like a <code>Vec</code>, each <code>String</code> has its own heap-allocated buffer that isn’t shared with any other <code>String</code>. When a <code>String</code> variable goes out of scope, the buffer is automatically freed, unless the <code>String</code> was moved.</p>

<p>There are several ways to create <code>String</code>s:</p>

<ul>
	<li>
	<p>The <code>.to_string()</code> method converts a <code>&amp;str</code> to a <code>String</code>. This copies the string:</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">error_message</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"too many pets"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"/></pre>
	</li>
	<li>
	<p>The <code>format!()</code> macro works just like <code>println!()</code>, except that it returns a new <code>String</code> instead of writing text to stdout, and it doesn’t automatically add a newline at the end.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">format</code><code class="o">!</code><code class="p">(</code><code class="s">"{}°{:02}′{:02}″N"</code><code class="p">,</code><code class="w"> </code><code class="mi">24</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">23</code><code class="p">),</code><code class="w"/>
<code class="w">           </code><code class="s">"24°05′23″N"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/></pre>
	</li>
	<li>
	<p>Arrays, slices, and vectors of strings have two methods, <code>.concat()</code> and <code>.join(sep)</code>, that form a new <code>String</code> from many strings.</p>

	<pre data-code-language="rust" data-type="programlisting">
<code class="kd">let</code><code class="w"> </code><code class="n">bits</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">vec</code><code class="o">!</code><code class="p">[</code><code class="s">"veni"</code><code class="p">,</code><code class="w"> </code><code class="s">"vidi"</code><code class="p">,</code><code class="w"> </code><code class="s">"vici"</code><code class="p">];</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">bits</code><code class="p">.</code><code class="n">concat</code><code class="p">(),</code><code class="w"> </code><code class="s">"venividivici"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="n">bits</code><code class="p">.</code><code class="n">join</code><code class="p">(</code><code class="s">", "</code><code class="p">),</code><code class="w"> </code><code class="s">"veni, vidi, vici"</code><code class="p">);</code><code class="w"/></pre>
	</li>
</ul>

<p>The choice sometimes arises of which type to use: <code>&amp;str</code> or <code>String</code>. <a data-type="xref" href="ch04.xhtml#references">Chapter 4</a> addresses this question in detail. For now it will suffice to point out that a <code>&amp;str</code> can refer to any slice of any string, whether it is a string literal (stored in the executable) or a <code>String</code> (allocated and freed at run time). This means that <code>&amp;str</code> is more appropriate for function arguments when the caller should be allowed to pass either kind of string.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Using Strings"><div class="sect2" id="using-strings">
<h2>Using Strings</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="using" data-type="indexterm" id="idm45625515709480"/> Strings support the <code>==</code> and <code>!=</code> operators. Two strings are equal if they contain the same characters in the same order (regardless of whether they point to the same location in memory).</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="s">"ONE"</code><code class="p">.</code><code class="n">to_lowercase</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="s">"one"</code><code class="p">);</code><code class="w"/></pre>

<p><a contenteditable="false" data-primary="comparison operators" data-secondary="with strings" data-type="indexterm" id="idm45625515697576"/> Strings also support the comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>, as well as many useful methods and functions that you can find in the online documentation by searching for “<code>str</code> (primitive type)” or the “<code>std::str</code>” module (or just flip to XREF HERE). Here are a few examples:</p>

<pre data-code-language="rust" data-type="programlisting">
<code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="s">"peanut"</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="s">"nut"</code><code class="p">));</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"ಠ_ಠ"</code><code class="p">.</code><code class="n">replace</code><code class="p">(</code><code class="s">"ಠ"</code><code class="p">,</code><code class="w"> </code><code class="s">"■"</code><code class="p">),</code><code class="w"> </code><code class="s">"■_■"</code><code class="p">);</code><code class="w"/>
<code class="n">assert_eq</code><code class="o">!</code><code class="p">(</code><code class="s">"    clean</code><code class="se">\n</code><code class="s">"</code><code class="p">.</code><code class="n">trim</code><code class="p">(),</code><code class="w"> </code><code class="s">"clean"</code><code class="p">);</code><code class="w"/>

<code class="k">for</code><code class="w"> </code><code class="n">word</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="s">"veni, vidi, vici"</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="s">", "</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">assert</code><code class="o">!</code><code class="p">(</code><code class="n">word</code><code class="p">.</code><code class="n">starts_with</code><code class="p">(</code><code class="s">"v"</code><code class="p">));</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Keep in mind that, given the nature of Unicode, simple <code>char</code>-by-<code>char</code> comparison does <em>not</em> always give the expected answers. For example, the Rust strings <code>"th\u{e9}"</code> and <code>"the\u{301}"</code> are both valid Unicode representations for <i>thé</i>, the French word for tea. Unicode says they should both be displayed and processed in the same way, but Rust treats them as two completely distinct strings. Similarly, Rust’s ordering operators like <code>&lt;</code> use a simple lexicographical order based on character code point values. This ordering only sometimes resembles the ordering used for text in the user’s language and culture. We discuss these issues in more detail in XREF HERE.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Other String-Like Types"><div class="sect2" id="other-string-like-types">
<h2>Other String-Like Types</h2>

<p><a contenteditable="false" data-primary="String types" data-secondary="non-Unicode strings" data-type="indexterm" id="idm45625515557288"/> Rust guarantees that strings are valid UTF-8. Sometimes a program really needs to be able to deal with strings that are <em>not</em> valid Unicode. This usually happens when a Rust program has to interoperate with some other system that doesn’t enforce any such rules. For example, in most operating systems it’s easy to create a file with a filename that isn’t valid Unicode. What should happen when a Rust program comes across this sort of filename?</p>

<p>Rust’s solution is to offer a few string-like types for these situations:</p>

<ul>
	<li>
	<p>Stick to <code>String</code> and <code>&amp;str</code> for Unicode text.</p>
	</li>
	<li>
	<p>When working with filenames, use <code>std::path::PathBuf</code> and <code>&amp;Path</code> instead.</p>
	</li>
	<li>
	<p>When working with binary data that isn’t character data at all, use <code>Vec&lt;u8&gt;</code> and <code>&amp;[u8]</code>.</p>
	</li>
	<li>
	<p>When working with environment variable names and command-line arguments in the native form presented by the operating system, use <code>OsString</code> and <code>&amp;OsStr</code>.</p>
	</li>
	<li>
	<p>When interoperating with C libraries that use null-terminated strings, use <code>std::ffi::CString</code> and <code>&amp;CStr</code>. <a contenteditable="false" data-primary="" data-startref="C03-types.html19" data-type="indexterm" id="idm45625515545112"/></p>
	</li>
</ul>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Beyond the Basics"><div class="sect1" id="beyond-the-basics">
<h1>Beyond the Basics</h1>

<p>Types are a central part of Rust. We’ll continue talking about types and introducing new ones throughout the book. In particular, Rust’s user-defined types give the language much of its flavor, because that’s where methods are defined. There are three kinds of user-defined types, and we’ll cover them in three successive chapters: structs in <a data-type="xref" href="ch08.xhtml#structs">Chapter 8</a>, enums in <a data-type="xref" href="ch09.xhtml#enums-and-patterns">Chapter 9</a>, and traits in <a data-type="xref" href="ch10.xhtml#traits-and-generics">Chapter 10</a>.</p>

<p>Functions and closures have their own types, covered in XREF HERE. And the types that make up the standard library are covered throughout the book. For example, XREF HERE presents the standard collection types. <a contenteditable="false" data-primary="" data-startref="C03-types.html0" data-type="indexterm" id="idm45625515537848"/></p>

<p>All of that will have to wait, though. Before we move on, it’s time to tackle the concepts that are at the heart of Rust’s safety rules.</p>
</div></section>
</div></section></div></body>
</html>