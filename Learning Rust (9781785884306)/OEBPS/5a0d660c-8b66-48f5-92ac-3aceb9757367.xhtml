<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generics and arrays</h1>
                </header>
            
            <article>
                
<p>For those coming from a C# or C++ background, you will no doubt be used to generic types (often referred to as having a type <kbd>T</kbd>); you will be used to seeing things like this:</p>
<pre>T a = new T(); </pre>
<p>Generics allow defining methods for several types. In its most general form, <kbd>T</kbd> means "any type." The following function, for instance, takes two arguments that can be any type <kbd>T</kbd>:</p>
<pre>fn generic_function&lt;T&gt;(a: T, b: T) </pre>
<p><kbd>T</kbd>, as has been established, can be of any type. This means that we cannot do much with them, since only a few methods are implemented for "any type." For instance, if we would like to add these variables together, we would need to restrict the generic types somewhat. We would essentially need to tell Rust that "T may be of any type, as long as it implements addition." More about this later.</p>


            </article>

            
        </section>
    </div></body>
</html>