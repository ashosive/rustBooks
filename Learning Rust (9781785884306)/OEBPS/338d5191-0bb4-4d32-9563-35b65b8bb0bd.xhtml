<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling Rust from another language</h1>
                </header>
            
            <article>
                
<p>Rust can also be called from a different language and it's a simple process. The only caveat is that the name used has to be unmangled. If you recall from <a href="9764ae84-9948-4bc8-a9d7-7537b2f31723.xhtml">Chapter 8</a>, <em>The Rust Application Lifetime</em>, when you use a generic, the compiler generates the necessary code to ensure the linker works. It does this by mangling the names to ensure that the correct code is compiled and called when the code needs it.</p>
<p>Unmangling is the opposite of this; it preserves the name of the function in use:</p>
<pre>#[no_mangle] 
pub extern fn hello_world() -&gt; *const u8 { 
    "Hello, world!\0".as_ptr() 
} </pre>
<p>This can then be called from within your own (non-Rust) application.</p>


            </article>

            
        </section>
    </div></body>
</html>