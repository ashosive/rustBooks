<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">String methods</h1>
                </header>
            
            <article>
                
<p>Strings are important in any language. Without them, it becomes difficult to communicate with users, and if data is coming from a web service (in the form of XML, plain text, or JSON), this data will need to be manipulated. Rust provides the developer with a number of methods in the standard library to deal with strings. Here's a table of some useful methods (don't worry about the types yet):</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>What it does</strong></p>
</td>
<td>
<p><strong>Usage (or example project)</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>from(&amp;str) -&gt; String</kbd></p>
</td>
<td>
<p>This method creates a new String from a string slice.</p>
</td>
<td>
<pre>let s   = String::from("Richmond");   </pre></td>
</tr>
<tr>
<td>
<p><kbd>from_utf8( Vec &lt; u8 &gt; ) -&gt; Result&lt;String, FromUtf8Error&gt;</kbd></p>
</td>
<td>
<p>This method creates a new string buffer from a valid vector of UTF-8 characters. It will fail if the vector contains non-UTF8 data.</p>
</td>
<td>
<pre>   
let s   = String::from_utf8(vec!(33, 34)).expect("UTF8 decoding failed);   </pre></td>
</tr>
<tr>
<td>
<p><kbd>with_capacity(usize) -&gt; String</kbd></p>
</td>
<td>
<p>This method preallocates a String with a number of bytes.</p>
</td>
<td>
<pre>let s   = String::with_capacity(10);   </pre></td>
</tr>
<tr>
<td>
<p><kbd>as_bytes -&gt; &amp;[u8]</kbd></p>
</td>
<td>
<p>This method outputs a String as a byte slice.</p>
</td>
<td>
<pre>let s = "A String".to_owned();<br/>let slice = s.as_bytes();</pre></td>
</tr>
<tr>
<td>
<p><kbd>insert(usize, char)</kbd></p>
</td>
<td>
<p>This method inserts <kbd>char</kbd> at position <kbd>index</kbd>.</p>
</td>
<td>
<pre>let mut s = "A String".to_owned();<br/>s.insert(2, 'S');<br/>// s = "A SString"</pre></td>
</tr>
<tr>
<td>
<p><kbd>len -&gt; usize</kbd></p>
</td>
<td>
<p>This method returns the length of the String in bytes. It may therefore be larger than the number of characters in the String.</p>
</td>
<td>
<pre>let s = "A String äö";<br/>// s.len() =&gt; 13</pre></td>
</tr>
<tr>
<td>
<p><kbd>is_empty -&gt; bool</kbd></p>
</td>
<td>
<p>This method returns <kbd>true</kbd> if the String is empty.</p>
</td>
<td>
<pre>let s1 = "".to_owned();<br/>let s2 = "A String".to_owned();<br/>// s1.is_empty() =&gt; true<br/>// s2.is_empty() =&gt; false</pre></td>
</tr>
<tr>
<td>
<p><kbd>is_char_boundary(usize) -&gt; bool</kbd></p>
</td>
<td>
<p>This method returns <kbd>true</kbd> if a character at <kbd>index</kbd> falls on a Unicode boundary.</p>
</td>
<td>
<pre>let s1 = "Hellö World";<br/>// s1.is_char_boundary(5) =&gt; false<br/>// s1.is_char_boundary(6) =&gt; true</pre></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div></body>
</html>