<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced the primitives of concurrent computation. Subprocesses, forked processes, and threads are the basic building blocks of all concurrent applications. In Rust threads, there are additional concerns that are introduced by the language to encourage type and thread safety.</p>
<p>In several examples, we built a concurrent web server using fork or threads. Later, while exploring thread behavior, we looked closely at what data can be shared between threads and how information can be sent between threads safely.</p>
<p>In the design pattern section, we introduced the actor design pattern. This popular technique combines some elements of object-oriented programming with other concepts from functional programming. The result is a programming tool designed specifically for complex resilient concurrency.</p>
<p>In the next chapter, we will explore performance, debugging, and metaprogramming. Performance can be hard to measure or compare, but we will try to introduce habits that are strictly good for performance. To help debugging, we will look at proactive and reactive techniques to solve issues. Proactive debugging is a set of techniques, such as proper error handling, that either prevents bugs or makes them easier to document and resolve. Reactive techniques are useful for difficult bugs that don't have an obvious cause. Finally, metaprogramming can do lots of complicated work behind the scenes to make ugly code look nicer.</p>


            </article>

            
        </section>
    </div></body>
</html>