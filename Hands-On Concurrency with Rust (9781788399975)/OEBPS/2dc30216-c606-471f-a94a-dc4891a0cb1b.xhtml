<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Futurism – Near-Term Rust</h1>
                </header>
            
            <article>
                
<p class="mce-root">We've <span>covered a lot of material in this</span> book<span>.</span><br/></p>
<p>If you already knew parallel programming well from another systems programming language, I hope that now you've got a confident handle on the way Rust operates. Its ownership model is strict, and can feel foreign at first. Unsafe Rust, if my own experiences are any kind of general guide, feels like more familiar ground. I hope that you too have come to appreciate the general safety of Rust, as well as its ability to do fiddly things in memory when needed. I find being able to implement unsafe code that is then wrapped up in a safe interface nothing short of incredible.</p>
<p>If you knew parallel programming fairly well from a high-level, garbage-collected programming language, then I hope that this book has served as an introduction to parallel programming at a systems level. As you know, memory safety does not guarantee correct operation, hence this book's continual focus on testing—generative and fuzz, in addition to performance inspection—and careful reasoning about models. Rust, I have argued, is one of the easier systems languages to do parallel programming well in because of the language's focus on ownership management with lifetimes and the strong, static type system. Rust is not immune to bugs—in fact, it's vulnerable to a wide variety—but these are common to all languages on modern hardware, and Rust does manage to solve a swath of memory-related issues.</p>
<p>If you already knew Rust, but didn't know much about parallel programming, I very much hope that this book has managed to convince you of one thing—c<span>oncurrency is not magic. Parallel programming is a wide, wide field of endeavor, one that takes a great deal of study, but it can be understood and mastered. Moreover, it need not be mastered all at once. The shape of this book argues for one path among several. May this book be the first of many on your journey.</span></p>
<p>Whatever your background, thank you for reading through to the end. I know that, at times, the material covered was not easy and it must have taken some real willpower to get through it all. I appreciate it. I wrote this book to be what I would have wanted for myself ten years ago. It was a real pleasure getting the opportunity to write it out for you.</p>
<p><span>By the end of this chapter, we will have:</span></p>
<ul>
<li><span>Discussed the future of SIMD in Rust</span></li>
<li><span>Discussed the future of async IO in Rust</span></li>
<li><span>Discussed the possibility of specialization being stablized and in what fashion</span></li>
<li><span>Discussed more extensive testing methods for Rust</span></li>
<li><span>Introduced various avenues to get involved with the Rust community</span></li>
</ul>


            </article>

            
        </section>
    </div></body>
</html>