<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Zero sized types</h1>
                </header>
            
            <article>
                
<p>Rust also supports <em>zero sized types</em> or ZSTs; structs with no fields, the unit type <kbd>()</kbd>, or arrays with no size are all zero sized. The fact that the type has no size is a boon to optimization and dead-tree removal. Rust APIs often include return types like so: <kbd>Result&lt;(), a_mod::ErrorKind&gt;</kbd>. This type signals that while the function may error, its return value in the happy path is the unit type. These types are somewhat rare in practice but unsafe, and Rust must be aware of them. Many allocators return null when asked to allocate zero bytes—making the allocation of a ZST indistinguishable from the allocator being unable to find free memory—and pointer offsets from a ZST are of zero offset. Both of these considerations will be important in this chapter.</p>


            </article>

            
        </section>
    </div></body>
</html>