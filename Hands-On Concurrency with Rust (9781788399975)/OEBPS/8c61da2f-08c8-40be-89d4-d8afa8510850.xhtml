<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sequential Rust Performance and Testing</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"Make it work, then make it beautiful, then if you really, really have to, make it fast."</div>
<div class="packt_quote">                                                                                                         - <em>Joe Armstrong</em></div>
<p>In the previous chapter, we discussed the basics of modern computer architectures—the CPU and its function, memory hierarchies, and their interplay. We left off with a brief introduction to debugging and performance analysis of Rust programs. In this chapter, we'll continue that discussion, digging into the performance characteristics of sequential Rust programs, deferring, for now, considerations of concurrent performance. We'll also be discussing testing techniques for demonstrating the fitness for purpose of a Rust program. Why, in a book about parallel programming, would we wish to devote an entire chapter to just sequential programs? The techniques we'll discuss in this sequential setting are applicable and vital to a parallel setting. What we gain here is the meat of the concern—being fast <em>and</em> correct—without the complication that parallel programming brings, however, we'll come to that in good time. It is also important to understand that the production of fast parallel code comes part and parcel with the production of fast sequential code. That's on account of there being a cold, hard mathematical reality that we'll deal with throughout the book.</p>
<p>By the close of the chapter, we will: </p>
<ul>
<li>Have learned about <span>Amdahl's and Gustafson's laws</span></li>
<li>Have investigated the internals of the Rust standard library <kbd>HashMap</kbd></li>
<li>Be able to use QuickCheck to perform randomized validating of an alternative HashMap implementation</li>
<li>Be able to use American Fuzzy Lop to demonstrate the lack of crashes in the same</li>
<li>Have used Valgrind and Linux Perf to examine the performance of Rust software</li>
</ul>


            </article>

            
        </section>
    </div></body>
</html>