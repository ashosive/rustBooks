<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Seer, a symbolic execution engine for Rust</h1>
                </header>
            
            <article>
                
<p>Fuzzing, as we discussedÂ previously, explores the state space of a program using random inputs and binary instrumentation. This can be, as we've seen, slow. The ambition of symbolic execution (<a href="https://en.wikipedia.org/wiki/Symbolic_execution">https://en.wikipedia.org/wiki/Symbolic_execution</a>) is to allow the same exploration of state space, but without random probing. Searching for program crashes is one area of application, but it can also be used with proof tools. Symbolic execution, in a carefully written program, can let you demonstrate that your program can never reach error states. Rust has a partially implemented symbolic execution tool, seer (<a href="https://github.com/dwrensha/seer">https://github.com/dwrensha/seer</a>). The project uses z3, a constraint solver, to generate branching inputs at program branches. Seer's README, as of SHA <kbd>91f12b2291fa52431f4ac73f28d3b18a0a56ff32</kbd>, amusingly decodes a hash. This is done by defining the decoding of the hashed data to be a crashable condition. Seer churns for a bit and then decodes the hash, crashing the program. It reports the decoded value among the error report.</p>
<p>It's still early days for seer, but the potential is there.</p>


            </article>

            
        </section>
    </div></body>
</html>