<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What this book covers</h1>
                </header>
            
            <article>
                
<p>The material that this book covers is very broad, and it attempts to go into that material at some depth. The material is written so that you can work straight through, but it's also expected that some readers will only be interested in a subset of the content.</p>
<p class="mce-root"><a href="5f3aec9d-fd53-48ff-9ba8-43ce13e91cff.xhtml" target="_blank">Chapter 1</a>,<span> </span><em>Preliminaries – Machine Architecture and Getting Started with Rust</em>, discusses modern CPU architectures, focusing specifically on x86 and ARM. These two architectures will be the focus of the book. The reader is assumed to be familiar with Rust, but we will also discuss verifying that your installation works as expected.</p>
<p class="mce-root"><a href="8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml" target="_blank">Chapter 2</a>,<span> </span><em>Sequential Rust Performance and Testing</em>, introduces inspecting the performance of a Rust program. The details of the underlying computer hardware are especially important in this: cache interactions, memory layout, and exploiting the nature of the problem domain are key to writing fast programs. However, <em>fast</em> doesn't matter if the results are inaccurate. This chapter also focuses on testing in Rust.</p>
<p class="mce-root"><a href="605ce307-29ed-4b5a-961e-8d327467b84f.xhtml" target="_blank">Chapter 3</a>,<span> </span><em>The Rust Memory Model – Ownership, References and Manipulation</em>, discusses the memory model of Rust, focusing specifically on what makes Rust <em>memory safe</em>, how the language is constrained to achieve such safety and how these constraints influence the fundamental types' implementations. The reader will understand the borrow checker and its ways at the close of this chapter.</p>
<p class="mce-root"><a href="5a332d94-37e4-4748-8920-1679b07e2880.xhtml" target="_blank">Chapter 4</a>,<span> </span><em>Sync and Send – the Foundation of Rust Concurrency</em>, is the first in which notions of concurrency make their appearance. The chapter discusses the<span> </span><kbd>Sync</kbd><span> </span>and<span> </span><kbd>Send</kbd><span> </span>traits, both why they exist and their implications. The chapter closes with a concrete demonstration of a multithreaded Rust program. Not the last, either.</p>
<p class="mce-root"><a href="e2de1ba7-c291-494e-82da-37fee7323c1d.xhtml" target="_blank">Chapter 5</a>,<span> </span><em>Locks – Mutex, Condvar, Barriers and RWLock</em>, introduces the <em>coarse</em> synchronization methods available to the Rust programmer. Each is examined in turn and demonstrated in context of an industrial Rust project, hopper. The <em>coarse</em> synchronization methods are elaborated on in more detail in a series of smaller projects and data structures.</p>
<p class="mce-root"><a href="d42acb0b-a05e-4068-894f-81365d147bf4.xhtml" target="_blank">Chapter 6</a>,<span> </span><em>Atomics – the Primitives of Synchronization</em>, introduces <em>fine</em> synchronization in terms of atomic primitives available on all modern CPUs. This is an exceedingly difficult topic, and a deep investigation into atomic programming and its methods is carried out. The chapter lock-free, atomic data structures, and production-grade codebases. The reader will construct many of the <em>coarse</em> synchronization mechanisms seen in <a href="https://cdp.packtpub.com/rust_concurrency/wp-admin/post.php?post=215&amp;action=edit#post_94" target="_blank">Chapter 5</a><span>,</span><span> </span><em>Locks<span> </span>– Mutex, Condvar, Barriers and RWLock</em>.</p>
<p><a href="2099e79d-45cd-46cb-bf58-fc27b27b84ec.xhtml" target="_blank">Chapter 7</a>,<span> </span><em>Atomics – Safely Reclaiming Memory</em>, discusses at length one of the key difficulties of atomic programming in any language—safely deallocating memory. The main three methods—reference counting, hazard pointers, epoch-based reclamation—are each discussed in great detail, and production-worthy codebases are investigated. Crossbeam, especially, is discussed in great detail.</p>
<p class="mce-root"><a href="d4802512-564b-4037-9407-b6035bd38f31.xhtml" target="_blank">Chapter 8</a>,<span> </span><em>High-Level Parallelism – Threadpools, Parallel Iterators and </em><em>Processes</em>, motivates and explains the implementation of thread pooling. Having this knowledge in hand, the Rayon project is investigated and subsequently used in a complex project that benefits greatly from simple data parallelism.</p>
<p class="mce-root"><a href="48d410d6-8ff7-40ec-9548-6007b789bd17.xhtml" target="_blank">Chapter 9</a>,<span> </span><em>FFI and Embedding – Combining Rust and Other Languages</em>, extends the final project of <a href="d4802512-564b-4037-9407-b6035bd38f31.xhtml" target="_blank">Chapter 8</a><span>,</span><span> </span><em>High-Level Parallelism – Threadpools, Parallel Iterators, and </em><em>Processes</em> by embedding C code into it. The rlua project, a convenient library to extend Rust programs with lua programs, is discussed. The chapter closes by compiling Rust for embedding into C, Python, and Erlang projects.</p>
<p class="mce-root"><a href="2dc30216-c606-471f-a94a-dc4891a0cb1b.xhtml" target="_blank">Chapter 10</a>,<span> </span><em>Futurism – Near-Term Rust</em>, closes the book with a discussion of the near-term changes to the language that are apropos to parallel programmers, as well as a few miscellaneous remarks.</p>


            </article>

            
        </section>
    </div></body>
</html>